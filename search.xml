<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2022/03/05/RocketMQ/"/>
      <url>/2022/03/05/RocketMQ/</url>
      
        <content type="html"><![CDATA[<p>已在<a href="https://github.com/Floating-Dreamm/RocketMQPaser">我的Github</a>上上传了阅读源码需要的一些注释，读者可以下下来跟着流程看一下。</p><p>默认大家对MQ都有一些了解，像异步解耦啊、削峰填谷啊，就不多啰嗦了，直接干货。</p><p>首先需要了解RocketMQ的基本组件：</p><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>负责消费消息，一般是后台系统负责异步消费。对应的就把它当成顾客，既然生产了消息，我过来消费，没问题吧？这没有问题。而且它还贴心的提供了两种消费形式：</p><ul><li>拉模式：每次顾客都需要到店里去消费；</li><li>推模式：店里到货了，打包好直接送到消费者手里（这感觉贴心多了）。</li></ul><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p><h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><p>NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer和Consumer仍然可以动态感知Broker的路由的信息。</p><h2 id="其他重要概念"><a href="#其他重要概念" class="headerlink" title="其他重要概念"></a>其他重要概念</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a><strong>Topic</strong></h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 同一个Topic下的数据，会分片保存到不同的Broker上，而每一个分片单位，就叫做MessageQueue。</p><p>MessageQueue是生产者发送消息与消费者消费消息的最小单位。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a><strong>Message</strong></h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题Topic。 RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过 Message ID和Key查询消息的功能。</p><p>并且Message上有一个为消息设置的标志，Tag标签。用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p>下图为RocketMQ官网的技术架构图:</p><p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/uTools_1646621962622.jpg"></p><p>结合部署架构图，描述集群工作流程：</p><ul><li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 中间件 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言</title>
      <link href="/2022/03/03/%E4%B8%80%E4%BA%9B%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/"/>
      <url>/2022/03/03/%E4%B8%80%E4%BA%9B%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>​        首先想感谢一下提供这些开源软件及安装教程的开发者们。从零开始搭建一个博客，光靠一个人从头开始，耗时耗力耗神，有了这些工具之后，让我可以在很短时间内实现自己的博客。我是参考知乎上一位作者，每一步都讲的很详细，如果有读者也想自己搭建一个自己的博客，可以参考一下，<a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客</a>。</p><p>​        当程序员是件很酷的事，反正我一直是这么觉得。想做一名合格的java程序员，要学的东西还真不少，java基础、网络编程、多线程相关、框架源码、中间件、数据库等等。要真正把这些掌握，还是要花挺多时间的。很多知识点学过之后，可能自己似懂非懂，不如把这些以自己的理解讲出来，更加能加深印象。接下来我准备持续更新一些java开发中用到的一些技术，不一定能每天更新，但是尽量吧。</p><p>​        先介绍一些基本功能吧。</p><ul><li><p>在<strong>首页</strong>标签下，我会持续更新一些技术源码等；各位读者可以通过网站的搜索功能或者标签跳转到想看的专题；当然，由于个人能力有限，如果发现有错误的地方，可以点击导航栏最下面的<strong>E-mail</strong>标签与我联系，我会及时查看每一位读者的来信；</p></li><li><p>在<strong>随笔</strong>标签下，我会记录一些日常开发中遇到的bug，如果解决了会及时贴上去，各位读者可以通过搜索功能查看是否有与自己遇到相同的问题；另外，在随笔标签下，我开启了评论功能，如果读者有更好的解决方案，可以在下方留言。</p></li><li><p><strong>关于</strong>标签暂时还没想好要干啥，如果读者有什么需求可以联系我。</p></li></ul><p>​        同时，也希望读者能形成知识和劳动付费的意识。如果觉得文章对您有帮助，小小的打赏是对创作者最大的支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/02/hello-world/"/>
      <url>/2022/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
