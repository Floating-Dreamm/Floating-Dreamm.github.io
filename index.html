<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cailiang.website","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
<meta property="og:type" content="website">
<meta property="og:title" content="Boyce">
<meta property="og:url" content="http://cailiang.website/index.html">
<meta property="og:site_name" content="Boyce">
<meta property="og:description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="靓仔灬很忙">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cailiang.website/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Boyce</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Boyce</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-essays">

    <a href="/essays/" rel="section"><i class="fa fa-book fa-fw"></i>随笔</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-quickhelp">

    <a href="/categories/quickHelp/" rel="section"><i class="fa fa-bolt fa-fw"></i>快捷</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Floating-Dreamm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/08/11/Flask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/11/Flask/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-11 15:15:18 / 修改时间：17:28:22" itemprop="dateCreated datePublished" datetime="2022-08-11T15:15:18+08:00">2022-08-11</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="title-Flask入门"><a href="#title-Flask入门" class="headerlink" title="title: Flask入门"></a>title: Flask入门</h2><p>date: 2022-08-11 15:15:18<br>tags:</p>
<ul>
<li>flask</li>
<li>web<br>categories: </li>
<li>python</li>
</ul>
<h1 id="Flask简介："><a href="#Flask简介：" class="headerlink" title="Flask简介："></a>Flask简介：</h1><p>Flask诞生于2010年，是用Python语言基于Werkzeug工具箱编写的轻量级Web开发框架。</p>
<p>Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展（邮件扩展Flask-Mail，用户认证Flask-Login），都需要用第三方的扩展来实现。</p>
<p>其 WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。这两个也是Flask框架的核心。</p>
<p>Python最出名的框架要数Django，此外还有Flask、Tornado等框架。虽然Flask不是最出名的框架，但是Flask应该算是最灵活的框架之一，这也是Flask受到广大开发者喜爱的原因。</p>
<p><strong>Flask常用扩展包：</strong></p>
<ul>
<li>Flask-SQLalchemy：操作数据库；</li>
<li>Flask-migrate：管理迁移数据库；</li>
<li>Flask-Mail:邮件；</li>
<li>Flask-WTF：表单；</li>
<li>Flask-Bable：提供国际化和本地化支持，翻译；</li>
<li>Flask-script：插入脚本；</li>
<li>Flask-Login：认证用户状态；</li>
<li>Flask-OpenID：认证；</li>
<li>Flask-RESTful：开发REST API的工具；</li>
<li>Flask-Bootstrap：集成前端Twitter Bootstrap框架；</li>
<li>Flask-Moment：本地化日期和时间；</li>
<li>Flask-Admin：简单而可扩展的管理接口的框架</li>
</ul>
<blockquote>
<p>扩展列表：<a target="_blank" rel="noopener" href="http://flask.pocoo.org/extensions/">http://flask.pocoo.org/extensions/</a></p>
</blockquote>
<ol>
<li>中文文档（<a target="_blank" rel="noopener" href="http://docs.jinkan.org/docs/flask/%EF%BC%89">http://docs.jinkan.org/docs/flask/）</a></li>
<li>英文文档（<a target="_blank" rel="noopener" href="http://flask.pocoo.org/docs/0.12/%EF%BC%89">http://flask.pocoo.org/docs/0.12/）</a></li>
</ol>
<h2 id="Flask-安装环境"><a href="#Flask-安装环境" class="headerlink" title="Flask 安装环境"></a>Flask 安装环境</h2><p>使用虚拟环境安装Flask，可以避免包的混乱和版本的冲突，虚拟环境是Python解释器的副本，在虚拟环境中你可以安装扩展包，为每个程序单独创建的虚拟环境，可以保证程序只能访问虚拟环境中的包。而不会影响系统中安装的全局Python解释器，从而保证全局解释器的整洁。</p>
<p>虚拟环境使用virtualenv创建，可以查看系统是否安装了virtualenv：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --version</span><br></pre></td></tr></table></figure>

<p><strong>安装虚拟环境</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install virtualenv</span><br><span class="line">$ sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure>

<p><strong>创建虚拟环境(须在联网状态下)</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkvirtualenv Flask_py</span><br></pre></td></tr></table></figure>

<p><strong>安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 1、创建目录用来存放虚拟环境</span><br><span class="line">mkdir </span><br><span class="line">$HOME/.virtualenvs</span><br><span class="line"></span><br><span class="line"># 2、打开~/.bashrc文件，并添加如下：</span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"></span><br><span class="line"># 3、运行</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p><strong>进入虚拟环境</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ workon Flask_py</span><br></pre></td></tr></table></figure>

<p><strong>退出虚拟环境</strong></p>
<p>如果所在环境为真实环境，会提示deactivate：未找到命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate Flask_py</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-安装Flask"><a href="#1-2-1-安装Flask" class="headerlink" title="1.2.1 安装Flask"></a>1.2.1 安装Flask</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指定Flask版本安装</span><br><span class="line">$ pip install flask==0.10.1</span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>Mac系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ easy_install flask==0.10.1</span><br></pre></td></tr></table></figure>

<p><strong>在ipython中测试安装是否成功</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ from flask import Flask</span><br></pre></td></tr></table></figure>

<p><img src="/../images/install_success1.png" alt="安装成功1"></p>
<p><img src="/../images/install_success2.png" alt="安装成功2"></p>
<h2 id="requirements-文件"><a href="#requirements-文件" class="headerlink" title="requirements 文件"></a>requirements 文件</h2><p>Python 项目中必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号，以便在新环境中进行部署操作。</p>
<p>在虚拟环境使用以下命令将当前虚拟环境中的依赖包以版本号生成至文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装或升级包后，最好更新这个文件以保证虚拟环境中的依赖包。</p>
</blockquote>
<p>需求文件的内容示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">alembic==0.9.2</span><br><span class="line">blinker==1.4</span><br><span class="line">click==6.7</span><br><span class="line">dominate==2.3.1</span><br><span class="line">Flask==0.10.1</span><br><span class="line">Flask-Bootstrap==3.3.7.1</span><br><span class="line">Flask-Login==0.4.0</span><br><span class="line">Flask-Mail==0.9.1</span><br><span class="line">Flask-Migrate==2.0.4</span><br><span class="line">Flask-Redis==0.3.0</span><br><span class="line">Flask-Script==2.0.5</span><br><span class="line">Flask-SQLAlchemy==2.2</span><br><span class="line">Flask-Testing==0.6.2</span><br><span class="line">Flask-WTF==0.14.2</span><br><span class="line">gunicorn==19.7.1</span><br><span class="line">itsdangerous==0.24</span><br><span class="line">Jinja2==2.9.6</span><br><span class="line">Mako==1.0.6</span><br><span class="line">MarkupSafe==1.0</span><br><span class="line">MySQL-python==1.2.5</span><br><span class="line">mysqlclient==1.3.10</span><br><span class="line">PyMySQL==0.7.11</span><br><span class="line">python-dateutil==2.6.0</span><br><span class="line">python-editor==1.0.3</span><br><span class="line">redis==2.10.5</span><br><span class="line">six==1.10.0</span><br><span class="line">SQLAlchemy==1.1.10</span><br><span class="line">uWSGI==2.0.15</span><br><span class="line">visitor==0.1.3</span><br><span class="line">Werkzeug==0.12.2</span><br><span class="line">WTForms==2.1</span><br><span class="line">xmltodict==0.11.0</span><br></pre></td></tr></table></figure>

<p>当需要创建这个虚拟环境的完全副本，可以创建一个新的虚拟环境，并在其上运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="从-Hello-World-开始"><a href="#从-Hello-World-开始" class="headerlink" title="从 Hello World 开始"></a>从 Hello World 开始</h2><h3 id="Flask程序运行过程"><a href="#Flask程序运行过程" class="headerlink" title="Flask程序运行过程"></a>Flask程序运行过程</h3><ol>
<li>当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。</li>
<li>此时，Web服务器会把来自客户端的所有请求都交给Flask程序实例</li>
<li>程序实例使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。</li>
<li>根据每个URL请求，找到具体的视图函数并进行调用。<ul>
<li>在Flask程序中，路由的实现一般是通过程序实例的装饰器实现。</li>
</ul>
</li>
<li>Flask调用视图函数后，可以返回两种内容：<ul>
<li>字符串内容：将视图函数的返回值作为响应的内容，返回给客户端(浏览器)</li>
<li>HTML模版内容：获取到数据后，把数据传入HTML模板文件中，模板引擎负责渲染HTTP响应数据，然后返回响应数据给客户端(浏览器)</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><ul>
<li>新建Flask项目</li>
<li>导入Flask类</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br></pre></td></tr></table></figure>

<ul>
<li>Flask函数接收一个参数<strong>name</strong>，它会指向程序所在的模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器的作用是将路由映射到视图函数index</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Flask应用程序实例的run方法启动WEB服务器</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<h2 id="路由定义的基本方式"><a href="#路由定义的基本方式" class="headerlink" title="路由定义的基本方式"></a>路由定义的基本方式</h2><h3 id="请求方式限定"><a href="#请求方式限定" class="headerlink" title="请求方式限定"></a>请求方式限定</h3><p>使用 methods 参数指定可接受的请求方式，可以是多种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="给路由传参示例"><a href="#给路由传参示例" class="headerlink" title="给路由传参示例"></a>给路由传参示例</h3><p>有时我们需要将同一类URL映射到同一个视图函数处理，比如：使用同一个视图函数 来显示不同用户的订单信息。</p>
<p>路由传递的参数默认当做string处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/orders/&lt;order_id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_itheima</span>(<span class="params">order_id</span>):</span><br><span class="line">    <span class="comment"># 此处的逻辑: 去查询数据库改用户的订单信息, 并返回</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">type</span>(order_id) <span class="comment"># 类型为unicode</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello itcast %d&#x27;</span> % order_id</span><br></pre></td></tr></table></figure>

<p>这里指定int, 会调用系统的路由转换器进行匹配和转换.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 大致原理是将参数强转为int, 如果成功, 则可以进行路由匹配</span><br><span class="line">- 如果参数无法转换成功, 就无法匹配该路由</span><br><span class="line">@app.route(&#x27;/orders/&lt;int:order_id&gt;&#x27;)</span><br><span class="line">def hello_itheima(order_id):</span><br><span class="line">    print type(order_id) # 类型为int</span><br><span class="line">    return &#x27;hello itcast %d&#x27; % order_id</span><br></pre></td></tr></table></figure>

<p><img src="/../images/dynamic_route.png" alt="给路由传参"></p>
<h1 id="Jinja2模板引擎"><a href="#Jinja2模板引擎" class="headerlink" title="Jinja2模板引擎"></a>Jinja2模板引擎</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在前面的示例中，视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。本节学到的模板，它的作用即是承担视图函数的另一个作用，即返回响应内容。</p>
<ul>
<li>模板其实是一个包含响应文本的文件，其中用占位符(变量)表示动态部分，告诉模板引擎其具体的值需要从使用的数据中获取</li>
<li>使用真实值替换变量，再返回最终得到的字符串，这个过程称为“渲染”</li>
<li>Flask是使用 <strong>Jinja2</strong> 这个模板引擎来渲染模板</li>
</ul>
<p>使用模板的好处：</p>
<ul>
<li>视图函数只负责业务逻辑和数据处理(业务逻辑方面)</li>
<li>而模板则取到视图函数的数据结果进行展示(视图展示方面)</li>
<li>代码结构清晰，耦合度低</li>
</ul>
<h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h2><h3 id="两个概念："><a href="#两个概念：" class="headerlink" title="两个概念："></a>两个概念：</h3><ul>
<li>Jinja2：是 Python 下一个被广泛应用的模板引擎，是由Python实现的模板语言，他的设计思想来源于 Django 的模板引擎，并扩展了其语法和一系列强大的功能，其是Flask内置的模板语言。</li>
<li>模板语言：是一种被设计来自动生成文档的简单文本格式，在模板语言中，一般都会把一些变量传给模板，替换模板的特定位置上预先定义好的占位变量名。</li>
</ul>
<h3 id="渲染模版函数"><a href="#渲染模版函数" class="headerlink" title="渲染模版函数"></a>渲染模版函数</h3><ul>
<li>Flask提供的 <strong>render_template</strong> 函数封装了该模板引擎</li>
<li><strong>render_template</strong> 函数的第一个参数是模板的文件名，后面的参数都是键值对，表示模板中变量对应的真实值。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>使用  进行注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# 这是注释 #&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变量代码块"><a href="#变量代码块" class="headerlink" title="变量代码块"></a>变量代码块</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; post.title &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Jinja2 模版中的变量代码块可以是任意Python类型或者对象，只要它能够被Python的str()方法转换为一个字符串就可以,比如,可以通过下面的方式显示一个字典或者列表中的某个元素:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;your_dict[<span class="string">&#x27;key&#x27;</span>]&#125;&#125;</span><br><span class="line">&#123;&#123;your_list[<span class="number">0</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制代码块"><a href="#控制代码块" class="headerlink" title="控制代码块"></a>控制代码块</h4><ul>
<li>用 {<strong>%%</strong>} 定义的<strong>控制代码块</strong>，可以实现一些语言层次的功能，比如循环或者if语句</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">    &#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    hello!</span><br><span class="line"></span><br><span class="line">&#123;% for index in indexs %&#125;</span><br><span class="line">    &#123;&#123; index &#125;&#125; </span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器的本质就是函数。有时候我们不仅仅只是需要输出变量的值，我们还需要修改变量的显示，甚至格式化、运算等等，而在模板中是不能直接调用 Python 中的某些方法，那么这就用到了过滤器。</p>
<p>使用方式：</p>
<ul>
<li>过滤器的使用方式为：变量名 | 过滤器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;variable | filter_name(*args)&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有任何参数传给过滤器,则可以把括号省略掉</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;variable | filter_name&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如：&#96;&#96;，这个过滤器的作用：把变量variable 的值的首字母转换为大写，其他字母转换为小写</li>
</ul>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>在 jinja2 中，过滤器是可以支持链式调用的，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; <span class="string">&quot;hello world&quot;</span> | reverse | upper &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见内建过滤器"><a href="#常见内建过滤器" class="headerlink" title="常见内建过滤器"></a>常见内建过滤器</h3><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul>
<li>safe：禁用转义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;</span> | safe &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>capitalize：把变量值的首字母转成大写，其余字母转小写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;hello&#x27;</span> | capitalize &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>lower：把值转成小写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;HELLO&#x27;</span> | lower &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>upper：把值转成大写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;hello&#x27;</span> | upper &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>title：把值中的每个单词的首字母都转成大写</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;hello&#x27;</span> | title &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>reverse：字符串反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;olleh&#x27;</span> | reverse &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>format：格式化输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;%s is %d&#x27;</span> | <span class="built_in">format</span>(<span class="string">&#x27;name&#x27;</span>,<span class="number">17</span>) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>striptags：渲染之前把值中所有的HTML标签都删掉</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;</span> | striptags &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>truncate: 字符串截断</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="string">&#x27;hello every one&#x27;</span> | truncate(<span class="number">9</span>)&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h4><ul>
<li>first：取第一个元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] | first &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>last：取最后一个元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] | last &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>length：获取列表长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] | length &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>sum：列表求和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] | <span class="built_in">sum</span> &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>sort：列表排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; [6,2,3,1,5,4] | sort &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="语句块过滤"><a href="#语句块过滤" class="headerlink" title="语句块过滤"></a>语句块过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% filter upper %&#125;</span><br><span class="line">    一大堆文字</span><br><span class="line">&#123;% endfilter %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Web表单"><a href="#Web表单" class="headerlink" title="Web表单"></a>Web表单</h2><p>web表单是web应用程序的基本功能。</p>
<p>它是HTML页面中负责数据采集的部件。表单有三个部分组成：表单标签、表单域、表单按钮。表单允许用户输入数据，负责HTML页面数据采集，通过表单将用户输入的数据提交给服务器。</p>
<p>在Flask中，为了处理web表单，我们一般使用Flask-WTF扩展，它封装了WTForms，并且它有验证表单数据的功能</p>
<h3 id="WTForms支持的HTML标准字段"><a href="#WTForms支持的HTML标准字段" class="headerlink" title="WTForms支持的HTML标准字段"></a>WTForms支持的HTML标准字段</h3><table>
<thead>
<tr>
<th align="left">字段对象</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">StringField</td>
<td align="left">文本字段</td>
</tr>
<tr>
<td align="left">TextAreaField</td>
<td align="left">多行文本字段</td>
</tr>
<tr>
<td align="left">PasswordField</td>
<td align="left">密码文本字段</td>
</tr>
<tr>
<td align="left">HiddenField</td>
<td align="left">隐藏文件字段</td>
</tr>
<tr>
<td align="left">DateField</td>
<td align="left">文本字段，值为 datetime.date 文本格式</td>
</tr>
<tr>
<td align="left">DateTimeField</td>
<td align="left">文本字段，值为 datetime.datetime 文本格式</td>
</tr>
<tr>
<td align="left">IntegerField</td>
<td align="left">文本字段，值为整数</td>
</tr>
<tr>
<td align="left">DecimalField</td>
<td align="left">文本字段，值为decimal.Decimal</td>
</tr>
<tr>
<td align="left">FloatField</td>
<td align="left">文本字段，值为浮点数</td>
</tr>
<tr>
<td align="left">BooleanField</td>
<td align="left">复选框，值为True 和 False</td>
</tr>
<tr>
<td align="left">RadioField</td>
<td align="left">一组单选框</td>
</tr>
<tr>
<td align="left">SelectField</td>
<td align="left">下拉列表</td>
</tr>
<tr>
<td align="left">SelectMutipleField</td>
<td align="left">下拉列表，可选择多个值</td>
</tr>
<tr>
<td align="left">FileField</td>
<td align="left">文件上传字段</td>
</tr>
<tr>
<td align="left">SubmitField</td>
<td align="left">表单提交按钮</td>
</tr>
<tr>
<td align="left">FormField</td>
<td align="left">把表单作为字段嵌入另一个表单</td>
</tr>
<tr>
<td align="left">FieldList</td>
<td align="left">一组指定类型的字段</td>
</tr>
</tbody></table>
<h3 id="WTForms常用验证函数"><a href="#WTForms常用验证函数" class="headerlink" title="WTForms常用验证函数"></a>WTForms常用验证函数</h3><table>
<thead>
<tr>
<th align="left">验证函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DataRequired</td>
<td align="left">确保字段中有数据</td>
</tr>
<tr>
<td align="left">EqualTo</td>
<td align="left">比较两个字段的值，常用于比较两次密码输入</td>
</tr>
<tr>
<td align="left">Length</td>
<td align="left">验证输入的字符串长度</td>
</tr>
<tr>
<td align="left">NumberRange</td>
<td align="left">验证输入的值在数字范围内</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">验证URL</td>
</tr>
<tr>
<td align="left">AnyOf</td>
<td align="left">验证输入值在可选列表中</td>
</tr>
<tr>
<td align="left">NoneOf</td>
<td align="left">验证输入值不在可选列表中</td>
</tr>
</tbody></table>
<p>使用Flask-WTF需要配置参数SECRET_KEY。</p>
<p>CSRF_ENABLED是为了CSRF（跨站请求伪造）保护。 SECRET_KEY用来生成加密令牌，当CSRF激活的时候，该设置会根据设置的密匙生成加密令牌。在HTML页面中直接写form表单：</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="使用普通方式实现表单"><a href="#使用普通方式实现表单" class="headerlink" title="使用普通方式实现表单"></a>使用普通方式实现表单</h4><h4 id="在HTML页面中直接写form表单："><a href="#在HTML页面中直接写form表单：" class="headerlink" title="在HTML页面中直接写form表单："></a>在HTML页面中直接写form表单：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>确认密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="视图函数中获取表单数据："><a href="#视图函数中获取表单数据：" class="headerlink" title="视图函数中获取表单数据："></a>视图函数中获取表单数据：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template,request</span><br><span class="line"></span><br><span class="line">app.secret_key = <span class="string">&#x27;heima&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 判断请求方式是post</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 获取参数, 并效验参数完整性, 如果有问题就进行flash</span></span><br><span class="line">        username = request.form.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        password2 = request.form.get(<span class="string">&#x27;password2&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([username, password, password2]):</span><br><span class="line">            flash(<span class="string">&#x27;params error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 效验密码</span></span><br><span class="line">        <span class="keyword">elif</span> password != password2:</span><br><span class="line">            flash(<span class="string">&#x27;password error&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 没有问题就返回&#x27;success&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> username</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;wtf.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用Flask-WTF实现表单"><a href="#使用Flask-WTF实现表单" class="headerlink" title="使用Flask-WTF实现表单"></a>使用Flask-WTF实现表单</h4><h5 id="模板页面："><a href="#模板页面：" class="headerlink" title="模板页面："></a>模板页面：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    &#123;#设置csrf_token#&#125;</span><br><span class="line">    &#123;&#123; form.csrf_token() &#125;&#125;</span><br><span class="line">    &#123;&#123; form.username.label &#125;&#125;&#123;&#123; form.username &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.password.label &#125;&#125;&#123;&#123; form.password &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.password2.label &#125;&#125;&#123;&#123; form.password2 &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; form.input &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="视图函数："><a href="#视图函数：" class="headerlink" title="视图函数："></a>视图函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, flash</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入wtf扩展的表单类</span></span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入自定义表单需要的字段</span></span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> SubmitField,StringField,PasswordField</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入wtf扩展提供的表单验证器</span></span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired,EqualTo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决编码问题</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>]=<span class="string">&#x27;heima&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义表单类，文本字段、密码字段、提交按钮</span></span><br><span class="line"><span class="comment"># 需要自定义一个表单类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterForm</span>(<span class="title class_ inherited__">FlaskForm</span>):</span><br><span class="line">    username = StringField(<span class="string">&#x27;用户名:&#x27;</span>, validators=[DataRequired()]&#125;)</span><br><span class="line">    password = PasswordField(<span class="string">&#x27;密码:&#x27;</span>, validators=[DataRequired()])</span><br><span class="line">    password2 = PasswordField(<span class="string">&#x27;确认密码:&#x27;</span>, validators=[DataRequired(), EqualTo(<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;密码输入不一致&#x27;</span>)])</span><br><span class="line">    <span class="built_in">input</span> = SubmitField(<span class="string">&#x27;提交&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义根路由视图函数，生成表单对象，获取表单数据，进行表单数据验证</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/form&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">form</span>():</span><br><span class="line">    register_form = RegisterForm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment"># 调用validate_on_submit方法, 可以一次性执行完所有的验证函数的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> register_form.validate_on_submit():</span><br><span class="line">            <span class="comment"># 进入这里就表示所有的逻辑都验证成功</span></span><br><span class="line">            username = request.form.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">            password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">            password2 = request.form.get(<span class="string">&#x27;password2&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span> username</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#message = register_form.errors.get(&#x27;password2&#x27;)[0]</span></span><br><span class="line">            <span class="comment">#flash(message)</span></span><br><span class="line">            flash(<span class="string">&#x27;参数有误&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;wtf.html&#x27;</span>, form=register_form)</span><br></pre></td></tr></table></figure>

<h1 id="Flask中使用数据库"><a href="#Flask中使用数据库" class="headerlink" title="Flask中使用数据库"></a>Flask中使用数据库</h1><h3 id="Flask-SQLAlchemy扩展"><a href="#Flask-SQLAlchemy扩展" class="headerlink" title="Flask-SQLAlchemy扩展"></a>Flask-SQLAlchemy扩展</h3><ul>
<li>SQLALchemy 实际上是对数据库的抽象，让开发者不用直接和 SQL 语句打交道，而是通过 Python 对象来操作数据库，在舍弃一些性能开销的同时，换来的是开发效率的较大提升</li>
<li>SQLAlchemy是一个关系型数据库框架，它提供了高层的ORM和底层的原生数据库的操作。flask-sqlalchemy是一个简化了SQLAlchemy操作的flask扩展。</li>
</ul>
<h3 id="安装-flask-sqlalchemy"><a href="#安装-flask-sqlalchemy" class="headerlink" title="安装 flask-sqlalchemy"></a>安装 flask-sqlalchemy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure>

<p>如果连接的是mysql数据库,需要安装mysqldb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-mysqldb</span><br></pre></td></tr></table></figure>

<h3 id="使用Flask-SQLAlchemy管理数据库"><a href="#使用Flask-SQLAlchemy管理数据库" class="headerlink" title="使用Flask-SQLAlchemy管理数据库"></a>使用Flask-SQLAlchemy管理数据库</h3><p>在Flask-SQLAlchemy中，数据库使用URL指定，而且程序使用的数据库必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。</p>
<h4 id="Flask的数据库设置："><a href="#Flask的数据库设置：" class="headerlink" title="Flask的数据库设置："></a>Flask的数据库设置：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:mysql@127.0.0.1:3306/test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其他设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态追踪修改设置，如未设置只会提示警告, 不建议开启</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 查询时会显示原始SQL语句</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SQLALCHEMY_DATABASE_URI</td>
<td align="left">用于连接的数据库 URI 。例如:sqlite:&#x2F;&#x2F;&#x2F;&#x2F;tmp&#x2F;test.dbmysql:&#x2F;&#x2F;username:password@server&#x2F;db</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_BINDS</td>
<td align="left">一个映射 binds 到连接 URI 的字典。更多 binds 的信息见<a target="_blank" rel="noopener" href="http://docs.jinkan.org/docs/flask-sqlalchemy/binds.html#binds"><em>用 Binds 操作多个数据库</em></a>。</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_ECHO</td>
<td align="left">如果设置为Ture， SQLAlchemy 会记录所有 发给 stderr 的语句，这对调试有用。(打印sql语句)</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_RECORD_QUERIES</td>
<td align="left">可以用于显式地禁用或启用查询记录。查询记录 在调试或测试模式自动启用。更多信息见get_debug_queries()。</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_NATIVE_UNICODE</td>
<td align="left">可以用于显式禁用原生 unicode 支持。当使用 不合适的指定无编码的数据库默认值时，这对于 一些数据库适配器是必须的（比如 Ubuntu 上 某些版本的 PostgreSQL ）。</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_POOL_SIZE</td>
<td align="left">数据库连接池的大小。默认是引擎默认值（通常 是 5 ）</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_POOL_TIMEOUT</td>
<td align="left">设定连接池的连接超时时间。默认是 10 。</td>
</tr>
<tr>
<td align="left">SQLALCHEMY_POOL_RECYCLE</td>
<td align="left">多少秒后自动回收连接。这对 MySQL 是必要的， 它默认移除闲置多于 8 小时的连接。注意如果 使用了 MySQL ， Flask-SQLALchemy 自动设定 这个值为 2 小时。</td>
</tr>
</tbody></table>
<h3 id="常用的SQLAlchemy字段类型"><a href="#常用的SQLAlchemy字段类型" class="headerlink" title="常用的SQLAlchemy字段类型"></a>常用的SQLAlchemy字段类型</h3><table>
<thead>
<tr>
<th align="left">类型名</th>
<th align="left">python中类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Integer</td>
<td align="left">int</td>
<td align="left">普通整数，一般是32位</td>
</tr>
<tr>
<td align="left">SmallInteger</td>
<td align="left">int</td>
<td align="left">取值范围小的整数，一般是16位</td>
</tr>
<tr>
<td align="left">BigInteger</td>
<td align="left">int或long</td>
<td align="left">不限制精度的整数</td>
</tr>
<tr>
<td align="left">Float</td>
<td align="left">float</td>
<td align="left">浮点数</td>
</tr>
<tr>
<td align="left">Numeric</td>
<td align="left">decimal.Decimal</td>
<td align="left">普通整数，一般是32位</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">str</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">Text</td>
<td align="left">str</td>
<td align="left">变长字符串，对较长或不限长度的字符串做了优化</td>
</tr>
<tr>
<td align="left">Unicode</td>
<td align="left">unicode</td>
<td align="left">变长Unicode字符串</td>
</tr>
<tr>
<td align="left">UnicodeText</td>
<td align="left">unicode</td>
<td align="left">变长Unicode字符串，对较长或不限长度的字符串做了优化</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">bool</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">datetime.date</td>
<td align="left">时间</td>
</tr>
<tr>
<td align="left">Time</td>
<td align="left">datetime.datetime</td>
<td align="left">日期和时间</td>
</tr>
<tr>
<td align="left">LargeBinary</td>
<td align="left">str</td>
<td align="left">二进制文件</td>
</tr>
</tbody></table>
<h3 id="常用的SQLAlchemy列选项"><a href="#常用的SQLAlchemy列选项" class="headerlink" title="常用的SQLAlchemy列选项"></a>常用的SQLAlchemy列选项</h3><table>
<thead>
<tr>
<th align="left">选项名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">primary_key</td>
<td align="left">如果为True，代表表的主键</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">如果为True，代表这列不允许出现重复的值</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">如果为True，为这列创建索引，提高查询效率</td>
</tr>
<tr>
<td align="left">nullable</td>
<td align="left">如果为True，允许有空值，如果为False，不允许有空值</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">为这列定义默认值</td>
</tr>
</tbody></table>
<h3 id="常用的SQLAlchemy关系选项"><a href="#常用的SQLAlchemy关系选项" class="headerlink" title="常用的SQLAlchemy关系选项"></a>常用的SQLAlchemy关系选项</h3><table>
<thead>
<tr>
<th align="left">选项名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">backref</td>
<td align="left">在关系的另一模型中添加反向引用</td>
</tr>
<tr>
<td align="left">primary join</td>
<td align="left">明确指定两个模型之间使用的联结条件</td>
</tr>
<tr>
<td align="left">uselist</td>
<td align="left">如果为False，不使用列表，而使用标量值</td>
</tr>
<tr>
<td align="left">order_by</td>
<td align="left">指定关系中记录的排序方式</td>
</tr>
<tr>
<td align="left">secondary</td>
<td align="left">指定多对多中记录的排序方式</td>
</tr>
<tr>
<td align="left">secondary join</td>
<td align="left">在SQLAlchemy中无法自行决定时，指定多对多关系中的二级联结条件</td>
</tr>
</tbody></table>
<h1 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h1><h2 id="一-增删改操作"><a href="#一-增删改操作" class="headerlink" title="一. 增删改操作"></a>一. 增删改操作</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>在Flask-SQLAlchemy中，插入、修改、删除操作，均由数据库会话管理。<ul>
<li>会话用db.session表示。在准备把数据写入数据库前，要先将数据添加到会话中然后调用 commit() 方法提交会话。</li>
</ul>
</li>
<li>在Flask-SQLAlchemy中，查询操作是通过query对象操作数据。<ul>
<li>最基本的查询是返回表中所有数据，可以通过过滤器进行更精确的数据库查询。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.session.add(role)    添加到数据库的session中</span><br><span class="line">db.session.add_all([user1, user2]) 添加多个信息到session中</span><br><span class="line">db.session.commit()     提交数据库的修改(包括增/删/改)</span><br><span class="line">db.session.rollback()   数据库的回滚操作</span><br><span class="line">db.session.delete(user) 删除数据库(需跟上commit)</span><br></pre></td></tr></table></figure>

<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="2-1-在视图函数中定义模型类"><a href="#2-1-在视图函数中定义模型类" class="headerlink" title="2.1 在视图函数中定义模型类"></a>2.1 在视图函数中定义模型类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置连接数据库的URL</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:mysql@127.0.0.1:3306/Flask_test&#x27;</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment">#查询时会显示原始SQL语句</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>(db.Model):</span><br><span class="line">    <span class="comment"># 定义表名</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;roles&#x27;</span></span><br><span class="line">    <span class="comment"># 定义列对象</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">32</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    user = db.relationship(<span class="string">&#x27;User&#x27;</span>, backref=<span class="string">&#x27;role&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#repr()方法显示一个可读字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;Role: %s %s&gt;&#x27;</span> % (self.name, self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">32</span>), unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">32</span>),unique=<span class="literal">True</span>)</span><br><span class="line">    password = db.Column(db.String(<span class="number">32</span>))</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;roles.id&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;User: %s %s %s %s&gt;&#x27;</span> % (self.name, self.<span class="built_in">id</span>, self.email, self.password)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建表：</span></span><br><span class="line">    db.create_all()</span><br><span class="line">    <span class="comment"># 删除表</span></span><br><span class="line">    db.drop_all()</span><br><span class="line"></span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#### 2.2 数据的增删改</span></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 进入ipython一次执行</span></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> demo3_sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条Role数据</span></span><br><span class="line">In [<span class="number">2</span>]: role = Role(name=<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">In [<span class="number">3</span>]: db.session.add(role)</span><br><span class="line">In [<span class="number">4</span>]: db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条User数据, 数据有误可以使用回滚, 将add的对象从session移除</span></span><br><span class="line">In [<span class="number">5</span>]: user = User(name=<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">In [<span class="number">6</span>]: db.session.add(user)</span><br><span class="line">In [<span class="number">7</span>]: db.session.rollback()</span><br><span class="line">In [<span class="number">9</span>]: user.role_id = <span class="number">1</span></span><br><span class="line">In [<span class="number">6</span>]: db.session.add(user)</span><br><span class="line">In [<span class="number">4</span>]: db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数据</span></span><br><span class="line">In [<span class="number">13</span>]: user.name = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">In [<span class="number">14</span>]: db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">In [<span class="number">16</span>]: db.session.delete(user)</span><br><span class="line">In [<span class="number">17</span>]: db.session.commit()</span><br></pre></td></tr></table></figure>

<h3 id="3-模型之间的关联"><a href="#3-模型之间的关联" class="headerlink" title="3 模型之间的关联"></a>3 模型之间的关联</h3><h4 id="3-1-一对多"><a href="#3-1-一对多" class="headerlink" title="3.1 一对多"></a>3.1 一对多</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span>(db.Model):</span><br><span class="line">...</span><br><span class="line"><span class="comment">#关键代码</span></span><br><span class="line">user = db.relationship(<span class="string">&#x27;User&#x27;</span>, backref=<span class="string">&#x27;role&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">...</span><br><span class="line">role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;roles.id&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>其中realtionship描述了Role和User的关系。在此文中，第一个参数为对应参照的类”User”</li>
<li>第二个参数backref为类User申明新属性的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from demo3_sqlalchemy import *</span><br><span class="line"></span><br><span class="line">In [2]: role = Role(name=&#x27;admin&#x27;)</span><br><span class="line"></span><br><span class="line">In [3]: db.session.add(role)</span><br><span class="line"></span><br><span class="line">In [4]: db.session.commit()</span><br><span class="line"></span><br><span class="line">In [5]: user1 = User(name=&#x27;zs&#x27;, role_id=role.id)</span><br><span class="line"></span><br><span class="line">In [6]: user2 = User(name=&#x27;ls&#x27;, role_id=role.id)</span><br><span class="line"></span><br><span class="line">In [7]: db.session.add_all([user1, user2])</span><br><span class="line"></span><br><span class="line">In [8]: db.session.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时就可以通过角色直接查询到用户信息</span><br><span class="line">In [9]: role.users</span><br><span class="line">Out[9]: [, ]</span><br><span class="line"></span><br><span class="line"># 此时就可以通过用户直接查询到角色信息</span><br><span class="line">In [10]: user1.role</span><br><span class="line">Out[10]: </span><br><span class="line"></span><br><span class="line">In [11]: user2.role</span><br><span class="line">Out[11]: </span><br><span class="line"></span><br><span class="line"># 此时就可以通过角色直接查询到用户信息</span><br></pre></td></tr></table></figure>

<h2 id="二-查询操作"><a href="#二-查询操作" class="headerlink" title="二. 查询操作"></a>二. 查询操作</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h3 id="1-1-常用的SQLAlchemy查询过滤器"><a href="#1-1-常用的SQLAlchemy查询过滤器" class="headerlink" title="1.1 常用的SQLAlchemy查询过滤器"></a>1.1 常用的SQLAlchemy查询过滤器</h3><table>
<thead>
<tr>
<th align="left">过滤器</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">filter()</td>
<td align="left">把过滤器添加到原查询上，返回一个新查询</td>
</tr>
<tr>
<td align="left">filter_by()</td>
<td align="left">把等值过滤器添加到原查询上，返回一个新查询</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">使用指定的值限定原查询返回的结果</td>
</tr>
<tr>
<td align="left">offset()</td>
<td align="left">偏移原查询返回的结果，返回一个新查询</td>
</tr>
<tr>
<td align="left">order_by()</td>
<td align="left">根据指定条件对原查询结果进行排序，返回一个新查询</td>
</tr>
<tr>
<td align="left">group_by()</td>
<td align="left">根据指定条件对原查询结果进行分组，返回一个新查询</td>
</tr>
</tbody></table>
<h3 id="1-2-常用的SQLAlchemy查询执行器"><a href="#1-2-常用的SQLAlchemy查询执行器" class="headerlink" title="1.2 常用的SQLAlchemy查询执行器"></a>1.2 常用的SQLAlchemy查询执行器</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">all()</td>
<td align="left">以列表形式返回查询的所有结果</td>
</tr>
<tr>
<td align="left">first()</td>
<td align="left">返回查询的第一个结果，如果未查到，返回None</td>
</tr>
<tr>
<td align="left">first_or_404()</td>
<td align="left">返回查询的第一个结果，如果未查到，返回404</td>
</tr>
<tr>
<td align="left">get()</td>
<td align="left">返回指定主键对应的行，如不存在，返回None</td>
</tr>
<tr>
<td align="left">get_or_404()</td>
<td align="left">返回指定主键对应的行，如不存在，返回404</td>
</tr>
<tr>
<td align="left">count()</td>
<td align="left">返回查询结果的数量</td>
</tr>
<tr>
<td align="left">paginate()</td>
<td align="left">返回一个Paginate对象，它包含指定范围内的结果</td>
</tr>
</tbody></table>
<h3 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. 示例</h3><h4 id="2-1-插入角色数据"><a href="#2-1-插入角色数据" class="headerlink" title="2.1 插入角色数据"></a>2.1 插入角色数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ro1 = Role(name=&#x27;admin&#x27;)</span><br><span class="line">db.session.add(ro1)</span><br><span class="line">db.session.commit()</span><br><span class="line">#再次插入一条数据</span><br><span class="line">ro2 = Role(name=&#x27;user&#x27;)</span><br><span class="line">db.session.add(ro2)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>

<h4 id="2-2-一次插入多条数据"><a href="#2-2-一次插入多条数据" class="headerlink" title="2.2 一次插入多条数据"></a>2.2 一次插入多条数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">us1 = User(name=<span class="string">&#x27;wang&#x27;</span>,email=<span class="string">&#x27;wang@163.com&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,role_id=ro1.<span class="built_in">id</span>)</span><br><span class="line">us2 = User(name=<span class="string">&#x27;zhang&#x27;</span>,email=<span class="string">&#x27;zhang@189.com&#x27;</span>,password=<span class="string">&#x27;201512&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">us3 = User(name=<span class="string">&#x27;chen&#x27;</span>,email=<span class="string">&#x27;chen@126.com&#x27;</span>,password=<span class="string">&#x27;987654&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">us4 = User(name=<span class="string">&#x27;zhou&#x27;</span>,email=<span class="string">&#x27;zhou@163.com&#x27;</span>,password=<span class="string">&#x27;456789&#x27;</span>,role_id=ro1.<span class="built_in">id</span>)</span><br><span class="line">us5 = User(name=<span class="string">&#x27;tang&#x27;</span>,email=<span class="string">&#x27;tang@itheima.com&#x27;</span>,password=<span class="string">&#x27;158104&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">us6 = User(name=<span class="string">&#x27;wu&#x27;</span>,email=<span class="string">&#x27;wu@gmail.com&#x27;</span>,password=<span class="string">&#x27;5623514&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">us7 = User(name=<span class="string">&#x27;qian&#x27;</span>,email=<span class="string">&#x27;qian@gmail.com&#x27;</span>,password=<span class="string">&#x27;1543567&#x27;</span>,role_id=ro1.<span class="built_in">id</span>)</span><br><span class="line">us8 = User(name=<span class="string">&#x27;liu&#x27;</span>,email=<span class="string">&#x27;liu@itheima.com&#x27;</span>,password=<span class="string">&#x27;867322&#x27;</span>,role_id=ro1.<span class="built_in">id</span>)</span><br><span class="line">us9 = User(name=<span class="string">&#x27;li&#x27;</span>,email=<span class="string">&#x27;li@163.com&#x27;</span>,password=<span class="string">&#x27;4526342&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">us10 = User(name=<span class="string">&#x27;sun&#x27;</span>,email=<span class="string">&#x27;sun@163.com&#x27;</span>,password=<span class="string">&#x27;235523&#x27;</span>,role_id=ro2.<span class="built_in">id</span>)</span><br><span class="line">db.session.add_all([us1,us2,us3,us4,us5,us6,us7,us8,us9,us10])</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure>

<h4 id="2-3-查询演练"><a href="#2-3-查询演练" class="headerlink" title="2.3 查询演练"></a>2.3 查询演练</h4><p>完成以下查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 查询所有用户数据</span><br><span class="line"><span class="number">2.</span> 查询有多少个用户</span><br><span class="line"><span class="number">3.</span> 查询第<span class="number">1</span>个用户</span><br><span class="line"><span class="number">4.</span> 查询<span class="built_in">id</span>为<span class="number">4</span>的用户[<span class="number">3</span>种方式]</span><br><span class="line"><span class="number">1.</span> 查询所有用户数据</span><br><span class="line"><span class="comment"># all()返回查询到的所有对象</span></span><br><span class="line">User.query.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 查询有多少个用户</span><br><span class="line">User.query.count()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 查询第<span class="number">1</span>个用户</span><br><span class="line">User.query.first()</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 查询<span class="built_in">id</span>为<span class="number">4</span>的用户[<span class="number">3</span>种方式]</span><br><span class="line"><span class="comment"># filter_by直接用属性名，比较用=, filter用类名.属性名，比较用==</span></span><br><span class="line"><span class="comment"># filter_by用于查询简单的列名，不支持比较运算符</span></span><br><span class="line"><span class="comment"># filter比filter_by的功能更强大，支持比较运算符，支持or_、in_等语法。</span></span><br><span class="line">User.query.get(<span class="number">4</span>)</span><br><span class="line">User.query.filter_by(<span class="built_in">id</span>=<span class="number">4</span>).first()  <span class="comment">#属性 =</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.<span class="built_in">id</span>==<span class="number">4</span>).first() <span class="comment">#对象名.属性 ==</span></span><br><span class="line">User.query.filter_by(<span class="built_in">id</span>=<span class="number">4</span>).first()  <span class="comment">#属性 =</span></span><br></pre></td></tr></table></figure>

<h1 id="综合案例-图书管理"><a href="#综合案例-图书管理" class="headerlink" title="综合案例-图书管理"></a>综合案例-图书管理</h1><ul>
<li>WTF表单</li>
<li>数据库操作</li>
</ul>
<h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>模型表示程序使用的数据实体，在Flask-SQLAlchemy中，模型一般是Python类，继承自db.Model，db是SQLAlchemy类的实例，代表程序使用的数据库。</p>
<p>类中的属性对应数据库表中的列。id为主键，是由Flask-SQLAlchemy管理。db.Column类构造函数的第一个参数是数据库列和模型属性类型。</p>
<blockquote>
<p>注：如果没有在创建数据库的时候指定编码的话，向数据库中插入中文后，会报错，那么需要修改数据库的编码集:</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> database 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8</span><br></pre></td></tr></table></figure>

<p>如下示例：定义了两个模型类，作者和书名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;mysql://root:mysql@127.0.0.1:3306/test2&#x27;</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;authors&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    books = db.relationship(<span class="string">&#x27;Book&#x27;</span>, backref=<span class="string">&#x27;author&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Author:%s&#x27;</span> %self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;books&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>))</span><br><span class="line">    author_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;authors.id&#x27;</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Book:%s,%s&#x27;</span>%(self.name,self.author_id)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    db.drop_all()</span><br><span class="line">    db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成数据</span></span><br><span class="line">    au1 = Author(name=<span class="string">&#x27;老王&#x27;</span>)</span><br><span class="line">    au2 = Author(name=<span class="string">&#x27;老惠&#x27;</span>)</span><br><span class="line">    au3 = Author(name=<span class="string">&#x27;老刘&#x27;</span>)</span><br><span class="line">    <span class="comment"># 把数据提交给用户会话</span></span><br><span class="line">    db.session.add_all([au1, au2, au3])</span><br><span class="line">    <span class="comment"># 提交会话</span></span><br><span class="line">    db.session.commit()</span><br><span class="line">    bk1 = Book(name=<span class="string">&#x27;老王回忆录&#x27;</span>, author_id=au1.<span class="built_in">id</span>)</span><br><span class="line">    bk2 = Book(name=<span class="string">&#x27;我读书少，你别骗我&#x27;</span>, author_id=au1.<span class="built_in">id</span>)</span><br><span class="line">    bk3 = Book(name=<span class="string">&#x27;如何才能让自己更骚&#x27;</span>, author_id=au2.<span class="built_in">id</span>)</span><br><span class="line">    bk4 = Book(name=<span class="string">&#x27;怎样征服美丽少女&#x27;</span>, author_id=au3.<span class="built_in">id</span>)</span><br><span class="line">    bk5 = Book(name=<span class="string">&#x27;如何征服英俊少男&#x27;</span>, author_id=au3.<span class="built_in">id</span>)</span><br><span class="line">    <span class="comment"># 把数据提交给用户会话</span></span><br><span class="line">    db.session.add_all([bk1, bk2, bk3, bk4, bk5])</span><br><span class="line">    <span class="comment"># 提交会话</span></span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数据显示-amp-表单添加"><a href="#数据显示-amp-表单添加" class="headerlink" title="数据显示&amp;表单添加"></a>数据显示&amp;表单添加</h2><h3 id="使用WTF实现表单"><a href="#使用WTF实现表单" class="headerlink" title="使用WTF实现表单"></a>使用WTF实现表单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from flask_wtf import FlaskForm</span><br><span class="line">from wtforms import StringField, SubmitField</span><br><span class="line">from wtforms.validators import DataRequired</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">app.secret_key = &#x27;abc&#x27;</span><br><span class="line"></span><br><span class="line">class Author(db.Model):</span><br><span class="line">    __tablename__ = &#x27;authors&#x27;</span><br><span class="line">    id = db.Column(db.Integer, primary_key=True)</span><br><span class="line">    name = db.Column(db.String(64), unique=True)</span><br><span class="line">    books = db.relationship(&#x27;Book&#x27;, backref=&#x27;author&#x27;)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def hello_world():</span><br><span class="line">    author_form = AuthorForm()</span><br><span class="line">    return render_template(&#x27;temp2_books.html&#x27;, form=author_form)</span><br></pre></td></tr></table></figure>

<h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;post&quot;&gt;</span><br><span class="line">    &#123;&#123; form.csrt_token() &#125;&#125;</span><br><span class="line">    &#123;&#123; form.author.label &#125;&#125;&#123;&#123; form.author &#125;&#125;&lt;br&gt;</span><br><span class="line">    &#123;&#123; form.book.label &#125;&#125;&#123;&#123; form.book &#125;&#125;&lt;br&gt;</span><br><span class="line">    &#123;&#123; form.submit&#125;&#125;&lt;br&gt;</span><br><span class="line">    &#123;% for message in get_flashed_messages() %&#125;</span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for author in authors %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; author.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;% for book in author.books %&#125;</span><br><span class="line">                &lt;li&gt;&#123;&#123; book.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authors = Author.query.all()</span><br></pre></td></tr></table></figure>

<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  1. 调用wtf的函数实现验证</span></span><br><span class="line"><span class="keyword">if</span> book_form.validate_on_submit():</span><br><span class="line">    <span class="comment"># 2. 验证通过获取数据</span></span><br><span class="line">    author_name = book_form.author.data</span><br><span class="line">    book_name = book_form.book.data</span><br><span class="line">    <span class="comment"># 3. 判断作者是否存在</span></span><br><span class="line">    author = Author.query.filter_by(name=author_name).first()</span><br><span class="line">    <span class="keyword">if</span> author:</span><br><span class="line">        <span class="comment"># 4. 判断书籍是否存在, 没有重复书籍就添加数据. 如果重复就提示错误</span></span><br><span class="line">        book = Book.query.filter_by(name=book_name).first()</span><br><span class="line">        <span class="keyword">if</span> book:</span><br><span class="line">            <span class="comment"># 如果重复就提示错误</span></span><br><span class="line">            flash(<span class="string">&#x27;已存在同名书籍&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 没有重复书籍就添加数据</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                new_book = Book(name=book_name, author_id=author.<span class="built_in">id</span>)</span><br><span class="line">                db.session.add(new_book)</span><br><span class="line">                db.session.commit()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span> e</span><br><span class="line">                flash(<span class="string">&#x27;书籍添加失败&#x27;</span>)</span><br><span class="line">                db.session.rollback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 5. 如果作者不存在, 添加作者和书籍</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_author = Author(name=author_name)</span><br><span class="line">            db.session.add(new_author)</span><br><span class="line">            db.session.commit()</span><br><span class="line"></span><br><span class="line">            new_book = Book(name=book_name, author_id=new_author.<span class="built_in">id</span>)</span><br><span class="line">            db.session.add(new_book)</span><br><span class="line">            db.session.commit()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line">            flash(<span class="string">&#x27;添加失败&#x27;</span>)</span><br><span class="line">            db.session.rollback()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 6. 验证不通过提示错误</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        flash(<span class="string">&#x27;参数不完整&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><ul>
<li>定义删除author和book的路由</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/delete_book/&lt;int:book_id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_book</span>(<span class="params">book_id</span>):</span><br><span class="line">    book = Book.query.get(book_id)</span><br><span class="line">    <span class="keyword">if</span> book:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            db.session.delete(book)</span><br><span class="line">            db.session.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line">            flash(<span class="string">&#x27;删除书失败&#x27;</span>)</span><br><span class="line">            db.session.rollback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flash(<span class="string">&#x27;书不存在&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;li&gt;&#123;&#123; book.name &#125;&#125;&lt;a href=<span class="string">&quot;&#123;&#123; url_for(&#x27;delete_book&#x27;, book_id=book.id) &#125;&#125;&quot;</span>&gt;删除&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&lt;li&gt;无&lt;/li&gt;</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/delete_author/&lt;int:author_id&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_author</span>(<span class="params">author_id</span>):</span><br><span class="line">    author = Author.query.get(author_id)</span><br><span class="line">    <span class="keyword">if</span> author:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 先删除书</span></span><br><span class="line">            Book.query.filter_by(author_id=author.<span class="built_in">id</span>).delete()</span><br><span class="line">            <span class="comment"># 再删除作者</span></span><br><span class="line">            db.session.delete(author)</span><br><span class="line">            db.session.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line">            flash(<span class="string">&#x27;删除失败&#x27;</span>)</span><br><span class="line">            db.session.rollback()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flash(<span class="string">&#x27;未找到该作者&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;index&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&lt;li&gt;&#123;&#123; author.name &#125;&#125;&lt;a href=<span class="string">&quot;&#123;&#123; url_for(&#x27;delete_author&#x27;, author_id=author.id) &#125;&#125;&quot;</span>&gt;删除&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/04/10/BIO-NIO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/10/BIO-NIO-%E9%9B%B6%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">BIO/NIO&零拷贝</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-10 23:18:16 / 修改时间：23:20:47" itemprop="dateCreated datePublished" datetime="2022-04-10T23:18:16+08:00">2022-04-10</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络通信编程基本常识"><a href="#网络通信编程基本常识" class="headerlink" title="网络通信编程基本常识"></a><strong>网络通信编程基本常识</strong></h1><h2 id="什么是Socket？"><a href="#什么是Socket？" class="headerlink" title="什么是Socket？"></a><strong>什么是Socket？</strong></h2><p><strong>Socket</strong>是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口，一般由操作系统提供。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议处理和通信缓存管理等等都隐藏在Socket接口后面，对用户来说，使用一组简单的接口就能进行网络应用编程，让Socket去组织数据，以符合指定的协议。主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接。</p>
<p>客户端连接上一个服务端，就会在客户端中产生一个socket接口实例，服务端每接受一个客户端连接，就会产生一个socket接口实例和客户端的socket进行通信，有多个客户端连接自然就有多个socket接口实例。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image1.png" alt="0"></p>
<h3 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a><strong>短连接</strong></h3><p>连接-&gt;传输数据-&gt;关闭连接   传统HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。   也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a><strong>长连接</strong></h3><p>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。 -&gt;关闭连接。   长连接指建立SOCKET连接后不管是否使用都保持连接。</p>
<h3 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a><strong>什么时候用长连接，短连接？</strong></h3><p>  长连接多用于操作频繁，点对点的通讯。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p>
<p> 而像WEB网站的http服务按照Http协议规范早期一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。但是现在的Http协议，Http1.1，尤其是Http2、Http3已经开始向长连接演化。</p>
<p> 总之，长连接和短连接的选择要视情况而定。</p>
<h1 id="网络编程里通用常识"><a href="#网络编程里通用常识" class="headerlink" title="网络编程里通用常识"></a><strong>网络编程里通用常识</strong></h1><p>我们首先来看一个生活中的场景。周瑜老师准备开一个心理咨询中心，嘴上光喊没用，只有到工商局注册“东吴心理诊所”并且在图灵大街888号挂牌了，才算正式开张。疫情来了，准备开展电话业务，申请了一个电话号码88888888。诸葛老师有了心理问题，于是打电话过来，周瑜老师接了电话，但是周瑜老师不懂心理咨询，于是通过内部分机把电话转给请来的心理医生A负责接待诸葛老师，心理医生A和诸葛老师通过电话进行沟通，模式一般就是一个人说另个一人听，两者进行沟通交流。Fox老师也来了，周瑜老师接了电话，又把电话转给请来的心理医生B负责接待Fox老师，心理医生B和Fox老师也通过电话进行沟通。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image2.png" alt="0"></p>
<p>上述的场景和网络编程有很大的相似之处。</p>
<p>我们已经知道在通信编程里提供服务的叫服务端，连接服务端使用服务的叫客户端。在开发过程中，如果类的名字有Server或者ServerSocket的，表示这个类是给服务端容纳网络服务用的，如果类的名字只包含Socket的，那么表示这是负责具体的网络读写的。</p>
<p>那么对于服务端来说ServerSocket就只是个场所，就像上面的“东吴心理诊所”，它必须要绑定某个IP地址，就像“东吴心理诊所”在“图灵大街888号挂牌”，同时ServerSocket还需要监听某个端口，就像“申请了一个电话号码88888888”。</p>
<p>有电话进来了，具体和客户端沟通的还是一个一个的socket，就像“周瑜老师不懂心理咨询，于是通过内部分机把电话转给请来的心理医生A负责接待诸葛老师”，所以在通信编程里，ServerSocket并不负责具体的网络读写，ServerSocket就只是负责接收客户端连接后，新启一个socket来和客户端进行沟通。这一点对所有模式的通信编程都是适用的。</p>
<p>在通信编程里，我们关注的其实也就是三个事情：连接（客户端连接服务器，服务器等待和接收连接）、读网络数据、写网络数据，所有模式的通信编程都是围绕着这三件事情进行的。服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。</p>
<p>我们后面将学习的BIO和NIO其实都是处理上面三件事，只是处理的方式不一样。</p>
<h1 id="Java原生网络编程-BIO"><a href="#Java原生网络编程-BIO" class="headerlink" title="Java原生网络编程-BIO"></a><strong>Java原生网络编程-BIO</strong></h1><h2 id="原生JDK网络编程BIO"><a href="#原生JDK网络编程BIO" class="headerlink" title="原生JDK网络编程BIO"></a><strong>原生JDK网络编程BIO</strong></h2><p>BIO，意为Blocking I&#x2F;O，即阻塞的I&#x2F;O。</p>
<p>BIO基本上就是我们上面所说的生活场景的朴素实现。在BIO中类ServerSocket负责绑定IP地址，启动监听端口，等待客户连接；客户端Socket类的实例发起连接操作，ServerSocket接受连接后产生一个新的服务端socket实例负责和客户端socket实例通过输入和输出流进行通信。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image3.png" alt="0"></p>
<p>bio的阻塞，主要体现在两个地方。</p>
<p>①若一个服务器启动就绪，那么主线程就一直在等待着客户端的连接，这个等待过程中主线程就一直在阻塞。</p>
<p>②在连接建立之后，在读取到socket信息之前，线程也是一直在等待，一直处于阻塞的状态下的。 </p>
<p>这一点可以通过cn.tuling.bio下的ServerSingle.java服务端程序看出，启动该程序后，启动一个Client程序实例，并让这个Client阻塞住，位置就在向服务器输出具体请求之前，再启动一个新的Client程序实例，会发现尽管新的Client实例连接上了服务器，但是ServerSingle服务端程序仿佛无感知一样？为何，因为执行的主线程被阻塞了一直在等待第一个Client实例发送消息过来。</p>
<p>所以在BIO通信里，我们往往会在服务器的实现上结合线程来处理连接以及和客户端的通信。</p>
<p>传统BIO通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答模型，同时数据的读取写入也必须阻塞在一个线程内等待其完成。代码可见cn.tuling.bio.Server。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image4.png" alt="0"></p>
<p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p>
<p>为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I&#x2F;O），通常被称为“伪异步I&#x2F;O模型“。</p>
<p>我们知道，如果使用CachedThreadPool线程池（不限制线程数量，如果不清楚请参考文首提供的文章），其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I&#x2F;O模型。代码可见cn.tuling.bio.ServerPool。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image5.png" alt="0"></p>
<p>  但是，正因为限制了线程数量，如果发生读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。</p>
<h2 id="为什么要有RPC？"><a href="#为什么要有RPC？" class="headerlink" title="为什么要有RPC？"></a><strong>为什么要有RPC？</strong></h2><p>我们最开始开发的时候，一个应用一台机器，将所有功能都写在一起，比如说比较常见的电商场景，服务之间的调用就是我们最熟悉的普通本地方法调用。</p>
<p>随着我们业务的发展，我们需要提示性能了，我们会怎么做？将不同的业务功能放到线程里来实现异步和提升性能，但本质上还是本地方法调用。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image6.png" alt="0"></p>
<p>但是业务越来越复杂，业务量越来越大，单个应用或者一台机器的资源是肯定背负不起的，这个时候，我们会怎么做？将核心业务抽取出来，作为独立的服务，放到其他服务器上或者形成集群。这个时候就会请出RPC，系统变为分布式的架构。</p>
<p>为什么说千万级流量分布式、微服务架构必备的RPC框架？和LocalCall的代码进行比较，因为引入rpc框架对我们现有的代码影响最小，同时又可以帮我们实现架构上的扩展。现在的开源rpc框架，有什么？dubbo，grpc等等 </p>
<p>当服务越来越多，各种rpc之间的调用会越来越复杂，这个时候我们会引入中间件，比如说MQ、缓存，同时架构上整体往微服务去迁移，引入了各种比如容器技术docker，DevOps等等。最终会变为如图所示来应付千万级流量，但是不管怎样，rpc总是会占有一席之地。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image7.png" alt="0"></p>
<h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a><strong>什么是RPC？</strong></h2><p>RPC（Remote Procedure Call ——远程过程调用），它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络的技术。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image8.jpeg" alt="0"></p>
<p>一次完整的RPC同步调用流程： </p>
<p>1）服务消费方（client）以本地调用方式调用客户端存根； </p>
<p>2）什么叫客户端存根？就是远程方法在本地的模拟对象，一样的也有方法名，也有方法参数，client stub接收到调用后负责将方法名、方法的参数等包装，并将包装后的信息通过网络发送到服务端； </p>
<p>3）服务端收到消息后，交给代理存根在服务器的部分后进行解码为实际的方法名和参数 </p>
<p>4） server stub根据解码结果调用服务器上本地的实际服务；</p>
<p>5）本地服务执行并将结果返回给server stub； </p>
<p>6）server stub将返回结果打包成消息并发送至消费方；</p>
<p>7）client stub接收到消息，并进行解码； </p>
<p>8）服务消费方得到最终结果。</p>
<p>RPC框架的目标就是要中间步骤都封装起来，让我们进行远程方法调用的时候感觉到就像在本地方法调用一样。</p>
<h2 id="RPC和HTTP"><a href="#RPC和HTTP" class="headerlink" title="RPC和HTTP"></a><strong>RPC和HTTP</strong></h2><p>rpc字面意思就是远程过程调用，只是对不同应用间相互调用的一种描述，一种思想。具体怎么调用？实现方式可以是最直接的tcp通信，也可以是http方式，在很多的消息中间件的技术书籍里，甚至还有使用消息中间件来实现RPC调用的，我们知道的dubbo是基于tcp通信的，gRPC是Google公布的开源软件，基于最新的HTTP2.0协议，底层使用到了Netty框架的支持。所以总结来说，rpc和http是完全两个不同层级的东西，他们之间并没有什么可比性。</p>
<h2 id="实现RPC框架"><a href="#实现RPC框架" class="headerlink" title="实现RPC框架"></a><strong>实现RPC框架</strong></h2><h3 id="实现RPC框架需要解决的那些问题"><a href="#实现RPC框架需要解决的那些问题" class="headerlink" title="实现RPC框架需要解决的那些问题"></a><strong>实现RPC框架需要解决的那些问题</strong></h3><h4 id="代理问题"><a href="#代理问题" class="headerlink" title="代理问题"></a><strong>代理问题</strong></h4><p>代理本质上是要解决什么问题？要解决的是被调用的服务本质上是远程的服务，但是调用者不知道也不关心，调用者只要结果，具体的事情由代理的那个对象来负责这件事。既然是远程代理，当然是要用代理模式了。</p>
<p>代理(Proxy)是一种设计模式,即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。那我们这里额外的功能操作是干什么，通过网络访问远程服务。</p>
<p>jdk的代理有两种实现方式：静态代理和动态代理。</p>
<h4 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a><strong>序列化问题</strong></h4><p>序列化问题在计算机里具体是什么？我们的方法调用，有方法名，方法参数，这些可能是字符串，可能是我们自己定义的java的类，但是在网络上传输或者保存在硬盘的时候，网络或者硬盘并不认得什么字符串或者javabean，它只认得二进制的01串，怎么办？要进行序列化，网络传输后要进行实际调用，就要把二进制的01串变回我们实际的java的类，这个叫反序列化。java里已经为我们提供了相关的机制Serializable。</p>
<h4 id="通信问题"><a href="#通信问题" class="headerlink" title="通信问题"></a><strong>通信问题</strong></h4><p>我们在用序列化把东西变成了可以在网络上传输的二进制的01串，但具体如何通过网络传输？使用JDK为我们提供的BIO。</p>
<h4 id="登记的服务实例化"><a href="#登记的服务实例化" class="headerlink" title="登记的服务实例化"></a><strong>登记的服务实例化</strong></h4><p>登记的服务有可能在我们的系统中就是一个名字，怎么变成实际执行的对象实例，当然是使用反射机制。</p>
<p>反射机制是什么？</p>
<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>反射机制能做什么</p>
<p>反射机制主要提供了以下功能：</p>
<p>•在运行时判断任意一个对象所属的类；</p>
<p>•在运行时构造任意一个类的对象；</p>
<p>•在运行时判断任意一个类所具有的成员变量和方法；</p>
<p>•在运行时调用任意一个对象的方法；</p>
<p>•生成动态代理。</p>
<h4 id="成型代码"><a href="#成型代码" class="headerlink" title="成型代码"></a><strong>成型代码</strong></h4><p>参见工程ketang-tl-rpc，其中</p>
<p>rpc-client 包含了rpc框架客户端的使用范例</p>
<p>rpc-reg 包含了rpc框架的远程注册中心的实现代码</p>
<p>rpc-server-sms 包含了rpc框架服务端的使用范例 sms服务</p>
<p>rpc-server-stock 包含了rpc框架服务端的使用范例 stock服务</p>
<p>rpc-netty-client 包含了基于Netty通信框架的rpc实现的客户端</p>
<p>rpc-netty-server 包含了基于Netty通信框架的rpc实现的服务端，采用了本地注册中心模式</p>
<h2 id="原生JDK网络编程-NIO"><a href="#原生JDK网络编程-NIO" class="headerlink" title="原生JDK网络编程- NIO"></a><strong>原生JDK网络编程- NIO</strong></h2><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a><strong>什么是NIO？</strong></h3><p>NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 BIO 的不足，它在标准 Java 代码中提供了高速的、面向块的 I&#x2F;O。NIO被称为 no-blocking io 或者 new io都说得通。</p>
<h3 id="和BIO的主要区别"><a href="#和BIO的主要区别" class="headerlink" title="和BIO的主要区别"></a><strong>和BIO的主要区别</strong></h3><h4 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a><strong>面向流与面向缓冲</strong></h4><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h4 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a><strong>阻塞与非阻塞IO</strong></h4><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p> Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="NIO之Reactor模式"><a href="#NIO之Reactor模式" class="headerlink" title="NIO之Reactor模式"></a><strong>NIO之Reactor模式</strong></h3><p>“反应”器名字中”反应“的由来：</p>
<p>“反应”即“倒置”，“控制逆转”,具体事件处理程序不调用反应器，而向反应器注册一个事件处理器，表示自己对某些事件感兴趣，有时间来了，具体事件处理程序通过事件处理器对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）</p>
<p>例如，路人甲去做男士SPA，大堂经理负责服务，路人甲现在只对10000技师感兴趣，但是路人甲去的比较早，就告诉大堂经理，等10000技师上班了或者是空闲了，通知我。等路人甲接到大堂经理通知，做出了反应，把10000技师占住了。</p>
<p>然后，路人甲想起上一次的那个10000号房间不错，设备舒适，灯光暧昧，又告诉大堂经理，我对10000号房间很感兴趣，房间空出来了就告诉我，我现在先和10000这个小姐聊下人生，10000号房间空出来了，路人甲再次接到大堂经理通知，路人甲再次做出了反应。</p>
<p>路人甲就是具体事件处理程序，大堂经理就是所谓的反应器，“10000技师上班了”和“10000号房间空闲了”就是事件，路人甲只对这两个事件感兴趣，其他，比如10001号技师或者10002号房间空闲了也是事件，但是路人甲不感兴趣。</p>
<p>大堂经理不仅仅服务路人甲这个人，他还可以同时服务路人乙、丙……..，每个人所感兴趣的事件是不一样的，大堂经理会根据每个人感兴趣的事件通知对应的每个人。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image9.png" alt="0"></p>
<h3 id="NIO三大核心组件"><a href="#NIO三大核心组件" class="headerlink" title="NIO三大核心组件"></a><strong>NIO三大核心组件</strong></h3><p>NIO有三大核心组件：Selector选择器、Channel管道、buffer缓冲区。</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a><strong>Selector</strong></h4><p>Selector的英文含义是“选择器”，也可以称为为“轮询代理器”、“事件订阅器”、“channel容器管理机”都行。</p>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选择器，进而“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<p>应用程序将向Selector对象注册需要它关注的Channel，以及具体的某一个Channel会对哪些IO事件感兴趣。Selector中也会维护一个“已经注册的Channel”的容器。</p>
<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a><strong>Channels</strong></h4><p>通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。</p>
<ul>
<li>所有被Selector（选择器）注册的通道，只能是继承了SelectableChannel类的子类。</li>
<li>ServerSocketChannel：应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用IO”的端口监听。同时支持UDP协议和TCP协议。</li>
<li>ScoketChannel：TCP Socket套接字的监听通道，一个Socket套接字对应了一个客户端IP：端口 到 服务器IP：端口的通信连接。</li>
</ul>
<p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</p>
<h4 id="buffer缓冲区"><a href="#buffer缓冲区" class="headerlink" title="buffer缓冲区"></a><strong>buffer缓冲区</strong></h4><p>我们前面说过JDK NIO是面向缓冲的。Buffer就是这个缓冲，用于和NIO通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的。以写为例，应用程序都是将数据写入缓冲，再通过通道把缓冲的数据发送出去，读也是一样，数据总是先从通道读到缓冲，应用程序再读缓冲的数据。</p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存（其实就是数组）。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p>后面的附录详细讲到其中的api等相关内容。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image10.png" alt="0"></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h4><p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image11.png" alt="0"></p>
<p>1、</p>
<p>Selector对象是通过调用静态工厂方法open()来实例化的，如下：</p>
<p>Selector Selector&#x3D;Selector.open()；</p>
<p>2、</p>
<p>要实现Selector管理Channel，需要将channel注册到相应的Selector上，如下：</p>
<p>channel.configureBlocking(false);</p>
<p>SelectionKey key&#x3D; channel.register(selector,SelectionKey,OP_READ);</p>
<p>通过调用通道的register()方法会将它注册到一个选择器上。与Selector一起使用时，Channel必须处于非阻塞模式下，否则将抛出IllegalBlockingModeException异常，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道都可以。另外通道一旦被注册，将不能再回到阻塞状态，此时若调用通道的configureBlocking(true)将抛出BlockingModeException异常。</p>
<p>register()方法的第二个参数是“interest集合”，表示选择器所关心的通道操作，它实际上是一个表示选择器在检查通道就绪状态时需要关心的操作的比特掩码。比如一个选择器对通道的read和write操作感兴趣，那么选择器在检查该通道时，只会检查通道的read和write操作是否已经处在就绪状态。</p>
<p>具体的操作类型和通道上能被支持的操作类型前面已经讲述过。</p>
<p>如果Selector对通道的多操作类型感兴趣，可以用“位或”操作符来实现：</p>
<p>int interestSet&#x3D;SelectionKey.OP_READ|SelectionKey.OP_WRITE;</p>
<p>同时 一个 Channel 仅仅可以被注册到一个 Selector 一次, 如果将 Channel 注册到 Selector 多次, 那么其实就是相当于更新 SelectionKey 的 interest set。</p>
<p>通过SelectionKey可以判断Selector是否对Channel的某种事件感兴趣，比如</p>
<p>int interestSet &#x3D; selectionKey.interestOps(); </p>
<p>boolean isInterestedInAccept &#x3D; (interestSet &amp; SelectionKey.OP_ACCEPT) &#x3D;&#x3D; SelectionKey.OP_ACCEPT；</p>
<p>通过SelctionKey对象的readyOps()来获取相关通道已经就绪的操作。它是interest集合的子集，并且表示了interest集合中从上次调用select()以后已经就绪的那些操作。JAVA中定义几个方法用来检查这些操作是否就绪，比如selectionKey.isAcceptable();</p>
<p>同时，通过SelectionKey可以取出这个SelectionKey所关联的Selector和Channel。</p>
<p>如果我们要取消关联关系，怎么办？SelectionKey对象的cancel()方法来取消特定的注册关系。</p>
<p>在实际的应用中，我们还可以为SelectionKey绑定附加对象，在需要的时候取出。</p>
<p>SelectionKey key&#x3D;channel.register(selector,SelectionKey.OP_READ,theObject);</p>
<p>或selectionKey.attach(theObject);</p>
<p>取出这个附加对象，通过：</p>
<p>Object attachedObj &#x3D; key.attachment();</p>
<p>3、</p>
<p>在实际运行中，我们通过Selector的select（）方法可以选择已经准备就绪的通道（这些通道包含你感兴趣的的事件）。</p>
<p>下面是Selector几个重载的select()方法：</p>
<p>select():阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<p>select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。</p>
<p>selectNow():非阻塞，立刻返回。</p>
<p>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。</p>
<p>一旦调用select()方法，并且返回值不为0时，则可以通过调用Selector的selectedKeys()方法来访问已选择键集合。</p>
<p>Set selectedKeys&#x3D;selector.selectedKeys();</p>
<p>这个时候，循环遍历selectedKeys集中的每个键，并检测各个键所对应的通道的就绪事件，再通过SelectionKey关联的Selector和Channel进行实际的业务处理。</p>
<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除，否则的话，下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<p><strong>具体与NIO编程相关的代码参见模块nio下包cn.tuling.nio.nio。从服务端的代码我们可以看到，我们仅用了一个线程就处理了多个客户端的的连接。</strong></p>
<h2 id="重要概念SelectionKey"><a href="#重要概念SelectionKey" class="headerlink" title="重要概念SelectionKey"></a><strong>重要概念SelectionKey</strong></h2><h4 id="什么是SelectionKey"><a href="#什么是SelectionKey" class="headerlink" title="什么是SelectionKey"></a><strong>什么是SelectionKey</strong></h4><p>SelectionKey是一个抽象类,表示selectableChannel在Selector中注册的标识.每个Channel向Selector注册时,都将会创建一个SelectionKey。SelectionKey将Channel与Selector建立了关系，并维护了channel事件。</p>
<p>可以通过cancel方法取消键,取消的键不会立即从selector中移除,而是添加到cancelledKeys中,在下一次select操作时移除它.所以在调用某个key时,需要使用isValid进行校验.</p>
<h4 id="SelectionKey类型和就绪条件"><a href="#SelectionKey类型和就绪条件" class="headerlink" title="SelectionKey类型和就绪条件"></a><strong>SelectionKey类型和就绪条件</strong></h4><p>在向Selector对象注册感兴趣的事件时，JAVA NIO共定义了四种：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT（定义在SelectionKey中），分别对应读、写、请求连接、接受连接等网络Socket操作。</p>
<table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>就绪条件及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>OP_READ</td>
<td>当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作，有的放矢，避免浪费CPU。</td>
</tr>
<tr>
<td>OP_WRITE</td>
<td>当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册。</td>
</tr>
<tr>
<td>OP_CONNECT</td>
<td>当SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用。</td>
</tr>
<tr>
<td>OP_ACCEPT</td>
<td>当接收到一个客户端连接请求时就绪。该操作只给服务器使用。</td>
</tr>
</tbody></table>
<p>关于OP_WRITE的相关代码可以参见包cn.tuling.nio.nio.writeable</p>
<h4 id="服务端和客户端分别感兴趣的类型"><a href="#服务端和客户端分别感兴趣的类型" class="headerlink" title="服务端和客户端分别感兴趣的类型"></a><strong>服务端和客户端分别感兴趣的类型</strong></h4><p>ServerSocketChannel和SocketChannel可以注册自己感兴趣的操作类型，当对应操作类型的就绪条件满足时OS会通知channel，下表描述各种Channel允许注册的操作类型，Y表示允许注册，N表示不允许注册，其中服务器SocketChannel指由服务器ServerSocketChannel.accept()返回的对象。</p>
<table>
<thead>
<tr>
<th></th>
<th>OP_READ</th>
<th>OP_WRITE</th>
<th>OP_CONNECT</th>
<th>OP_ACCEPT</th>
</tr>
</thead>
<tbody><tr>
<td>服务器ServerSocketChannel</td>
<td></td>
<td></td>
<td></td>
<td><strong>Y</strong></td>
</tr>
<tr>
<td>服务器SocketChannel</td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>客户端SocketChannel</td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td></td>
</tr>
</tbody></table>
<p>服务器启动ServerSocketChannel，关注OP_ACCEPT事件，</p>
<p>客户端启动SocketChannel，连接服务器，关注OP_CONNECT事件</p>
<p>服务器接受连接，启动一个服务器的SocketChannel，这个SocketChannel可以关注OP_READ、OP_WRITE事件，一般连接建立后会直接关注OP_READ事件</p>
<p>客户端这边的客户端SocketChannel发现连接建立后，可以关注OP_READ、OP_WRITE事件，一般是需要客户端需要发送数据了才关注OP_READ事件</p>
<p>连接建立后客户端与服务器端开始相互发送消息（读写），根据实际情况来关注OP_READ、OP_WRITE事件。</p>
<p><strong>附录- Buffer详解</strong> </p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a><strong>重要属性</strong></h3><h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a><strong>capacity</strong></h4><p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a><strong>position</strong></h4><p>当你写数据到Buffer中时，position表示当前能写的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h4><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p>
<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>
<h4 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a><strong>Buffer的分配</strong></h4><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有<strong>allocate</strong>方法(可以在堆上分配，也可以在直接内存上分配)。</p>
<p>分配48字节capacity的ByteBuffer的例子:ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</p>
<p>分配一个可存储1024个字符的CharBuffer：CharBuffer buf &#x3D; CharBuffer.allocate(1024);</p>
<p><strong>wrap方法</strong>：把一个byte数组或byte数组的一部分包装成ByteBuffer：</p>
<p>ByteBuffer wrap(byte [] array)</p>
<p>ByteBuffer wrap(byte [] array, int offset, int length) </p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h4><p>HeapByteBuffer与DirectByteBuffer，在原理上，前者可以看出分配的buffer是在heap区域的，其实真正flush到远程的时候会先拷贝到直接内存，再做下一步操作；在NIO的框架下，很多框架会采用DirectByteBuffer来操作，这样分配的内存不再是在java heap上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比HeapByteBuffer要快速好几倍。</p>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。 </p>
<p>NIO可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。</p>
<p><strong>直接内存（堆外内存）与堆内存比较</strong></p>
<p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p>
<p>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p>
<h3 id="Buffer的读写"><a href="#Buffer的读写" class="headerlink" title="Buffer的读写"></a><strong>Buffer的读写</strong></h3><p><strong>向Buffer中写数据</strong></p>
<p><strong>写数据到Buffer有两种方式：</strong></p>
<ul>
<li><strong>读取Channel写到Buffer。</strong></li>
<li><strong>通过Buffer的put()方法写到Buffer里。</strong></li>
</ul>
<p>从Channel写到Buffer的例子</p>
<p><strong>int</strong> bytesRead &#x3D; inChannel.read(buf); &#x2F;&#x2F;read into buffer.</p>
<p>通过put方法写Buffer的例子：</p>
<p>buf.put(127);</p>
<p>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。在比如：</p>
<p>put(byte b)	相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备。</p>
<p><strong>flip()方法</strong></p>
<p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
<p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p>
<p><strong>从Buffer中读取数据</strong></p>
<p><strong>从Buffer中读取数据有两种方式：</strong></p>
<ol>
<li><strong>从Buffer读取数据写入到Channel。</strong></li>
<li><strong>使用get()方法从Buffer中读取数据。</strong></li>
</ol>
<p>从Buffer读取数据到Channel的例子：</p>
<p><strong>int</strong> bytesWritten &#x3D; inChannel.write(buf);</p>
<p>使用get()方法从Buffer中读取数据的例子</p>
<p><strong>byte</strong> aByte &#x3D; buf.get();</p>
<p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组，再比如</p>
<p>get()属于相对读，从position位置读取一个byte，并将position+1，为下次读写作准备;</p>
<p><strong>使用Buffer读写数据常见步骤</strong></p>
<ol>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法，准备下一次的写入</li>
</ol>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。</p>
<h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a><strong>其他常用操作</strong></h3><h4 id="绝对读写"><a href="#绝对读写" class="headerlink" title="绝对读写"></a><strong>绝对读写</strong></h4><p>put(int index, byte b)	绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变position的值。</p>
<p> get(int index)属于绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position。</p>
<p>更多Buffer实现的细节参考JavaDoc。</p>
<p><strong>rewind()方法</strong></p>
<p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<p><strong>clear()与compact()方法</strong></p>
<p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p>
<p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<p><strong>mark()与reset()方法</strong></p>
<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如：</p>
<p>buffer.mark();&#x2F;&#x2F;call buffer.get() a couple of times, e.g. during parsing.</p>
<p>buffer.reset(); &#x2F;&#x2F;set position back to mark.</p>
<p><strong>equals()与compareTo()方法</strong></p>
<p>可以使用equals()和compareTo()方法两个Buffer。</p>
<p><strong>equals()</strong></p>
<p>当满足下列条件时，表示两个Buffer相等：</p>
<ol>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ol>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p>
<p><strong>compareTo()方法</strong></p>
<p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ol>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ol>
<h3 id="Buffer方法总结"><a href="#Buffer方法总结" class="headerlink" title="Buffer方法总结"></a><strong>Buffer方法总结</strong></h3><table>
<thead>
<tr>
<th>limit(), limit(10)等</th>
<th>其中读取和设置这4个属性的方法的命名和jQuery中的val(),val(10)类似，一个负责get，一个负责set</th>
</tr>
</thead>
<tbody><tr>
<td>reset()</td>
<td>把position设置成mark的值，相当于之前做过一个标记，现在要退回到之前标记的地方</td>
</tr>
<tr>
<td>clear()</td>
<td>position &#x3D; 0;limit &#x3D; capacity;mark &#x3D; -1; 有点初始化的味道，但是并不影响底层byte数组的内容</td>
</tr>
<tr>
<td>flip()</td>
<td>limit &#x3D; position;position &#x3D; 0;mark &#x3D; -1; 翻转，也就是让flip之后的position到limit这块区域变成之前的0到position这块，翻转就是将一个处于存数据状态的缓冲区变为一个处于准备取数据的状态</td>
</tr>
<tr>
<td>rewind()</td>
<td>把position设为0，mark设为-1，不改变limit的值</td>
</tr>
<tr>
<td>remaining()</td>
<td>return limit - position;返回limit和position之间相对位置差</td>
</tr>
<tr>
<td>hasRemaining()</td>
<td>return position &lt; limit返回是否还有未读内容</td>
</tr>
<tr>
<td>compact()</td>
<td>把从position到limit中的内容移到0到limit-position的区域内，position和limit的取值也分别变成limit-position、capacity。如果先将positon设置到limit，再compact，那么相当于clear()</td>
</tr>
<tr>
<td>get()</td>
<td>相对读，从position位置读取一个byte，并将position+1，为下次读写作准备</td>
</tr>
<tr>
<td>get(int index)</td>
<td>绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position</td>
</tr>
<tr>
<td>get(byte[] dst, int offset, int length)</td>
<td>从position位置开始相对读，读length个byte，并写入dst下标从offset到offset+length的区域</td>
</tr>
<tr>
<td>put(byte b)</td>
<td>相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备</td>
</tr>
<tr>
<td>put(int index, byte b)</td>
<td>绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变position</td>
</tr>
<tr>
<td>put(ByteBuffer src)</td>
<td>用相对写，把src中可读的部分（也就是position到limit）写入此byteBuffer</td>
</tr>
<tr>
<td>put(byte[] src, int offset, int length)</td>
<td>从src数组中的offset到offset+length区域读取数据并使用相对写写入此byteBuffer</td>
</tr>
</tbody></table>
<p>Buffer相关的代码参见模块nio下包cn.tuling.nio.buffer</p>
<h3 id="Reactor模式类型"><a href="#Reactor模式类型" class="headerlink" title="Reactor模式类型"></a><strong>Reactor模式类型</strong></h3><p><strong>单线程Reactor模式流程：</strong></p>
<ul>
<li><ul>
<li>服务器端的Reactor是一个线程对象，该线程会启动事件循环，并使用Selector(选择器)来实现IO的多路复用。注册一个Acceptor事件处理器到Reactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样Reactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</li>
</ul>
</li>
</ul>
<p>② 客户端向服务器端发起一个连接请求，Reactor监听到了该ACCEPT事件的发生并将该ACCEPT事件派发给相应的Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的READ事件以及对应的READ事件处理器注册到Reactor中，这样一来Reactor就会监听该连接的READ事件了。</p>
<p>③ 当Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过SocketChannel的read()方法读取数据，此时read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</p>
<p>④ 每当处理完所有就绪的感兴趣的I&#x2F;O事件后，Reactor线程会再次执行select()阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</p>
<p>注意，Reactor的单线程模式的单线程主要是针对于I&#x2F;O操作而言，也就是所有的I&#x2F;O的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
<p>但在目前的单线程Reactor模式中，不仅I&#x2F;O操作在该Reactor线程上，连非I&#x2F;O的业务操作也在该线程上进行处理了，这可能会大大延迟I&#x2F;O请求的响应。所以我们应该将非I&#x2F;O的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对I&#x2F;O请求的响应。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image12.png" alt="0"></p>
<h4 id="单线程Reactor，工作者线程池"><a href="#单线程Reactor，工作者线程池" class="headerlink" title="单线程Reactor，工作者线程池"></a><strong>单线程Reactor，工作者线程池</strong></h4><p>与单线程Reactor模式不同的是，添加了一个工作者线程池，并将非I&#x2F;O操作从Reactor线程中移出转交给工作者线程池来执行。这样能够提高Reactor线程的I&#x2F;O响应，不至于因为一些耗时的业务逻辑而延迟对后面I&#x2F;O请求的处理。</p>
<p>使用线程池的优势：</p>
<p>① 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程产生的巨大开销。</p>
<p>② 另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p>
<p>③ 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p>
<p>改进的版本中，所以的I&#x2F;O操作依旧由一个Reactor来完成，包括I&#x2F;O的accept()、read()、write()以及connect()操作。</p>
<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：</p>
<p>① 一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的读取和发送；</p>
<p>② 当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image13.png" alt="0"></p>
<h4 id="多Reactor线程模式"><a href="#多Reactor线程模式" class="headerlink" title="多Reactor线程模式"></a><strong>多Reactor线程模式</strong></h4><p>Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的事件循环逻辑。</p>
<p>mainReactor可以只有一个，但subReactor一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的SocketChannel传递给subReactor，由subReactor来完成和客户端的通信。</p>
<p>流程：</p>
<p>① 注册一个Acceptor事件处理器到mainReactor中，Acceptor事件处理器所关注的事件是ACCEPT事件，这样mainReactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动mainReactor的事件循环。</p>
<p>② 客户端向服务器端发起一个连接请求，mainReactor监听到了该ACCEPT事件并将该ACCEPT事件派发给Acceptor处理器来进行处理。Acceptor处理器通过accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将这个SocketChannel传递给subReactor线程池。</p>
<p>③ subReactor线程池分配一个subReactor线程给这个SocketChannel，即，将SocketChannel关注的READ事件以及对应的READ事件处理器注册到subReactor线程中。当然你也注册WRITE事件以及WRITE事件处理器到subReactor线程中以完成I&#x2F;O写操作。Reactor线程池中的每一Reactor线程都会有自己的Selector、线程和分发的循环逻辑。</p>
<p>④ 当有I&#x2F;O事件就绪时，相关的subReactor就将事件派发给响应的处理器处理。注意，这里subReactor线程只负责完成I&#x2F;O的read()操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的I&#x2F;O的write操作还是会被提交回subReactor线程来完成。</p>
<p>注意，所以的I&#x2F;O操作(包括，I&#x2F;O的accept()、read()、write()以及connect()操作)依旧还是在Reactor线程(mainReactor线程 或 subReactor线程)中完成的。Thread Pool(线程池)仅用来处理非I&#x2F;O操作的逻辑。</p>
<p>多Reactor线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个Reactor线程来完成。mainReactor完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给subReactor线程来完成与客户端的通信，这样一来就不会因为read()数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多Reactor线程模式在海量的客户端并发请求的情况下，还可以通过实现subReactor线程池来将海量的连接分发给多个subReactor线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p>
<p><strong>Netty服务端使用了“多Reactor线程模式”</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image14.png" alt="0"></p>
<p><strong>和观察者模式的区别</strong></p>
<p><strong>观察者模式：</strong> 　也可以称为为 发布-订阅 模式，主要适用于多个对象依赖某一个对象的状态并，当某对象状态发生改变时，要通知其他依赖对象做出更新。是一种一对多的关系。当然，如果依赖的对象只有一个时，也是一种特殊的一对一关系。通常，观察者模式适用于消息事件处理，监听者监听到事件时通知事件处理者对事件进行处理（这一点上面有点像是回调，容易与反应器模式和前摄器模式的回调搞混淆）<strong>。 Reactor模</strong>式： 　reactor模式，即反应器模式，是一种高效的异步IO模式，特征是回调，当IO完成时，回调对应的函数进行处理。这种模式并非是真正的异步，而是运用了异步的思想，当IO事件触发时，通知应用程序作出IO处理。模式本身并不调用系统的异步IO函数。</p>
<p>reactor模式与观察者模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>
<p><strong>3、直接内存深入辨析</strong></p>
<p>在所有的网络通信和应用程序中，每个TCP的Socket的内核中都有一个发送缓冲区(SO_SNDBUF)和一个接收缓冲区(SO_RECVBUF)，可以使用相关套接字选项来更改该缓冲区大小。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image15.png" alt="0"></p>
<p>当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，假设该套接字是阻塞的，则该应用进程将被投入睡眠。</p>
<p>内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP或应用进程已接收到数据。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image16.png" alt="0"></p>
<p>Java程序自然也要遵守上述的规则。但在Java中存在着堆、垃圾回收等特性，所以在实际的IO中，在JVM内部的存在着这样一种机制：</p>
<p>在IO读写上，如果是使用堆内存，JDK会先创建一个DirectBuffer，再去执行真正的写操作。这是因为，当我们把一个地址通过JNI传递给底层的C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在GC管理下的对象是会在Java堆中移动的。也就是说，有可能我把一个地址传给底层的write，但是这段内存却因为GC整理内存而失效了。所以必须要把待发送的数据放到一个GC管不着的地方。这就是调用native方法之前，数据—定要在堆外内存的原因。</p>
<p>可见，站在网络通信的角度DirectBuffer并没有节省什么内存拷贝，只是Java网络通信里因为HeapBuffer必须多做一次拷贝，使用DirectBuffer就会少一次内存拷贝。相比没有使用堆内存的Java程序，使用直接内存的Java程序当然更快一点。</p>
<p>从垃圾回收的角度而言，直接内存不受 GC(新生代的 Minor GC) 影响，只有当执行老年代的 Full GC 时候才会顺便回收直接内存，整理内存的压力也比数据放到HeapBuffer要小。</p>
<p><strong>堆外内存的优点和缺点</strong></p>
<p>堆外内存相比于堆内内存有几个优势： 　　1 减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作（可能使用多线程或者时间片的方式，根本感觉不到） 　　2 加快了复制的速度。因为堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。 　　而福之祸所依，自然也有不好的一面： 　　1 堆外内存难以控制，如果内存泄漏，那么很难排查 　　2 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</p>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a><strong>零拷贝</strong></h1><h2 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝?"></a><strong>什么是零拷贝?</strong></h2><p>零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
<p>➢零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</p>
<p>➢零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销</p>
<p>可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p>
<p>下面这些组件、框架中均使用了零拷贝技术：Kafka、Netty、Rocketmq、Nginx、Apache。</p>
<h2 id="Linux的I-x2F-O机制与DMA"><a href="#Linux的I-x2F-O机制与DMA" class="headerlink" title="Linux的I&#x2F;O机制与DMA"></a><strong>Linux的I&#x2F;O机制与DMA</strong></h2><p>在早期计算机中，用户进程需要读取磁盘数据，需要CPU中断和CPU参与，因此效率比较低，发起IO请求，每次的IO中断，都带来CPU的上下文切换。因此出现了——DMA。</p>
<p>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。</p>
<p>DMA控制器，接管了数据读写请求，减少CPU的负担。这样一来，CPU能高效工作了。现代硬盘基本都支持DMA。</p>
<p>实际因此IO读取，涉及两个过程：</p>
<p>1、DMA等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</p>
<p>2、用户进程，将内核缓冲区的数据copy到用户空间。</p>
<p>这两个过程，都是阻塞的。</p>
<h2 id="传统数据传送机制"><a href="#传统数据传送机制" class="headerlink" title="传统数据传送机制"></a><strong>传统数据传送机制</strong></h2><p>比如：读取文件，再用socket发送出去，实际经过四次copy。</p>
<p>伪码实现如下：</p>
<p>buffer &#x3D; File.read() </p>
<p>Socket.send(buffer)</p>
<p>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；</p>
<p>2、第二次：将内核缓冲区的数据，copy到应用程序的buffer；</p>
<p>3、第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；</p>
<p>4、第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image17.png" alt="0"></p>
<p>分析上述的过程，虽然引入DMA来接管CPU的中断请求，但四次copy是存在“不必要的拷贝”的。实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。</p>
<p>显然，第二次和第三次数据copy 其实在这种场景下没有什么帮助反而带来开销，这也正是零拷贝出现的背景和意义。</p>
<p>同时，read和send都属于系统调用，每次调用都牵涉到两次上下文切换：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image18.png" alt="0"></p>
<p>总结下，传统的数据传送所消耗的成本：4次拷贝，4次上下文切换。</p>
<p>4次拷贝，其中两次是DMA copy，两次是CPU copy。</p>
<p><strong>Linux支持的(常见)零拷贝</strong></p>
<p>目的：减少IO流程中不必要的拷贝，当然零拷贝需要OS支持，也就是需要kernel暴露api。</p>
<h2 id="mmap内存映射"><a href="#mmap内存映射" class="headerlink" title="mmap内存映射"></a><strong>mmap内存映射</strong></h2><p> 硬盘上文件的位置和应用程序缓冲区(application buffers)进行映射（建立一种一一对应关系），由于mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。</p>
<p>mmap内存映射将会经历：3次拷贝: 1次cpu copy，2次DMA copy；</p>
<p>以及4次上下文切换</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image19.png" alt="0"></p>
<p><strong>sendfile</strong></p>
<p>linux 2.1支持的sendfile</p>
<p>当调用sendfile()时，DMA将磁盘数据复制到kernel buffer，然后将内核中的kernel buffer直接拷贝到socket buffer；但是数据并未被真正复制到socket关联的缓冲区内。取而代之的是，只有记录数据位置和长度的描述符被加入到socket缓冲区中。DMA模块将数据直接从内核缓冲区传递给协议引擎，从而消除了遗留的最后一次复制。</p>
<p>一旦数据全都拷贝到socket buffer，sendfile()系统调用将会return、代表数据转化的完成。socket buffer里的数据就能在网络传输了。</p>
<p>sendfile会经历：3次拷贝，1次CPU copy 2次DMA copy；</p>
<p>以及2次上下文切换</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image20.png" alt="0"></p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a><strong>splice</strong></h2><p>Linux 从2.6.17 支持splice</p>
<p>数据从磁盘读取到OS内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。</p>
<p>如下图所示，从磁盘读取到内核buffer后，在内核空间直接与socket buffer建立pipe管道。</p>
<p>和sendfile()不同的是，splice()不需要硬件支持。</p>
<p>注意splice和sendfile的不同，sendfile是将磁盘数据加载到kernel buffer后，需要一次CPU copy，拷贝到socket buffer。而splice是更进一步，连这个CPU copy也不需要了，直接将两个内核空间的buffer进行pipe。</p>
<p>splice会经历 2次拷贝: 0次cpu copy 2次DMA copy；</p>
<p>以及2次上下文切换</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/socket/image21.png" alt="0"></p>
<h2 id="总结Linux中零拷贝"><a href="#总结Linux中零拷贝" class="headerlink" title="总结Linux中零拷贝"></a><strong>总结Linux中零拷贝</strong></h2><p>最早的零拷贝定义，来源于</p>
<p><em>Linux 2.4内核新增 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIO Buffer(socket buffer)，无需 CPU 拷贝。这也是零拷贝这一说法的来源。这是真正操作系统 意义上的零拷贝(也就是狭义零拷贝)。</em></p>
<p>但是我们知道，由OS内核提供的 操作系统意义上的零拷贝，发展到目前也并没有很多种，也就是这样的零拷贝并不是很多；</p>
<p>随着发展，零拷贝的概念得到了延伸，就是目前的减少不必要的数据拷贝都算作零拷贝的范畴。</p>
<p><strong>Java生态圈中的零拷贝</strong></p>
<p>Linux提供的零拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；</p>
<p><strong>NIO提供的内存映射 MappedByteBuffer</strong></p>
<p>NIO中的FileChannel.map()方法其实就是采用了操作系统中的内存映射方式，底层就是调用Linux mmap()实现的。</p>
<p>将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射。这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过SocketChannel发送，还是需要CPU进行数据的拷贝。</p>
<p><strong>NIO提供的sendfile</strong></p>
<p>Java NIO 中提供的 FileChannel 拥有 transferTo 和 transferFrom 两个方法，可直接把 FileChannel 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel。该接口常被用于高效的网络 &#x2F; 文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于 Java IO 中提供的方法。</p>
<p><strong>Kafka中的零拷贝</strong></p>
<p>Kafka两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是Producer生产的数据存到broker，二是 Consumer从broker读取数据。</p>
<p>Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；</p>
<p>Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</p>
<p><strong>Netty的零拷贝实现</strong></p>
<p>Netty 的零拷贝主要包含三个方面：</p>
<p>在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
<p>在缓存操作上，Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</p>
<p>通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。</p>
<p>ByteBuf支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</p>
<p>在文件传输上，Netty 的通过FileRegion包装的FileChannel.tranferTo实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/04/01/Tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/Tomcat/" class="post-title-link" itemprop="url">Tomcat</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 21:51:28" itemprop="dateCreated datePublished" datetime="2022-04-01T21:51:28+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-14 23:33:12" itemprop="dateModified" datetime="2022-04-14T23:33:12+08:00">2022-04-14</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="⼀、Tomcat处理请求过程"><a href="#⼀、Tomcat处理请求过程" class="headerlink" title="⼀、Tomcat处理请求过程"></a>⼀、Tomcat处理请求过程</h1><p>Tomcat通过Endpoint组件接收socket连接，接收到⼀个socket连接后会执⾏如下步骤 </p>
<ol>
<li>第⼀次从socket中获取数据到InputBuffer中，BIO对应的是InternalInputBuffer，⽗类是 AbstractInputBuffer </li>
<li>然后基于InputBuffer进⾏解析数据 </li>
<li>先解析请求⾏，把请求⽅法，请求uri，请求协议等封装到org.apache.coyote.Request对象中 </li>
<li>org.apache.coyote.Request中的属性都是MessageBytes类型，直接可以理解为字节类型，因为从 socket中获取的数据都是字节，在解析过程中不⽤直接把字节转成字符串，并且MessageBytes虽然表 示字节，但是它并不会真正的存储字节，还是使⽤ByteChunk基于InputBuffer中的字节数组来进⾏标 记，标记字节数组中的哪个⼀个范围表示请求⽅法，哪个⼀个范围表示请求uri等等。 </li>
<li>然后解析头，和解析请求⾏类似 </li>
<li>解析完请求头后，就基于请求头来初始化⼀些参数，⽐如Connection是keepalive是close，⽐如是否 有Content-length，并且对于的⻓度是多少等等，还包括当前请求在处理请求体时应该使⽤哪个 InputFilter。 </li>
<li>然后将请求交给容器 </li>
<li>容器再将请求交给具体的servlet进⾏处理 </li>
<li>servlet在处理请求的过程中会利⽤response进⾏响应，返回数据给客户端，⼀个普通的响应过程会把 数据先写⼊⼀个缓冲区，当调⽤flush，或者close⽅法时会把缓冲区中的内容发送给socet</li>
<li>servlet处理完请求后，先会检查是否需要把响应数据发送给socket </li>
<li>接着看当前请求的请求体是否处理结束，是否还有剩余数据，如果有剩余数据需要把这些数据处理掉， 以便能够获取到下⼀个请求的数据 </li>
<li>然后回到第⼀步开始处理下⼀个请求</li>
</ol>
<h1 id="⼆、Tomcat响应数据过程"><a href="#⼆、Tomcat响应数据过程" class="headerlink" title="⼆、Tomcat响应数据过程"></a>⼆、Tomcat响应数据过程</h1><p>当我们在Servlet中调⽤如下⽅法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;test&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>resp对应的类型为ResponseFacade, 得到的outputStream的类型为CoyoteOutputStream。 所以响应数据是通过CoyoteOutputStream这个类处理的。 当调⽤outputStream的write⽅法写数据时，实际调⽤的就是CoyoteOutputStream类的write(byte[] b) ⽅法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	ob.write(b, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CoyoteOutputStream类中有⼀个属性是ob，类型为org.apache.catalina.connector.OutputBuffer ，该属性是在构造CoyoteOutputStream对象时初始化的。先注意OutputBuffer所在的包。 我们在调⽤write⽅法时，实际就是调⽤OutputBuffer的write⽅法，⽽write⽅法实际调⽤的就是该类中的 writeBytes(byte b[], int off, int len)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeBytes</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (closed) &#123;</span><br><span class="line"> 		<span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  bb.append(b, off, len);</span><br><span class="line">	bytesWritten += len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if called from within flush(), then immediately flush</span></span><br><span class="line">	<span class="comment">// remaining bytes</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (doFlush) &#123;</span><br><span class="line"> 	<span class="comment">// 那么每次write都把缓冲中的数据发送出去</span></span><br><span class="line"> 	bb.flushBuffer();</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在OutputBuffer中有⼀个属性叫做bb，类型是ByteChunk。在Tomcat响应流程中，可以把ByteChunk类 当作⼀个缓冲区的实现，该类中有⼀个字节数组，名字叫做buff，默认⼤⼩为8192。 </p>
<p>当我们在write字节数据时，就是把数据添加到ByteChunk对应的缓冲区buff中。当把数据添加到缓冲区 后，如果有其他线程在执⾏outputSteam的flush()⽅法，则doFlush为true，那么则会调⽤ bb.flushBuffer()。 </p>
<p>这⾥就要考虑⼀个问题，我们把数据都写到了缓冲区buff中，那么buff中的数据是何时传递给socket中的 呢？</p>
<p>在ByteChunk中有⼀个属性out，类型是ByteOutputChannel，它表示缓冲区中的数据该向流向哪个渠 道，为了⽅便理解，可以先理解为渠道就是socket，表示把缓冲区中的数据发送给socket，当实际情况并 不是，暂且这么理解。</p>
<p> ByteOutputChannel类中有⼀个⽅法realWriteBytes(byte buf[], int off, int len)，当调⽤ out.realWriteBytes(src, off, len)⽅法时，就会把src数据发送给对应驱动 </p>
<p>在当前这个ByteChunk中，它的out对应的仍然还是org.apache.catalina.connector.OutputBuffer，在这个类中存在该⽅法：</p>
<div class="pdfobject-container" data-target="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/Tomcat/Tomcat/%E4%B8%80%E3%80%81Tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="二、Tomcat响应数据过程.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="三、Tomcat中BIO和NIO底层原理实现对比.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="四、Tomcat中的类加载器与安全机制.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="五、Tomcat的架构、生命周期、事件监听.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="六、Tomcat启动过程.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="七、Tomcat热部署与热加载.pdf" data-height="500px"></div>

<div class="pdfobject-container" data-target="八、Tomcat中关于Session的实现.pdf" data-height="500px"></div>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">垃圾收集器</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-23 20:54:48 / 修改时间：21:16:27" itemprop="dateCreated datePublished" datetime="2022-03-23T20:54:48+08:00">2022-03-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">垃圾收集器</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="G1收集器-XX-UseG1GC"><a href="#G1收集器-XX-UseG1GC" class="headerlink" title="G1收集器(-XX:+UseG1GC)"></a><strong>G1收集器(-XX:+UseG1GC)</strong></h1><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/%E6%88%AA%E5%9B%BE.png" alt="0"></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/%E6%88%AA%E5%9B%BE%20(1).png" alt="0"></p>
<p>G1将Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），JVM目标是不超过2048个Region(JVM源码里TARGET_REGION_NUMBER 定义)，实际可以超过该值，但是不推荐。</p>
<p>一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数”-XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。</p>
<p>G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>
<p>默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”调整。年轻代中的Eden和Survivor对应的region也跟之前一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应100个。</p>
<p>一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。</p>
<p>G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，<strong>唯一不同的是对大对象的处理</strong>，G1有专门分配大对象的Region叫<strong>Humongous区</strong>，而不是让大对象直接进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Region来存放。</p>
<p>Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。</p>
<p>Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
<p>G1收集器一次GC(主要值Mixed GC)的运作过程大致分为以下几个步骤：</p>
<ul>
<li><p><strong>初始标记</strong>（initial mark，STW）：暂停所有的其他线程，并记录下gc roots直接能引用的对象，<strong>速度很快</strong> ；</p>
</li>
<li><p><strong>并发标记</strong>（Concurrent Marking）：同CMS的并发标记</p>
</li>
<li><p><strong>最终标记</strong>（Remark，STW）：同CMS的重新标记</p>
</li>
<li><p><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的<strong>回收价值和成本进行排序</strong>，<strong>根据用户所期望的GC停顿STW时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制定回收计划</strong>，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region(<strong>Collection Set</strong>，要回收的集合)，尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代或是老年代，<strong>回收算法主要用的是复制算法</strong>，<strong>将一个region中的存活对象复制到另一个region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制算法回收几乎不会有太多内存碎片</strong>。(注意：CMS回收阶段是跟用户线程一起并发执行的，G1因为内部实现太复杂暂时没实现并发回收，不过到了ZGC，Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本)</p>
</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(12).png" alt="0"></p>
<p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率。</p>
<p>被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li>
<li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“<strong>标记整理</strong>”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段(通过参数”<strong>-XX:MaxGCPauseMillis</strong>“指定)内完成垃圾收集。</li>
</ul>
<p>毫无疑问， 可以由用户指定期望的停顿时间是G1收集器很强大的一个功能， 设置不同的期望停顿时间， 可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。 不过， 这里设置的“期望值”必须是符合实际的， 不能异想天开， 毕竟G1是要冻结用户线程来复制对象的， 这个停顿时</p>
<p>间再怎么低也得有个限度。 它默认的停顿目标为两百毫秒， 一般来说， 回收阶段占到几十到一百甚至接近两百毫秒都很正常， 但如果我们把停顿时间调得非常低， 譬如设置为二十毫秒， 很可能出现的结果就是由于停顿目标时间太短， 导致每次选出来的回收集只占堆内存很小的一部分， 收集器收集的速度逐渐跟不上分配器分配的速度， 导致垃圾慢慢堆积。 很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间， 但应用运行时间一长就不行了， 最终占满堆引发Full GC反而降低性能， 所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
<h2 id="G1垃圾收集分类"><a href="#G1垃圾收集分类" class="headerlink" title="G1垃圾收集分类"></a><strong>G1垃圾收集分类</strong></h2><h3 id="YoungGC"><a href="#YoungGC" class="headerlink" title="YoungGC"></a><strong>YoungGC</strong></h3><p>YoungGC并不是说现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC</p>
<h3 id="MixedGC"><a href="#MixedGC" class="headerlink" title="MixedGC"></a><strong>MixedGC</strong></h3><p>不是FullGC，老年代的堆占有率达到参数(<strong>-XX:InitiatingHeapOccupancyPercent</strong>)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及<strong>大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用复制算法，需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现<strong>没有足够的空region</strong>能够承载拷贝对象就会触发一次Full GC</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a><strong>Full GC</strong></h3><p>停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下一次MixedGC使用，这个过程是非常耗时的。(Shenandoah优化成多线程收集了)</p>
<h2 id="G1收集器参数设置"><a href="#G1收集器参数设置" class="headerlink" title="G1收集器参数设置"></a><strong>G1收集器参数设置</strong></h2><p>  -XX:+UseG1GC:使用G1收集器</p>
<p>  -XX:ParallelGCThreads:指定GC工作的线程数量</p>
<p>  -XX:G1HeapRegionSize:指定分区大小(1MB~32MB，且必须是2的N次幂)，默认将整堆划分为2048个分区</p>
<p>  -XX:MaxGCPauseMillis:目标暂停时间(默认200ms)</p>
<p>  -XX:G1NewSizePercent:新生代内存初始空间(默认整堆5%，值配置整数，默认就是百分比)</p>
<p>  -XX:G1MaxNewSizePercent:新生代内存最大空间</p>
<p>  -XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代</p>
<p>  -XX:MaxTenuringThreshold:最大年龄阈值(默认15)</p>
<p>  -XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行新生代和老年代的混合收集(<strong>MixedGC</strong>)，比如我们之前说的堆默认有2048个region，如果有接近1000个region都是老年代的region，则可能就要触发MixedGC了</p>
<p> -XX:G1MixedGCLiveThresholdPercent(默认85%)  region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。</p>
<p>  -XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。</p>
<p>  -XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</p>
<h2 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a><strong>G1垃圾收集器优化建议</strong></h2><p>假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代gc。</p>
<p>那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。</p>
<p>或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。</p>
<p>所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触发mixed gc.</p>
<h2 id="什么场景适合使用G1"><a href="#什么场景适合使用G1" class="headerlink" title="什么场景适合使用G1"></a><strong>什么场景适合使用G1</strong></h2><ol>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间特别长，超过1秒</li>
<li>8GB以上的堆内存(建议值)</li>
<li>停顿时间是500ms以内</li>
</ol>
<h2 id="每秒几十万并发的系统如何优化JVM"><a href="#每秒几十万并发的系统如何优化JVM" class="headerlink" title="每秒几十万并发的系统如何优化JVM"></a><strong>每秒几十万并发的系统如何优化JVM</strong></h2><p>Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，我们以前常说的对于eden区的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四十G的eden区可能也就一两分钟吧，那么意味着整个系统每运行一两分钟就会因为young gc卡顿几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，我们可以使用G1收集器，设置 -XX:MaxGCPauseMills 为50ms，假设50ms能够回收三到四个G内存，然后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边收集垃圾。</p>
<p>G1天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的问题。</p>
<h1 id="ZGC收集器-XX-UseZGC"><a href="#ZGC收集器-XX-UseZGC" class="headerlink" title="ZGC收集器(-XX:+UseZGC)"></a><strong>ZGC收集器(-XX:+UseZGC)</strong></h1><p>参考文章：<a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/zgc/Main">https://wiki.openjdk.java.net/display/zgc/Main</a></p>
<p><a target="_blank" rel="noopener" href="http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf">http://cr.openjdk.java.net/~pliden/slides/ZGC-Jfokus-2018.pdf</a></p>
<p>ZGC是一款JDK 11中新加入的具有实验性质的低延迟垃圾收集器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(13).png" alt="0"></p>
<h2 id="ZGC目标"><a href="#ZGC目标" class="headerlink" title="ZGC目标"></a><strong>ZGC目标</strong></h2><p>如下图所示，ZGC的目标主要有4个：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(14).png" alt="0"></p>
<ul>
<li><strong>支持TB量级的堆</strong>。我们生产环境的硬盘还没有上TB呢，这应该可以满足未来十年内，所有JAVA应用的需求了吧。 </li>
<li><strong>最大GC停顿时间不超10ms</strong>。目前一般线上环境运行良好的JAVA应用Minor GC停顿时间在10ms左右，Major GC一般都需要100ms以上（G1可以调节停顿时间，但是如果调的过低的话，反而会适得其反），之所以能做到这一点是因为它的停顿时间主要跟Root扫描有关，而Root数量和堆大小是没有任何关系的。 </li>
<li><strong>奠定未来GC特性的基础</strong>。</li>
<li>**最糟糕的情况下吞吐量会降低15%**。这都不是事，停顿时间足够优秀。至于吞吐量，通过扩容分分钟解决。</li>
</ul>
<p>另外，Oracle官方提到了它最大的优点是：它的停顿时间不会随着堆的增大而增长！也就是说，几十G堆的停顿时间是10ms以下，几百G甚至上T堆的停顿时间也是10ms以下。</p>
<h2 id="不分代-暂时"><a href="#不分代-暂时" class="headerlink" title="不分代(暂时)"></a><strong>不分代(暂时)</strong></h2><p>单代，即ZGC「没有分代」。我们知道以前的垃圾回收器之所以分代，是因为源于“「大部分对象朝生夕死」”的假设，事实上大部分系统的对象分配行为也确实符合这个假设。</p>
<p>那么为什么ZGC就不分代呢？因为分代实现起来麻烦，作者就先实现出一个比较简单可用的单代版本，后续会优化。</p>
<h2 id="ZGC内存布局"><a href="#ZGC内存布局" class="headerlink" title="ZGC内存布局"></a><strong>ZGC内存布局</strong></h2><p>ZGC收集器是一款基于Region内存布局的， 暂时不设分代的， 使用了<strong>读屏障、 颜色指针</strong>等技术来实现可并发的标记-整理算法的， 以低延迟为首要目标的一款垃圾收集器。</p>
<p>ZGC的Region可以具有如图3-19所示的大、 中、 小三类容量：</p>
<ul>
<li>小型Region（Small Region） ： 容量固定为2MB， 用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region） ： 容量固定为32MB， 用于放置大于等于256KB但小于4MB的对象。</li>
<li>大型Region（Large Region） ： 容量不固定， 可以动态变化， 但必须为2MB的整数倍， 用于放置4MB或以上的大对象。 <strong>每个大型Region中只会存放一个大对象</strong>， 这也预示着虽然名字叫作“大型Region”， 但它的实际容量完全有可能小于中型Region， 最小容量可低至4MB。 大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作， 用于复制对象的收集器阶段， 稍后会介绍到）的， 因为复制一个大对象的代价非常高昂。</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(15).png" alt="0"></p>
<h2 id="NUMA-aware"><a href="#NUMA-aware" class="headerlink" title="NUMA-aware"></a><strong>NUMA-aware</strong></h2><p>NUMA对应的有UMA，UMA即<strong>Uniform Memory Access Architecture</strong>，NUMA就是Non Uniform Memory Access Architecture。UMA表示内存只有一块，所有CPU都去访问这一块内存，那么就会存在竞争问题（争夺内存总线访问权），有竞争就会有锁，有锁效率就会受到影响，而且CPU核心数越多，竞争就越激烈。NUMA的话每个CPU对应有一块内存，且这块内存在主板上离这个CPU是最近的，每个CPU优先访问这块内存，那效率自然就提高了：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/640.webp" alt="0"></p>
<p>服务器的NUMA架构在中大型系统上一直非常盛行，也是高性能的解决方案，尤其在系统延迟方面表现都很优秀。ZGC是能自动感知NUMA架构并充分利用NUMA架构特性的。</p>
<h2 id="ZGC运作过程"><a href="#ZGC运作过程" class="headerlink" title="ZGC运作过程"></a><strong>ZGC运作过程</strong></h2><p>ZGC的运作过程大致可划分为以下四个大的阶段：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(16).png" alt="0"></p>
<ul>
<li><strong>并发标记（Concurrent Mark）</strong>：与G1一样，并发标记是遍历对象图做可达性分析的阶段，它的初始标记(<strong>Mark Start</strong>)和最终标记(<strong>Mark End</strong>)也会出现短暂的停顿，与G1不同的是， ZGC的标记是在指针上而不是在对象上进行的， 标记阶段会更新<strong>颜色指针</strong>(见下面详解)中的Marked 0、 Marked 1标志位。</li>
<li><strong>并发预备重分配（Concurrent Prepare for Relocate）</strong>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。</li>
<li><strong>并发重分配（Concurrent Relocate）</strong>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个<strong>转发表（Forward Table）</strong>，记录从旧对象到新对象的转向关系。ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障(<strong>读屏障</strong>(见下面详解))所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。</li>
</ul>
<p>​                ZGC的颜色指针因为“自愈”（Self-Healing）能力，所以只有第一次访问旧对象会变慢， 一旦重分配集中某个Region的存活对象都复制完毕后， 这个Region就可以立即释放用于新对象的分配，但是转发表还得留着不能释放掉， 因为可能还有访问在使用这个转发表。              </p>
<ul>
<li><strong>并发重映射（Concurrent Remap）</strong>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，但是ZGC中对象引用存在“自愈”功能，所以这个重映射操作并不是很迫切。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所有对象的，这样合并就节省了一次遍历对象图的开销。一旦所有指针都被修正之后， 原来记录新旧对象关系的转发表就可以释放掉了。</li>
</ul>
<h2 id="颜色指针"><a href="#颜色指针" class="headerlink" title="颜色指针"></a><strong>颜色指针</strong></h2><p>Colored Pointers，即颜色指针，如下图所示，ZGC的核心设计之一。以前的垃圾回收器的GC信息都保存在对象头中，而ZGC的GC信息保存在指针中。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(20).png" alt="0"></p>
<p>每个对象有一个64位指针，这64位被分为：</p>
<ul>
<li>18位：预留给以后使用；</li>
<li>1位：Finalizable标识，此位与并发引用处理有关，它表示这个对象只能通过finalizer才能访问；</li>
<li>1位：Remapped标识，设置此位的值后，对象未指向relocation set中（relocation set表示需要GC的Region集合）；</li>
<li>1位：Marked1标识；</li>
<li>1位：Marked0标识，和上面的Marked1都是标记对象用于辅助GC；</li>
<li>42位：对象的地址（所以它可以支持2^42&#x3D;4T内存）：</li>
</ul>
<h3 id="为什么有2个mark标记？"><a href="#为什么有2个mark标记？" class="headerlink" title="为什么有2个mark标记？"></a><strong>为什么有2个mark标记？</strong></h3><p>每一个GC周期开始时，会交换使用的标记位，使上次GC周期中修正的已标记状态失效，所有引用都变成未标记。</p>
<p>GC周期1：使用mark0, 则周期结束所有引用mark标记都会成为01。</p>
<p>GC周期2：使用mark1, 则期待的mark标记10，所有引用都能被重新标记。</p>
<p>通过对配置ZGC后对象指针分析我们可知，对象指针必须是64位，那么ZGC就无法支持32位操作系统，同样的也就无法支持压缩指针了（CompressedOops，压缩指针也是32位）。</p>
<h3 id="颜色指针的三大优势："><a href="#颜色指针的三大优势：" class="headerlink" title="颜色指针的三大优势："></a><strong>颜色指针的三大优势：</strong></h3><ol>
<li>一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理，这使得理论上只要还有一个空闲Region，ZGC就能完成收集。</li>
<li>颜色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，ZGC只使用了读屏障。</li>
<li>颜色指针具备强大的扩展性，它可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li>
</ol>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a><strong>读屏障</strong></h2><p>之前的GC都是采用Write Barrier，这次ZGC采用了完全不同的方案读屏障，这个是ZGC一个非常重要的特性。</p>
<p>在标记和移动对象的阶段，每次「从堆里对象的引用类型中读取一个指针」的时候，都需要加上一个Load Barriers。</p>
<p>那么我们该如何理解它呢？看下面的代码，第一行代码我们尝试读取堆中的一个对象引用obj.fieldA并赋给引用o（fieldA也是一个对象时才会加上读屏障）。如果这时候对象在GC时被移动了，接下来JVM就会加上一个读屏障，这个屏障会把读出的指针更新到对象的新地址上，并且把堆里的这个指针“修正”到原本的字段里。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW。</p>
<p>那么，JVM是如何判断对象被移动过呢？就是利用上面提到的颜色指针，如果指针是Bad Color，那么程序还不能往下执行，需要「slow path」，修正指针；如果指针是Good Color，那么正常往下执行即可：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(17).png" alt="0"> 这个动作是不是非常像JDK并发中用到的CAS自旋？读取的值发现已经失效了，需要重新读取。而ZGC这里是之前持有的指针由于GC后失效了，需要通过读屏障修正指针。</p>
<p>后面3行代码都不需要加读屏障：Object p &#x3D; o这行代码并没有从堆中读取数据；o.doSomething()也没有从堆中读取数据；obj.fieldB不是对象引用，而是原子类型。</p>
<p>正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(18).png" alt="0"></p>
<p>那么，判断对象是Bad Color还是Good Color的依据是什么呢？就是根据上一段提到的Colored Pointers的4个颜色位。当加上读屏障时，根据对象指针中这4位的信息，就能知道当前对象是Bad&#x2F;Good Color了。</p>
<p><strong>PS：</strong>既然低42位指针可以支持4T内存，那么能否通过预约更多位给对象地址来达到支持更大内存的目的呢？答案肯定是不可以。因为目前主板地址总线最宽只有48bit，4位是颜色位，就只剩44位了，所以受限于目前的硬件，ZGC最大只能支持16T的内存，JDK13就把最大支持堆内存从4T扩大到了16T。</p>
<h2 id="ZGC存在的问题"><a href="#ZGC存在的问题" class="headerlink" title="ZGC存在的问题"></a><strong>ZGC存在的问题</strong></h2><p>ZGC最大的问题是<strong>浮动垃圾</strong>。ZGC的停顿时间是在10ms以下，但是ZGC的执行时间还是远远大于这个时间的。假如ZGC全过程需要执行10分钟，在这个期间由于对象分配速率很高，将创建大量的新对象，这些对象很难进入当次GC，所以只能在下次GC的时候进行回收，这些只能等到下次GC才能回收的对象就是浮动垃圾。</p>
<p>​                ZGC没有分代概念，每次都需要进行全堆扫描，导致一些“朝生夕死”的对象没能及时的被回收。              </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h3><p>目前唯一的办法是增大堆的容量，使得程序得到更多的喘息时间，但是这个也是一个治标不治本的方案。如果需要从根本上解决这个问题，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。</p>
<h2 id="ZGC参数设置"><a href="#ZGC参数设置" class="headerlink" title="ZGC参数设置"></a><strong>ZGC参数设置</strong></h2><p>启用ZGC比较简单，设置JVM参数即可：-XX:+UnlockExperimentalVMOptions 「-XX:+UseZGC」。调优也并不难，因为ZGC调优参数并不多，远不像CMS那么复杂。它和G1一样，可以调优的参数都比较少，大部分工作JVM能很好的自动完成。下图所示是ZGC可以调优的参数：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/640.png" alt="0"></p>
<h2 id="ZGC触发时机"><a href="#ZGC触发时机" class="headerlink" title="ZGC触发时机"></a><strong>ZGC触发时机</strong></h2><p>ZGC目前有4中机制触发GC：</p>
<ul>
<li>定时触发，默认为不使用，可通过ZCollectionInterval参数配置。</li>
<li>预热触发，最多三次，在堆内存达到10%、20%、30%时触发，主要时统计GC时间，为其他GC机制使用。</li>
<li>分配速率，基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</li>
<li>主动触发，（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</li>
</ul>
<h1 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a><strong>如何选择垃圾收集器</strong></h1><ol>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li>
<li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li><strong>4G以下可以用parallel，4-8G可以用ParNew+CMS，8G以上可以用G1，几百G以上用ZGC</strong></li>
</ol>
<p><strong>下图有连线的可以搭配使用</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(19).png" alt="0"></p>
<p><strong>JDK 1.8默认使用 Parallel(年轻代和老年代都是)</strong></p>
<p><strong>JDK 1.9默认使用 G1</strong>	</p>
<p><strong>安全点与安全区域</strong></p>
<p><strong>安全点</strong>就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。</p>
<p>这些特定的安全点位置主要有以下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>大体实现思想是当垃圾收集需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志位， 各个线程执行过程时会不停地主动去轮询这个标志， 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。 轮询标志的地方和安全点是重合的。</p>
<p><strong>安全区域又是什么？</strong></p>
<p>Safe Point 是对正在执行的线程设定的。</p>
<p>如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。</p>
<p>因此 JVM 引入了 Safe Region。</p>
<p>Safe Region 是指在一段代码片段中，<strong>引用关系不会发生变化</strong>。在这个区域内的任意地方开始 GC 都是安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">垃圾收集算法</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-23 20:23:51 / 修改时间：20:48:54" itemprop="dateCreated datePublished" datetime="2022-03-23T20:23:51+08:00">2022-03-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">垃圾收集算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a><strong>垃圾收集算法</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(7).png" alt="0"></p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a><strong>分代收集理论</strong></h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a><strong>标记-复制算法</strong></h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/96D6C205961C401FA08A222DD296F101.jpeg" alt="0"></p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h2><p>算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题  (如果需要标记的对象太多，效率不高)</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/9EA2822391964677B532FA20BA6C1CFE.jpeg" alt="0"></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h2><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/96BA7C6A2FE44EECBE32B64ADA05E03F.jpeg" alt="0"></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(8).png" alt="0"></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h2 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)"></a>Serial收集器(-XX:+UseSerialGC  -XX:+UseSerialOldGC)</h2><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/1C5BBB8EFDA34D30A04C67EB39C32E43.jpeg" alt="0"></p>
<p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p>
<p><strong>Serial Old收集器是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，<strong>另一种用途是作为CMS收集器的后备方案</strong>。</p>
<h2 id="Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</h2><p><strong>Parallel</strong>收集器其实<strong>就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/F4928A43F18645A8891088AC5A0BC9C6.jpeg" alt="0"></p>
<p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(<strong>JDK8默认的新生代和老年代收集器</strong>)。</p>
<h2 id="ParNew收集器-XX-UseParNewGC"><a href="#ParNew收集器-XX-UseParNewGC" class="headerlink" title="ParNew收集器(-XX:+UseParNewGC)"></a>ParNew收集器(-XX:+UseParNewGC)</h2><p>ParNew收集器其实<strong>跟Parallel收集器很类似</strong>，区别主要在于它可以和CMS收集器配合使用。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/4D6372782AD6472B8483A221172FB995.jpeg" alt="0"></p>
<p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<h2 id="CMS收集器-XX-UseConcMarkSweepGC-old"><a href="#CMS收集器-XX-UseConcMarkSweepGC-old" class="headerlink" title="CMS收集器(-XX:+UseConcMarkSweepGC(old))"></a>CMS收集器(-XX:+UseConcMarkSweepGC(old))</h2><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程(STW)，并记录下gc roots<strong>直接能引用的对象</strong>，<strong>速度很快</strong>。</li>
<li><strong>并发标记：</strong> 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，<strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的****增量更新算法(见下面详解)做重新标记。</strong></li>
<li><strong>并发清理：</strong> 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理(见下面三色标记算法详解)。</li>
<li><strong>并发重置：</strong>重置本次GC过程中的标记数据。</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/E22D67705EE44F509442E7CD3B705910.jpeg" alt="0"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>
<ul>
<li>对CPU资源敏感（会和服务抢资源）；</li>
<li>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li>
<li>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理</li>
<li>执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，<strong>特别是在并发标记和并发清理阶段会出现</strong>，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是”<strong>concurrent mode failure</strong>“，<strong>此时会进入stop the world，用serial old垃圾收集器来回收</strong></li>
</ul>
<h3 id="CMS的相关核心参数"><a href="#CMS的相关核心参数" class="headerlink" title="CMS的相关核心参数"></a><strong>CMS的相关核心参数</strong></h3><ol>
<li>-XX:+UseConcMarkSweepGC：启用cms </li>
<li>-XX:ConcGCThreads：并发的GC线程数</li>
<li>-XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</li>
<li>-XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一次  </li>
<li>-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是92，这是百分比）</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</li>
<li>-XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，降低CMS GC标记阶段**(<strong>也会对年轻代一起做标记，如果在minor gc就干掉了很多对垃圾对象，标记阶段就会减少一些标记时间</strong>)**时的开销，一般CMS的GC耗时 80%都在标记阶段</li>
<li>-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</li>
<li>-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</li>
</ol>
<h3 id="亿级流量电商系统如何优化JVM参数设置-ParNew-CMS"><a href="#亿级流量电商系统如何优化JVM参数设置-ParNew-CMS" class="headerlink" title="亿级流量电商系统如何优化JVM参数设置(ParNew+CMS)"></a><strong>亿级流量电商系统如何优化JVM参数设置(ParNew+CMS)</strong></h3><p>大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。</p>
<p>我们这里以比较核心的订单系统为例 </p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(9).png" alt="0"></p>
<p><strong>对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8            </span><br></pre></td></tr></table></figure>

<p>这样设置可能会由于<strong>动态对象年龄判断原则</strong>导致频繁full gc。</p>
<p>于是我们可以更新下JVM参数设置：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span><br></pre></td></tr></table></figure>



<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(10).png" alt="0"></p>
<p>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实<strong>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc</strong>。</p>
<p>对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。</p>
<p>对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的对象。</p>
<p>可以适当调整JVM参数如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span><br><span class="line">-XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M </span><br></pre></td></tr></table></figure>



<p>对于JDK8默认的垃圾回收器是-XX:+UseParallelGC(年轻代)和-XX:+UseParallelOldGC(老年代)，如果内存较大(超过4个G，只是经验值)，系统对停顿时间比较敏感，我们可以使用<strong>ParNew+CMS(</strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC**)**</p>
<p>对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。</p>
<p>无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其量也就几十MB。</p>
<p>还有就是某次minor gc完了之后还有超过一两百M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。</p>
<p>我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最高峰期，后续可能几小时才做一次FullGC。</p>
<p>对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理，或者两到三次之后再做一次也行。</p>
<p>综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=<span class="number">8</span> </span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">5</span> -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">92</span> -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<h1 id="垃圾收集底层算法实现"><a href="#垃圾收集底层算法实现" class="headerlink" title="垃圾收集底层算法实现"></a><strong>垃圾收集底层算法实现</strong></h1><hr>
<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a><strong>三色标记</strong></h2><p><strong>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</strong></p>
<p><strong>这里我们引入“三色标记”来给大家解释下，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</strong></p>
<ul>
<li><p><strong>黑色</strong>： 表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</p>
</li>
<li><p><strong>灰色</strong>： 表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</p>
</li>
<li><p><strong>白色</strong>： 表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</p>
</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(11).png" alt="0"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 垃圾收集算法细节之三色标记</span></span><br><span class="line"><span class="comment"> * 为了简化例子，代码写法可能不规范，请忽略</span></span><br><span class="line"><span class="comment"> * Created by 诸葛老师</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeColorRemark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">//开始做并发标记</span></span><br><span class="line">        <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> a.b.d;   <span class="comment">// 1.读</span></span><br><span class="line">        a.b.d = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">        a.d = d;       <span class="comment">// 3.写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="多标-浮动垃圾"><a href="#多标-浮动垃圾" class="headerlink" title="多标-浮动垃圾"></a><strong>多标-浮动垃圾</strong></h2><p>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gcroot引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</p>
<h2 id="漏标-读写屏障"><a href="#漏标-读写屏障" class="headerlink" title="漏标-读写屏障"></a><strong>漏标-读写屏障</strong></h2><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB） 。</strong></p>
<p><strong>增量更新</strong>就是当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， <strong>黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了</strong>。</p>
<p><strong>原始快照</strong>就是当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(<strong>目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</p>
<p>以上无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。 </p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a><strong>写屏障</strong></h3><p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<p>​                &#x2F;** * @param field 某对象的成员变量，如 a.b.d  * @param new_value 新值，如 null <em>&#x2F; void oop_field_store(oop</em> field, oop new_value) {     *field &#x3D; new_value; &#x2F;&#x2F; 赋值操作 }               </p>
<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>
<p>​                void oop_field_store(oop* field, oop new_value) {      pre_write_barrier(field);          &#x2F;&#x2F; 写屏障-写前操作    *field &#x3D; new_value;     post_write_barrier(field, value);  &#x2F;&#x2F; 写屏障-写后操作 }              </p>
<h3 id="写屏障实现SATB"><a href="#写屏障实现SATB" class="headerlink" title="写屏障实现SATB"></a><strong>写屏障实现SATB</strong></h3><p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d &#x3D; null），我们可以利用写屏障，将B<strong>原来成员变量的引用</strong>对象D记录下来：</p>
<p>​                void pre_write_barrier(oop* field) {    oop old_value &#x3D; *field;    &#x2F;&#x2F; 获取旧值    remark_set.add(old_value); &#x2F;&#x2F; 记录原来的引用对象 }              </p>
<h3 id="写屏障实现增量更新"><a href="#写屏障实现增量更新" class="headerlink" title="写屏障实现增量更新"></a><strong>写屏障实现增量更新</strong></h3><p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d &#x3D; d），我们可以利用写屏障，将A<strong>新的成员变量引用</strong>对象D记录下来：</p>
<p>​                void post_write_barrier(oop* field, oop new_value) {      remark_set.add(new_value);  &#x2F;&#x2F; 记录新引用的对象 }              </p>
<h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a><strong>读屏障</strong></h2><p>​                oop oop_field_load(oop* field) {    pre_load_barrier(field); &#x2F;&#x2F; 读屏障-读取前操作    return *field; }              </p>
<p>读屏障是直接针对第一步：D d &#x3D; a.b.d，当读取成员变量时，一律记录下来：</p>
<p>​                void pre_load_barrier(oop* field) {      oop old_value &#x3D; *field;    remark_set.add(old_value); &#x2F;&#x2F; 记录读取到的对象 }              </p>
<p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色&#x2F;黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈&#x2F;队列&#x2F;缓存日志等方式进行实现、遍历方式可以是广度&#x2F;深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li><strong>CMS：写屏障 + 增量更新</strong></li>
<li><strong>G1，Shenandoah：写屏障 + SATB</strong></li>
<li><strong>ZGC：读屏障</strong></li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代&#x2F;区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<p><strong>为什么G1用SATB？CMS用增量更新？</strong></p>
<p><strong>我的理解</strong>：SATB相对增量更新效率会高(当然SATB可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p>
<p><strong>记忆集与卡表</strong></p>
<p>在新生代做GCRoots可达性扫描过程中可能会碰到跨代引用的对象，这种如果又去对老年代再去扫描效率太低了。</p>
<p>为此，在新生代可以引入记录集（<strong>Remember Set</strong>）的数据结构（记录从非收集区到收集区的指针集合），避免把整个老年代加入GCRoots扫描范围。事实上并不只是新生代、 老年代之间才有跨代引用的问题， 所有涉及部分区域收集（Partial GC） 行为的垃圾收集器， 典型的如G1、 ZGC和Shenandoah收集器， 都会面临相同的问题。</p>
<p>垃圾收集场景中，收集器只需通过记忆集判断出某一块非收集区域是否存在指向收集区域的指针即可，无需了解跨代引用指针的全部细节。</p>
<p>hotspot使用一种叫做“卡表”(<strong>Cardtable</strong>)的方式实现记忆集，也是目前最常用的一种方式。关于卡表与记忆集的关系， 可以类比为Java语言中HashMap与Map的关系。</p>
<p>卡表是使用一个字节数组实现：CARD_TABLE[ ]，每个元素对应着其标识的内存区域一块特定大小的内存块，称为“卡页”。</p>
<p>hotSpot使用的卡页是2^9大小，即512字节</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/ac2f4c8a417f.png" alt="0"></p>
<p>一个卡页中可包含多个对象，只要有一个对象的字段存在跨代指针，其对应的卡表的元素标识就变成1，表示该元素变脏，否则为0.</p>
<p>GC时，只要筛选本收集区的卡表中变脏的元素加入GCRoots里。</p>
<p><strong>卡表的维护</strong></p>
<p>卡表变脏上面已经说了，但是需要知道如何让卡表变脏，即发生引用字段赋值时，如何更新卡表对应的标识为1。</p>
<p>Hotspot使用<strong>写屏障</strong>维护卡表状态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/22/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/JVM%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM创建对象&内存分配机制</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-22 22:21:35 / 修改时间：22:35:36" itemprop="dateCreated datePublished" datetime="2022-03-22T22:21:35+08:00">2022-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a><strong>对象的创建</strong></h1><p>对象创建的主要流程:</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(3).png" alt="0"></p>
<h2 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a><strong>类加载检查</strong></h2><p> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p> new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a><strong>分配内存</strong></h2><p> 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p>
<p>这个步骤有两个问题：</p>
<p>1.如何划分内存。</p>
<p>2.在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p><strong>划分内存的方法：</strong></p>
<ul>
<li>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)</li>
</ul>
<p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<ul>
<li>“空闲列表”（Free List）</li>
</ul>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</p>
<p><strong>解决并发问题的方法：</strong></p>
<ul>
<li>CAS（compare and swap）</li>
</ul>
<p>虚拟机采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p>
<ul>
<li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</li>
</ul>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过**-XX:+&#x2F;-*<em><strong>UseTLAB</strong>参数来设定虚拟机是否使用TLAB(JVM会默认开启</em>*-XX:+**<strong>UseTLAB</strong>)，-XX:TLABSize 指定TLAB大小。</p>
<h2 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a><strong>初始化零值</strong></h2><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a><strong>设置对象头</strong></h2><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。</p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>32位对象头</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(4).png" alt="0"></p>
<p><strong>64位对象头</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(5).png" alt="0"></p>
<p>对象头在hotspot的C++源码markOop.hpp文件里的注释如下：</p>
<figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>

<p>​          </p>
<h2 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a><strong>执行方法</strong></h2><p> 执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p>
<p><strong>对象大小与指针压缩</strong></p>
<p>对象大小可以用jol-core包查看，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算对象大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLayout</span> <span class="variable">layout</span> <span class="operator">=</span> ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">ClassLayout</span> <span class="variable">layout1</span> <span class="operator">=</span> ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;);</span><br><span class="line">        System.out.println(layout1.toPrintable());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">ClassLayout</span> <span class="variable">layout2</span> <span class="operator">=</span> ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">        System.out.println(layout2.toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedOops           默认开启的压缩所有指针</span></span><br><span class="line">    <span class="comment">// -XX:+UseCompressedClassPointers  默认开启的压缩对象头里的类型指针Klass Pointer</span></span><br><span class="line">    <span class="comment">// Oops : Ordinary Object Pointers</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">                       <span class="comment">//8B mark word</span></span><br><span class="line">                       <span class="comment">//4B Klass Pointer   如果关闭压缩-XX:-UseCompressedClassPointers或-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="type">int</span> id;        <span class="comment">//4B</span></span><br><span class="line">        String name;   <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">        <span class="type">byte</span> b;        <span class="comment">//1B </span></span><br><span class="line">        Object o;      <span class="comment">//4B  如果关闭压缩-XX:-UseCompressedOops，则占用8B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)    <span class="comment">//mark word</span></span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)    <span class="comment">//mark word     </span></span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           e5 <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217243</span>)    <span class="comment">//Klass Pointer</span></span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">4</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[I object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)                           <span class="number">6d</span> <span class="number">01</span> <span class="number">00</span> f8 (<span class="number">01101101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134217363</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>    <span class="type">int</span> [I.&lt;elements&gt;                             N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">com.tuling.jvm.JOLSample$A object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">61</span> cc <span class="number">00</span> f8 (<span class="number">01100001</span> <span class="number">11001100</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134165407</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>                <span class="type">int</span> A.id                                      <span class="number">0</span></span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>               <span class="type">byte</span> A.b                                       <span class="number">0</span></span><br><span class="line">     <span class="number">17</span>     <span class="number">3</span>                    (alignment/padding gap)                  </span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>   java.lang.String A.name                                    <span class="literal">null</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">4</span>   java.lang.Object A.o                                       <span class="literal">null</span></span><br><span class="line">     <span class="number">28</span>     <span class="number">4</span>                    (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">4</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">7</span> bytes total</span><br></pre></td></tr></table></figure>



<p>什么是java对象的<strong>指针压缩</strong>？</p>
<p>1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</p>
<p>2.jvm配置参数:UseCompressedOops，compressed–压缩、oop(ordinary object pointer)–对象指针</p>
<p>3.启用指针压缩:-XX:+UseCompressedOops(<strong>默认开启</strong>)，禁止指针压缩:-XX:-UseCompressedOops</p>
<p>为什么要进行指针压缩？</p>
<p>1.在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，<strong>占用较大宽带，同时GC也会承受较大压力</strong></p>
<p>2.为了减少64位平台下内存的消耗，启用指针压缩功能</p>
<p>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入<strong>堆内存</strong>时压缩编码、取出到<strong>cpu寄存器</strong>后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</p>
<p>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p>
<p>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p>
<p><strong>关于对齐填充：</strong>对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式。</p>
<p><strong>对象内存分配</strong></p>
<p><strong>对象内存分配流程图</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/327202027172.png" alt="0"></p>
<p><strong>对象栈上分配</strong></p>
<p>我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   user.setId(<span class="number">1</span>);</span><br><span class="line">   user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">   <span class="comment">//TODO 保存到数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​             </p>
<p>很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。</p>
<p>JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)，<strong>JDK7之后默认开启逃逸分析</strong>，如果要关闭使用参数(-XX:-DoEscapeAnalysis)</p>
<p><strong>标量替换：</strong>通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，<strong>JDK7之后默认开启</strong>。</p>
<p><strong>标量与聚合量：</strong>标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<p><strong>栈上分配示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配，标量替换</span></span><br><span class="line"><span class="comment"> * 代码调用了1亿次alloc()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用如下参数不会发生GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * 使用如下参数都会发生大量GC</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllotOnStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;zhuge&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p><strong>结论：栈上分配依赖于逃逸分析和标量替换</strong></p>
<h1 id="对象在Eden区分配"><a href="#对象在Eden区分配" class="headerlink" title="对象在Eden区分配"></a><strong>对象在Eden区分配</strong></h1><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p>
<p>在测试之前我们先来看看 <strong>Minor GC和Full GC 有什么不同呢？</strong></p>
<ul>
<li><strong>Minor GC&#x2F;Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>Major GC&#x2F;Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<p><strong>Eden与Survivor区默认8:1:1</strong></p>
<p>大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong></p>
<p>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//allocation2 = new byte[8000*1024];</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">     allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 65536K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000770900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">100</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fe80000</span>,<span class="number">0x000000076fe80000</span>,<span class="number">0x0000000770900000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f400000</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 0K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p>我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。<strong>假如我们再为allocation2分配内存会出现什么情况呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加运行JVM参数： -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">byte</span>[] allocation1, allocation2<span class="comment">/*, allocation3, allocation4, allocation5, allocation6*/</span>;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*allocation3 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation4 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation5 = new byte[1000*1024];</span></span><br><span class="line"><span class="comment">      allocation6 = new byte[1000*1024];*/</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;936K(76288K)] 65253K-&gt;60944K(251392K), <span class="number">0.0279083</span> secs] [Times: user=<span class="number">0.13</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 9591K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">13</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076bc73ef8</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ea020</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3342K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的对象<strong>提前转移到老年代</strong>中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。可以执行如下代码验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6;</span><br><span class="line">      allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">60000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8000</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">      allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">      allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">     allocation6 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 65253K-&gt;952K(76288K)] 65253K-&gt;60960K(251392K), <span class="number">0.0311467</span> secs] [Times: user=<span class="number">0.08</span> sys=<span class="number">0.02</span>, real=<span class="number">0.03</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 13878K [<span class="number">0x000000076b400000</span>, <span class="number">0x0000000774900000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">19</span>% used [<span class="number">0x000000076b400000</span>,<span class="number">0x000000076c09fb68</span>,<span class="number">0x000000076f400000</span>)</span><br><span class="line">  from space 10752K, <span class="number">8</span>% used [<span class="number">0x000000076f400000</span>,<span class="number">0x000000076f4ee030</span>,<span class="number">0x000000076fe80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000773e80000</span>,<span class="number">0x0000000774900000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 60008K [<span class="number">0x00000006c1c00000</span>, <span class="number">0x00000006cc700000</span>, <span class="number">0x000000076b400000</span>)</span><br><span class="line">  object space 175104K, <span class="number">34</span>% used [<span class="number">0x00000006c1c00000</span>,<span class="number">0x00000006c569a010</span>,<span class="number">0x00000006cc700000</span>)</span><br><span class="line"> Metaspace       used 3343K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><strong>大对象直接进入老年代</strong></h1><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p>
<p>比如设置JVM参数：-XX:PretenureSizeThreshold&#x3D;1000000 (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时的复制操作而降低效率。</p>
<h1 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a><strong>长期存活的对象将进入老年代</strong></h1><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<h1 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a><strong>对象动态年龄判断</strong></h1><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以<strong>直接进入老年代</strong>了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong></p>
<h1 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a><strong>老年代空间分配担保机制</strong></h1><p>年轻代每次<strong>minor gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong></p>
<p>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong>)</p>
<p>就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了</p>
<p>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的<strong>平均大小</strong>。</p>
<p>如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”</p>
<p>当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(6).png" alt="0"></p>
<p><strong>对象内存回收</strong></p>
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><strong>引用计数法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">      <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">      objA.instance = objB;</span><br><span class="line">      objB.instance = objA;</span><br><span class="line">      objA = <span class="literal">null</span>;</span><br><span class="line">      objB = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p><strong>可达性分析算法</strong></p>
<p>将<strong>“GC Roots”</strong> 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象</p>
<p><strong>GC Roots</strong>根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/6E72848C54E84BB7A76F0FF89ED5010D.jpeg" alt="0"></p>
<p><strong>常见引用类型</strong></p>
<p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<p><strong>强引用</strong>：普通的变量引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p><strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p>
<p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p>
<p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p>
<p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());   </span><br></pre></td></tr></table></figure>

<p>​       </p>
<p><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>
<h1 id="finalize-方法最终判定对象是否存活"><a href="#finalize-方法最终判定对象是否存活" class="headerlink" title="finalize()方法最终判定对象是否存活"></a><strong>finalize()方法最终判定对象是否存活</strong></h1><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p>
<p><strong>1. 第一次标记并进行一次筛选。</strong></p>
<p>筛选的条件是此对象是否有必要执行finalize()方法。</p>
<p>当对象没有覆盖finalize方法，对象将直接被回收。</p>
<p><strong>2. 第二次标记</strong></p>
<p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         list.add(<span class="keyword">new</span> <span class="title class_">User</span>(i++, UUID.randomUUID().toString()));</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">User</span>(j--, UUID.randomUUID().toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//User类需要重写finalize方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    OOMTest.list.add(<span class="built_in">this</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;关闭资源，userid=&quot;</span> + id + <span class="string">&quot;即将被回收&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p>finalize()方法的运行代价高昂， 不确定性大， 无法保证各个对象的调用顺序， 如今已被官方明确声明为不推荐使用的语法。 有些资料描述它适合做“关闭外部资源”之类的清理性工作， 这完全是对finalize()方法用途的一种自我安慰。 finalize()能做的所有工作， 使用try-finally或者其他方式都可以做得更好、更及时， 所以建议大家完全可以忘掉Java语言里面的这个方法。</p>
<h1 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><strong>如何判断一个类是无用的类</strong></h1><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？</p>
<p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/22/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JVM内存模型</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-22 22:03:51 / 修改时间：22:09:44" itemprop="dateCreated datePublished" datetime="2022-03-22T22:03:51+08:00">2022-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a><strong>JDK体系结构</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard.png" alt="0"></p>
<h1 id="Java语言的跨平台特性"><a href="#Java语言的跨平台特性" class="headerlink" title="Java语言的跨平台特性"></a><strong>Java语言的跨平台特性</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(1).png" alt="0"></p>
<h1 id="JVM整体结构及内存模型"><a href="#JVM整体结构及内存模型" class="headerlink" title="JVM整体结构及内存模型"></a><strong>JVM整体结构及内存模型</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="0"></p>
<p><strong>补充一个问题：</strong></p>
<p><strong>在minor gc过程中对象挪动后，引用如何修改？</strong></p>
<p>对象在堆内部挪动的过程其实是复制，原有区域对象还在，一般不直接清理，JVM内部清理过程只是将对象分配指针移动到区域的头位置即可，比如扫描s0区域，扫到gcroot引用的非垃圾对象是将这些对象<strong>复制</strong>到s1或老年代，最后扫描完了将s0区域的对象分配指针移动到区域的起始位置即可，s0区域之前对象并不直接清理，当有新对象分配了，原有区域里的对象也就被清除了。</p>
<p>minor gc在根扫描过程中会记录所有被扫描到的对象引用(在年轻代这些引用很少，因为大部分都是垃圾对象不会扫描到)，如果引用的对象被复制到新地址了，最后会一并更新引用指向新地址。</p>
<p>这里面内部算法比较复杂，感兴趣可以参考R大的这篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/42181722/answer/145085437">https://www.zhihu.com/question/42181722/answer/145085437</a></p>
<p><a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/39376#post-257329">https://hllvm-group.iteye.com/group/topic/39376#post-257329</a></p>
<h1 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a><strong>JVM内存参数设置</strong></h1><hr>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/clipboard%20(2).png" alt="0"></p>
<p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar</span><br><span class="line">-Xss：每个线程的栈大小</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p>-Xss：每个线程的栈大小</p>
<p>-Xms：设置堆的初始可用大小，默认物理内存的1&#x2F;64 </p>
<p>-Xmx：设置堆的最大可用大小，默认物理内存的1&#x2F;4</p>
<p>-Xmn：新生代大小</p>
<p>-XX:NewRatio：默认2表示新生代占年老代的1&#x2F;2，占整个堆内存的1&#x2F;3。</p>
<p>-XX:SurvivorRatio：默认8表示一个survivor区占用1&#x2F;8的Eden内存，即1&#x2F;10的新生代内存。</p>
<p>关于元空间的JVM参数有两个：-XX:MetaspaceSize&#x3D;N和 -XX:MaxMetaspaceSize&#x3D;N</p>
<p><strong>-XX：MaxMetaspaceSize</strong>： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。</p>
<p><strong>-XX：MetaspaceSize</strong>： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，-<strong>XX:PermSize</strong>代表永久代的初始容量。</p>
<p>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p>
<p><strong>StackOverflowError</strong>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM设置  -Xss128k(默认1M)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">redo</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        redo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redo();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">12</span>)</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">13</span>)</span><br><span class="line">	at com.tuling.jvm.StackOverflowTest.redo(StackOverflowTest.java:<span class="number">13</span>)</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p><strong>结论：</strong></p>
<p>-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p>
<p><strong>JVM内存参数大小该如何设置？</strong></p>
<p>JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子</p>
<p><strong>日均百万级订单交易系统如何设置JVM参数</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9FJVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96.png" alt="0"></p>
<p><strong>结论：通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</strong>        </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/21/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM类加载机制</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 22:50:38" itemprop="dateCreated datePublished" datetime="2022-03-21T22:50:38+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-22 22:50:19" itemprop="dateModified" datetime="2022-03-22T22:50:19+08:00">2022-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类加载运行全过程"><a href="#类加载运行全过程" class="headerlink" title="类加载运行全过程"></a>类加载运行全过程</h1><p>当我们用java命令运行某个类的main函数启动程序时，首先需要通过类加载器把主类加载到 JVM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">initData</span> <span class="operator">=</span> <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;  <span class="comment">//一个方法对应一块栈帧内存区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Math</span> <span class="variable">math</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Math</span>();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>通过Java命令执行代码的大体流程如下:</strong></p>
<p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/uTools_1647875093855.png" alt="image-20220321225948272"></p>
<p>其中loadClass的类加载过程有如下几步:<br> <strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt; 使用 &gt;&gt; 卸载</strong></p>
<ul>
<li><p>加载:在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
<li><p>验证:校验字节码文件的正确性 </p>
</li>
<li><p>准备:给类的静态变量分配内存，并赋予默认值 </p>
</li>
<li><p>解析:将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过 程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用</p>
</li>
<li><p>初始化:对类的静态变量初始化为指定的值，执行静态代码块</p>
</li>
</ul>
<p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/uTools_1647875284272.png" alt="0"></p>
<p>类被加载到方法区中后主要包含 运行时常量池、类型信息、字段信息、方法信息、类加载器的 引用、对应class实例的引用等信息。<br> 类加载器的引用:这个类到类加载器实例的引用 对应class实例的引用:类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的 对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p>
<p>注意，主类在运行过程中如果使用到其它类，会逐步加载这些类。 jar包或war包里的类不是一次性全部加载的，是使用到时才加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDynamicLoad</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load TestDynamicLoad************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load test************&quot;</span>);</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//B不会加载，除非这里执行 new B()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial A************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************load B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*************initial B************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">*************load TestDynamicLoad************</span><br><span class="line">*************load A************</span><br><span class="line">*************initial A************</span><br><span class="line">*************load test************</span><br></pre></td></tr></table></figure>



<h1 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h1><p>上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</p>
<ul>
<li><p>引导类加载器:负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等</p>
</li>
<li><p>扩展类加载器:负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 类包</p>
</li>
<li><p>应用程序类加载器:负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</p>
</li>
<li><p>自定义加载器:负责加载用户自定义路径下的类包</p>
</li>
</ul>
<p>看一个类加载器示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDKClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(String.class.getClassLoader());</span><br><span class="line">        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());</span><br><span class="line">        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassloader</span> <span class="operator">=</span> appClassLoader.getParent();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapLoader</span> <span class="operator">=</span> extClassloader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the extClassloader : &quot;</span> + extClassloader);</span><br><span class="line">        System.out.println(<span class="string">&quot;the appClassLoader : &quot;</span> + appClassLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrapLoader加载以下文件：&quot;</span>);</span><br><span class="line">        URL[] urls = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            System.out.println(urls[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;extClassloader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;appClassLoader加载以下文件：&quot;</span>);</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader</span><br><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">the bootstrapLoader : <span class="literal">null</span></span><br><span class="line">the extClassloader : sun.misc.Launcher$ExtClassLoader@<span class="number">3764951d</span></span><br><span class="line">the appClassLoader : sun.misc.Launcher$AppClassLoader@14dad5dc</span><br><span class="line"></span><br><span class="line">bootstrapLoader加载以下文件：</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/resources.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/rt.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jsse.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jce.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/charsets.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/lib/jfr.jar</span><br><span class="line">file:/D:/dev/Java/jdk1<span class="number">.8</span><span class="number">.0_45</span>/jre/classes</span><br><span class="line"></span><br><span class="line">extClassloader加载以下文件：</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br><span class="line"></span><br><span class="line">appClassLoader加载以下文件：</span><br><span class="line">D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\charsets.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\deploy.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\cldrdata.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\dnsns.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jaccess.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\jfxrt.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\localedata.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\nashorn.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunec.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunjce_provider.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunmscapi.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\sunpkcs11.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\ext\zipfs.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\javaws.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jce.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jfr.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jfxswt.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\jsse.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\management-agent.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\plugin.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\resources.jar;D:\dev\Java\jdk1<span class="number">.8</span><span class="number">.0_45</span>\jre\lib\rt.jar;D:\ideaProjects\project-all\target\classes;C:\Users\zhuge\.m2\repository\org\apache\zookeeper\zookeeper\<span class="number">3.4</span><span class="number">.12</span>\zookeeper-<span class="number">3.4</span><span class="number">.12</span>.jar;C:\Users\zhuge\.m2\repository\org\slf4j\slf4j-api\<span class="number">1.7</span><span class="number">.25</span>\slf4j-api-<span class="number">1.7</span><span class="number">.25</span>.jar;C:\Users\zhuge\.m2\repository\org\slf4j\slf4j-log4j12\<span class="number">1.7</span><span class="number">.25</span>\slf4j-log4j12-<span class="number">1.7</span><span class="number">.25</span>.jar;C:\Users\zhuge\.m2\repository\log4j\log4j\<span class="number">1.2</span><span class="number">.17</span>\log4j-<span class="number">1.2</span><span class="number">.17</span>.jar;C:\Users\zhuge\.m2\repository\jline\jline\<span class="number">0.9</span><span class="number">.94</span>\jline-<span class="number">0.9</span><span class="number">.94</span>.jar;C:\Users\zhuge\.m2\repository\org\apache\yetus\audience-annotations\<span class="number">0.5</span><span class="number">.0</span>\audience-annotations-<span class="number">0.5</span><span class="number">.0</span>.jar;C:\Users\zhuge\.m2\repository\io\netty\netty\<span class="number">3.10</span><span class="number">.6</span>.Final\netty-<span class="number">3.10</span><span class="number">.6</span>.Final.jar;C:\Users\zhuge\.m2\repository\com\google\guava\guava\<span class="number">22.0</span>\guava-<span class="number">22.0</span>.jar;C:\Users\zhuge\.m2\repository\com\google\code\findbugs\jsr305\<span class="number">1.3</span><span class="number">.9</span>\jsr305-<span class="number">1.3</span><span class="number">.9</span>.jar;C:\Users\zhuge\.m2\repository\com\google\errorprone\error_prone_annotations\<span class="number">2.0</span><span class="number">.18</span>\error_prone_annotations-<span class="number">2.0</span><span class="number">.18</span>.jar;C:\Users\zhuge\.m2\repository\com\google\j2objc\j2objc-annotations\<span class="number">1.1</span>\j2objc-annotations-<span class="number">1.1</span>.jar;C:\Users\zhuge\.m2\repository\org\codehaus\mojo\animal-sniffer-annotations\<span class="number">1.14</span>\animal-sniffer-annotations-<span class="number">1.14</span>.jar;D:\dev\IntelliJ IDEA <span class="number">2018.3</span><span class="number">.2</span>\lib\idea_rt.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="类加载器初始化过程"><a href="#类加载器初始化过程" class="headerlink" title="类加载器初始化过程:"></a>类加载器初始化过程:</h1><p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。 sun.misc.Launcher初始化使用了单例模式设计，保证一个JVM虚拟机内只有一个 sun.misc.Launcher实例。<br> 在Launcher构造方法内部，其创建了两个类加载器，分别是 sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应 用类加载器)。 JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们 的应用程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Launcher的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造扩展类加载器，在构造的过程中将其父加载器设置为null</span></span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span></span><br><span class="line">        <span class="comment">//Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span></span><br><span class="line">        <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br><span class="line">    <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">    。。。 。。。 <span class="comment">//省略一些不需关注代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>JVM类加载器是有亲子层级结构的，如下图</p>
<p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/uTools_1647876318692.png" alt="0"></p>
<p>这里类加载其实就有一个双亲委派机制，加载某个类时会先委托父加载器寻找目标类，找不到再 委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的 类加载路径中查找并载入目标类。 比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载 器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天 没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的 类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器， 应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。。 </p>
<p>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</p>
<p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader 的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下:</p>
<ol>
<li><p>首先，检查一下指定名称的类是否已经加载过,如果加载过了,就不需要再加载,直接返回。</p>
</li>
<li><p>如果此类没有加载过，那么，再判断一下是否有父加载器;如果有父加载器，则由父加载器加载(即调用parent.loadClass(name, false);).或者是调用bootstrap类加载器来加载。</p>
</li>
<li><p>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的 findClass方法来完成类加载。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;  <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;  <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="为什么要设计双亲委派机制"><a href="#为什么要设计双亲委派机制" class="headerlink" title="为什么要设计双亲委派机制?"></a>为什么要设计双亲委派机制?</h1><ul>
<li>沙箱安全机制:自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改 </li>
<li>避免类的重复加载:当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li>
</ul>
<p>看一个类加载示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>

<h1 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h1><p>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类 所依赖及引用的类也由这个ClassLoder载入。</p>
<h1 id="自定义类加载器示例"><a href="#自定义类加载器示例" class="headerlink" title="自定义类加载器示例:"></a>自定义类加载器示例:</h1><p> 自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//D盘创建 test/com/tuling/jvm 几级目录，将User类的复制类User1.class丢入该目录</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader</span><br></pre></td></tr></table></figure>



<h1 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h1><p>再来一个沙箱安全机制示例，尝试打破双亲委派机制，用自定义类加载器加载我们自己实现的 java.lang.String.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="comment">//尝试用自己改写类加载机制去加载自己写的java.lang.String.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader().getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">659</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">758</span>)</span><br></pre></td></tr></table></figure>



<h1 id="Tomcat打破双亲委派机制"><a href="#Tomcat打破双亲委派机制" class="headerlink" title="Tomcat打破双亲委派机制"></a>Tomcat打破双亲委派机制</h1><p> 以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行? 我们思考一下:Tomcat是个web容器， 那么它要解决什么问题:</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的 不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。</li>
<li>web容器也有自己依赖的类库，不能与应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</li>
<li>web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</li>
</ol>
<p>再看看我们的问题:Tomcat 如果使用默认的双亲委派类加载机制行不行? 答案是不行的。为什么? </p>
<p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认 的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 </p>
<p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。</p>
<p>第三个问题和第一个问题一样。 </p>
<p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文 件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp 是不会重新加载的。那么怎么办呢?我们可以直接卸载掉这jsp文件的类加载器，所以你应该想 到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载 器。重新创建类加载器，重新加载jsp文件。</p>
<h1 id="Tomcat自定义加载器详解"><a href="#Tomcat自定义加载器详解" class="headerlink" title="Tomcat自定义加载器详解"></a>Tomcat自定义加载器详解</h1><p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/1647878869567.png" alt="image-20220322000814246"></p>
<p>tomcat的几个主要类加载器: </p>
<ul>
<li>commonLoader:Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问;</li>
<li>catalinaLoader:Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见; </li>
<li>sharedLoader:各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见;</li>
<li>WebappClassLoader:各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本， 这样实现就能加载各自的spring版本;</li>
</ul>
<p>从图中的委派关系中可以看出: </p>
<p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用， 从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则 与对方相互隔离。 </p>
<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader 实例之间相互隔离。 </p>
<p>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的 就是为了被丢弃:当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例， 并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p>
<p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗?答案是:违背了。 很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个 webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制。</p>
<p>模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name</span><br><span class="line">                    + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">            fis.read(data);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] data = loadByte(name);</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//非自定义的类还是走双亲委派加载</span></span><br><span class="line">                    <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;com.tuling.jvm&quot;</span>))&#123;</span><br><span class="line">                        c = <span class="built_in">this</span>.getParent().loadClass(name);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        c = findClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                    resolveClass(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        Method method= clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;D:/test1&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> classLoader1.loadClass(<span class="string">&quot;com.tuling.jvm.User1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> clazz1.newInstance();</span><br><span class="line">        Method method1= clazz1.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method1.invoke(obj1, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(clazz1.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">=======自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@266474c2</span><br><span class="line"></span><br><span class="line">=======另外一个User1版本：自己的加载器加载类调用方法=======</span><br><span class="line">com.tuling.jvm.MyClassLoaderTest$MyClassLoader@66d3c617</span><br></pre></td></tr></table></figure>

<p>注意:同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一 样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类 加载器也是同一个才能认为他们是同一个。</p>
<p>附下User类的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======自己的加载器加载类调用方法=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：Hotspot源码JVM启动执行main方法流程</strong></p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JVM/Hotspot%E6%BA%90%E7%A0%81JVM%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8Cmain%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B.jpg" alt="0"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/20/%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6-Disruptor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6-Disruptor/" class="post-title-link" itemprop="url">无锁并发框架-Disruptor</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-20 17:58:36 / 修改时间：18:05:34" itemprop="dateCreated datePublished" datetime="2022-03-20T17:58:36+08:00">2022-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识Disruptor"><a href="#认识Disruptor" class="headerlink" title="认识Disruptor"></a><strong>认识Disruptor</strong></h2><p>Disruptor是一个开源框架，研发的初衷是为了解决高并发下列队锁的问题，最早由LMAX（一种新型零售金融交易平台）提出并使用，能够在无锁的情况下实现队列的并发操作，并号称能够在一个线程里每秒处理6百万笔订单(这个真假就不清楚了！牛皮谁都会吹)。</p>
<p>框架最经典也是最多的应用场景：生产消费。</p>
<p>讲到生产消费模型，大家应该马上就能回忆起前面我们已经学习过的BlockingQueue课程，里面我们学习过多种队列，但是这些队列大多是基于条件阻塞方式的，性能还不够优秀！</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue：基于数组形式的队列，通过加锁的方式，来保证多线程情况下数据的安全；</span><br><span class="line">LinkedBlockingQueue：基于链表形式的队列，也通过加锁的方式，来保证多线程情况下数据的安全；</span><br><span class="line">ConcurrentLinkedQueue：基于链表形式的队列，通过compare and swap(简称CAS)协议的方式，</span><br><span class="line">来保证多线程情况下数据的安全，不加锁，主要使用了Java中的sun.misc.Unsafe类来实现；</span><br></pre></td></tr></table></figure>

<p>​           </p>
<h2 id="核心设计原理"><a href="#核心设计原理" class="headerlink" title="核心设计原理"></a><strong>核心设计原理</strong></h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li>环形数组结构：</li>
</ul>
<blockquote>
<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
</blockquote>
<ul>
<li>元素位置定位：</li>
</ul>
<blockquote>
<p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
</blockquote>
<ul>
<li>无锁设计：</li>
</ul>
<blockquote>
<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><p>框架使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。原理图如下所示：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(63).png" alt="0"></p>
<h3 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a><strong>Sequence</strong></h3><p>mark：Disruptor通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。</p>
<h3 id="数组-序列号设计的优势是什么呢？"><a href="#数组-序列号设计的优势是什么呢？" class="headerlink" title="数组+序列号设计的优势是什么呢？"></a><strong>数组+序列号设计的优势是什么呢？</strong></h3><p>回顾一下我们讲HashMap时，在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，index&#x3D;sequence % table.length。当然也可以用位运算来计算效率更高，此时table.length必须是2的幂次方(原理前面讲过)。</p>
<h4 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a><strong>概念与作用</strong></h4><ul>
<li>RingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；</li>
<li>Sequencer——序号管理器，生产同步的实现者，负责消费者&#x2F;生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；</li>
<li>Sequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；</li>
<li>SequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理， Sequence Barrier是由Sequencer创建的,并被Processor持有；</li>
<li>EventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。</li>
<li>EventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。</li>
<li>Producer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。</li>
<li>Wait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(64).png" alt="0"></p>
<h4 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a><strong>等待策略</strong></h4><h5 id="BlockingWaitStrategy"><a href="#BlockingWaitStrategy" class="headerlink" title="BlockingWaitStrategy"></a><strong>BlockingWaitStrategy</strong></h5><p>Disruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。</p>
<h5 id="SleepingWaitStrategy"><a href="#SleepingWaitStrategy" class="headerlink" title="SleepingWaitStrategy"></a><strong>SleepingWaitStrategy</strong></h5><p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用LockSupport.parkNanos(1)来实现循环等待。一般来说Linux系统会暂停一个线程约60µs，这样做的好处是，生产线程不需要采取任何其他行动就可以增加适当的计数器，也不需要花费时间信号通知条件变量。但是，在生产者线程和使用者线程之间移动事件的平均延迟会更高。它在不需要低延迟并且对生产线程的影响较小的情况最好。一个常见的用例是异步日志记录。</p>
<h5 id="YieldingWaitStrategy"><a href="#YieldingWaitStrategy" class="headerlink" title="YieldingWaitStrategy"></a><strong>YieldingWaitStrategy</strong></h5><p>YieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用Thread.yield（），以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>
<h5 id="BusySpinWaitStrategy"><a href="#BusySpinWaitStrategy" class="headerlink" title="BusySpinWaitStrategy"></a><strong>BusySpinWaitStrategy</strong></h5><p>性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>
<h5 id="PhasedBackoffWaitStrategy"><a href="#PhasedBackoffWaitStrategy" class="headerlink" title="PhasedBackoffWaitStrategy"></a><strong>PhasedBackoffWaitStrategy</strong></h5><p>自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。</p>
<h4 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a><strong>写数据</strong></h4><p>单线程写数据的流程：</p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>
<li>若是返回的正确，则生产者开始写入元素。</li>
</ol>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(65).png" alt="0"></p>
<p><strong>框架的使用</strong></p>
<p><strong>生产消费模型的应用</strong></p>
<p><strong>1、引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<p><strong>2、定义Event</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义事件event  通过Disruptor 进行交换的数据类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Long value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3、定义EventFactory</strong></p>
<p>我们需要Disruptor为我们创建Event，所以这里我们需要定义事件工厂，实现框架定义的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventFactory</span> <span class="keyword">implements</span> <span class="title class_">EventFactory</span>&lt;LongEvent&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> LongEvent <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LongEvent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p><strong>4、定义事件消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;LongEvent&gt;  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LongEvent event, <span class="type">long</span> sequence, <span class="type">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;消费者:&quot;</span>+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>5、定义生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(ByteBuffer byteBuffer)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.ringBuffer 事件队列 下一个槽</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> ringBuffer.next();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.取出空的事件队列</span></span><br><span class="line">            <span class="type">LongEvent</span> <span class="variable">longEvent</span> <span class="operator">=</span> ringBuffer.get(sequence);</span><br><span class="line">            data = byteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//3.获取事件队列传递的数据</span></span><br><span class="line">            longEvent.setValue(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产这准备发送数据&quot;</span>);</span><br><span class="line">            <span class="comment">//4.发布事件</span></span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p><strong>6、定义Main入口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisruptorMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 2.创建工厂</span></span><br><span class="line">        EventFactory&lt;LongEvent&gt; eventFactory = <span class="keyword">new</span> <span class="title class_">LongEventFactory</span>();</span><br><span class="line">        <span class="comment">// 3.创建ringBuffer 大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ringBufferSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// ringBufferSize大小一定要是2的N次方</span></span><br><span class="line">        <span class="comment">// 4.创建Disruptor</span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,</span><br><span class="line">                ProducerType.SINGLE, <span class="keyword">new</span> <span class="title class_">YieldingWaitStrategy</span>());</span><br><span class="line">        <span class="comment">// 5.连接消费端方法</span></span><br><span class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler</span>());</span><br><span class="line">        <span class="comment">// 6.启动</span></span><br><span class="line">        disruptor.start();</span><br><span class="line">        <span class="comment">// 7.创建RingBuffer容器</span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        <span class="comment">// 8.创建生产者</span></span><br><span class="line">        <span class="type">LongEventProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventProducer</span>(ringBuffer);</span><br><span class="line">        <span class="comment">// 9.指定缓冲区大小</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            byteBuffer.putLong(<span class="number">0</span>, i);</span><br><span class="line">            producer.onData(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//10.关闭disruptor和executor</span></span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://cailiang.website/2022/03/20/future-forkjoin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/20/future-forkjoin/" class="post-title-link" itemprop="url">Future&ForkJoin</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-20 17:45:47 / 修改时间：17:57:11" itemprop="dateCreated datePublished" datetime="2022-03-20T17:45:47+08:00">2022-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="任务性质类型"><a href="#任务性质类型" class="headerlink" title="任务性质类型"></a><strong>任务性质类型</strong></h1><h2 id="CPU密集型（CPU-bound）"><a href="#CPU密集型（CPU-bound）" class="headerlink" title="CPU密集型（CPU-bound）"></a><strong>CPU密集型（CPU-bound）</strong></h2><p>CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。</p>
<p>在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。</p>
<p>CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I&#x2F;O的时间。</p>
<p>线程数一般设置为：</p>
<p>线程数 &#x3D; CPU核数+1 (现代CPU支持超线程)</p>
<h2 id="IO密集型（I-x2F-O-bound）"><a href="#IO密集型（I-x2F-O-bound）" class="headerlink" title="IO密集型（I&#x2F;O bound）"></a><strong>IO密集型（I&#x2F;O bound）</strong></h2><p>IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。</p>
<p>I&#x2F;O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I&#x2F;O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>
<p>线程数一般设置为：</p>
<p>线程数 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目 </p>
<h2 id="CPU密集型-vs-IO密集型"><a href="#CPU密集型-vs-IO密集型" class="headerlink" title="CPU密集型 vs IO密集型"></a><strong>CPU密集型 vs IO密集型</strong></h2><p>我们可以把任务分为计算密集型和IO密集型。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>
<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<h2 id="一、什么是-Fork-x2F-Join-框架？"><a href="#一、什么是-Fork-x2F-Join-框架？" class="headerlink" title="一、什么是 Fork&#x2F;Join 框架？"></a><strong>一、什么是 Fork&#x2F;Join 框架？</strong></h2><p>Fork&#x2F;Join 框架是 Java7 提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…..＋10000，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。如下图所示：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(58).png" alt="0"></p>
<p>Fork&#x2F;Jion特性：</p>
<ol>
<li>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。（见 Java Tip: When to use ForkJoinPool vs ExecutorService ）</li>
<li>ForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如 quick sort 等。</li>
<li>ForkJoinPool 最适合的是计算密集型的任务，如果存在 I&#x2F;O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用 ManagedBlocker。</li>
</ol>
<h2 id="二、工作窃取算法"><a href="#二、工作窃取算法" class="headerlink" title="二、工作窃取算法"></a><strong>二、工作窃取算法</strong></h2><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(59).png" alt="0"></p>
<ol>
<li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li>
<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li>
<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li>
</ol>
<h2 id="三、fork-x2F-join的使用"><a href="#三、fork-x2F-join的使用" class="headerlink" title="三、fork&#x2F;join的使用"></a><strong>三、fork&#x2F;join的使用</strong></h2><p>ForkJoinTask：我们要使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork() 和 join() 操作的机制，通常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，Fork&#x2F;Join 框架提供了以下两个子类：</p>
<p>RecursiveAction：用于没有返回结果的任务。(比如写数据到磁盘，然后就退出了。 一个RecursiveAction可以把自己的工作分割成更小的几块， 这样它们可以由独立的线程或者CPU执行。 我们可以通过继承来实现一个RecursiveAction)</p>
<p>RecursiveTask ：用于有返回结果的任务。(可以将自己的工作分割为若干更小任务，并将这些子任务的执行合并到一个集体结果。 可以有几个水平的分割和合并)</p>
<p>CountedCompleter： 在任务完成执行后会触发执行一个自定义的钩子函数</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(60).png" alt="0"></p>
<p>ForkJoinPool ：ForkJoinTask 需要通过 ForkJoinPool 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
<p>使用场景示例：</p>
<p>定义fork&#x2F;join任务，如下示例，随机生成2000w条数据在数组当中，然后求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RecursiveTask 并行计算，同步有返回值</span></span><br><span class="line"><span class="comment"> * ForkJoin框架处理的任务基本都能使用递归处理，比如求斐波那契数列等，但递归算法的缺陷是：</span></span><br><span class="line"><span class="comment"> *    一只会只用单线程处理，</span></span><br><span class="line"><span class="comment"> *    二是递归次数过多时会导致堆栈溢出；</span></span><br><span class="line"><span class="comment"> * ForkJoin解决了这两个问题，使用多线程并发处理，充分利用计算资源来提高效率，同时避免堆栈溢出发生。</span></span><br><span class="line"><span class="comment"> * 当然像求斐波那契数列这种小问题直接使用线性算法搞定可能更简单，实际应用中完全没必要使用ForkJoin框架，</span></span><br><span class="line"><span class="comment"> * 所以ForkJoin是核弹，是用来对付大家伙的，比如超大数组排序。</span></span><br><span class="line"><span class="comment"> * 最佳应用场景：多核、多内存、可以分割计算再合并的计算密集型任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LongSum</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line"><span class="comment">//任务拆分的最小阀值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEQUENTIAL_THRESHOLD</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NPS</span> <span class="operator">=</span> (<span class="number">1000L</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">extraWork</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// change to add more than just a sum</span></span><br><span class="line">    <span class="type">int</span> low;</span><br><span class="line">    <span class="type">int</span> high;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    LongSum(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi) &#123;</span><br><span class="line">        array = arr;</span><br><span class="line">        low = lo;</span><br><span class="line">        high = hi;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork()方法：将任务放入队列并安排异步执行，一个任务应该只调用一次fork()函数，除非已经执行完毕并重新初始化。</span></span><br><span class="line"><span class="comment"> * tryUnfork()方法：尝试把任务从队列中拿出单独处理，但不一定成功。</span></span><br><span class="line"><span class="comment"> * join()方法：等待计算完成并返回计算结果。</span></span><br><span class="line"><span class="comment"> * isCompletedAbnormally()方法：用于判断任务计算是否发生异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//任务被拆分到足够小时，则开始求和</span></span><br><span class="line">        <span class="keyword">if</span> (high - low &lt;= SEQUENTIAL_THRESHOLD) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; ++i) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果任务任然过大，则继续拆分任务，本质就是递归拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">LongSum</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongSum</span>(array, low, mid);</span><br><span class="line">            <span class="type">LongSum</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongSum</span>(array, mid, high);</span><br><span class="line">            left.fork();</span><br><span class="line">  right.fork();</span><br><span class="line">  <span class="type">long</span> <span class="variable">rightAns</span> <span class="operator">=</span> right.join();</span><br><span class="line">  <span class="type">long</span> <span class="variable">leftAns</span> <span class="operator">=</span> left.join();</span><br><span class="line">            <span class="keyword">return</span> leftAns + rightAns;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#执行fork/join任务</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongSumMain</span> &#123;</span><br><span class="line">   <span class="comment">//获取逻辑处理器数量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">   <span class="comment">/** for time conversion */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">NPS</span> <span class="operator">=</span> (<span class="number">1000L</span> * <span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">long</span> calcSum;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">reportSteals</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">int</span>[] array = Utils.buildRandomIntArray(<span class="number">20000000</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;cpu-num:&quot;</span>+NCPU);</span><br><span class="line">      <span class="comment">//单线程下计算数组数据总和</span></span><br><span class="line">      calcSum = seqSum(array);</span><br><span class="line">      System.out.println(<span class="string">&quot;seq sum=&quot;</span> + calcSum);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//采用fork/join方式将数组求和任务进行拆分执行，最后合并结果</span></span><br><span class="line">      <span class="type">LongSum</span> <span class="variable">ls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongSum</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">      <span class="type">ForkJoinPool</span> <span class="variable">fjp</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>); <span class="comment">//使用的线程数</span></span><br><span class="line">      ForkJoinTask&lt;Long&gt; result = fjp.submit(ls);</span><br><span class="line">      System.out.println(<span class="string">&quot;forkjoin sum=&quot;</span> + result.get());</span><br><span class="line"></span><br><span class="line">      fjp.shutdown();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">seqSum</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; ++i)</span><br><span class="line">         sum += array[i];</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、fork-x2F-join框架原理"><a href="#四、fork-x2F-join框架原理" class="headerlink" title="四、fork&#x2F;join框架原理"></a><strong>四、fork&#x2F;join框架原理</strong></h2><p><strong>常量介绍</strong></p>
<p>ForkJoinPool 与 内部类 WorkQueue 共享的一些常量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants shared across ForkJoinPool and WorkQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SMASK</span> <span class="operator">=</span> <span class="number">0xffff</span>;        <span class="comment">//  低位掩码，也是最大索引位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_CAP</span> <span class="operator">=</span> <span class="number">0x7fff</span>;        <span class="comment">//  工作线程最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EVENMASK</span> <span class="operator">=</span> <span class="number">0xfffe</span>;        <span class="comment">//  偶数低位掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQMASK</span> <span class="operator">=</span> <span class="number">0x007e</span>;        <span class="comment">//  workQueues 数组最多64个槽位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl 子域和 WorkQueue.scanState 的掩码和标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SCANNING</span> <span class="operator">=</span> <span class="number">1</span>;             <span class="comment">// 标记是否正在运行任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INACTIVE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 失活状态  负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SS_SEQ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本戳，防止ABA问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_MASK</span> <span class="operator">=</span> <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 模式掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIFO_QUEUE</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//LIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FIFO_QUEUE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//FIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_QUEUE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享模式队列，负数</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><strong>ForkJoinPool 中的相关常量和实例字段:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  低位和高位掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SP_MASK</span> <span class="operator">=</span> <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">UC_MASK</span> <span class="operator">=</span> ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AC_SHIFT</span> <span class="operator">=</span> <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">AC_UNIT</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">AC_MASK</span> <span class="operator">=</span> <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TC_SHIFT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TC_UNIT</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT; <span class="comment">//工作线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TC_MASK</span> <span class="operator">=</span> <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT; <span class="comment">//掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ADD_WORKER</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>);  <span class="comment">// 创建工作线程标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSLOCK</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSIGNAL</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STARTED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> ctl;                   <span class="comment">// 主控制参数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> runState;               <span class="comment">// 运行状态锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> config;                    <span class="comment">// 并行度|模式</span></span><br><span class="line"><span class="type">int</span> indexSeed;                       <span class="comment">// 用于生成工作线程索引</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// 主对象注册信息，workQueue</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;<span class="comment">// 线程工厂</span></span><br><span class="line"><span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// 每个工作线程的异常信息</span></span><br><span class="line"><span class="keyword">final</span> String workerNamePrefix;       <span class="comment">// 用于创建工作线程的名称</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicLong stealCounter;    <span class="comment">// 偷取任务总数，也可作为同步监视器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 静态初始化字段 */</span></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;</span><br><span class="line"><span class="comment">//启动或杀死线程的方法调用者的权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission modifyThreadPermission;</span><br><span class="line"><span class="comment">// 公共静态pool</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"><span class="comment">//并行度，对应内部common池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> commonParallelism;</span><br><span class="line"><span class="comment">//备用线程数，在tryCompensate中使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> commonMaxSpares;</span><br><span class="line"><span class="comment">//创建workerNamePrefix(工作线程名称前缀)时的序号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> poolNumberSequence;</span><br><span class="line"><span class="comment">//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">IDLE_TIMEOUT</span> <span class="operator">=</span> <span class="number">2000L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>; <span class="comment">// 2sec</span></span><br><span class="line"><span class="comment">//空闲超时时间，防止timer未命中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIMEOUT_SLOP</span> <span class="operator">=</span> <span class="number">20L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  <span class="comment">// 20ms</span></span><br><span class="line"><span class="comment">//默认备用线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_COMMON_MAX_SPARES</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment">//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPINS</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//indexSeed的增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEED_INCREMENT</span> <span class="operator">=</span> <span class="number">0x9e3779b9</span>;</span><br></pre></td></tr></table></figure>



<p><strong>ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:</strong></p>
<ul>
<li>AC: 正在运行工作线程数减去目标并行度，高16位</li>
<li>TC: 总工作线程数减去目标并行度，中高16位</li>
<li>SS: 栈顶等待线程的版本计数和状态，中低16位</li>
<li>ID: 栈顶 WorkQueue 在池中的索引(poolIndex)，低16位</li>
</ul>
<p>ForkJoinPool.WorkQueue 中的相关属性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始队列容量，2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="comment">//最大队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> scanState;    <span class="comment">// Woker状态, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="type">int</span> stackPred;             <span class="comment">// 记录前一个栈顶的ctl</span></span><br><span class="line"><span class="type">int</span> nsteals;               <span class="comment">// 偷取任务数</span></span><br><span class="line"><span class="type">int</span> hint;                  <span class="comment">// 记录偷取者索引，初始为随机索引</span></span><br><span class="line"><span class="type">int</span> config;                <span class="comment">// 池索引和模式</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> base;         <span class="comment">//下一个poll操作的索引(栈底/队列头)</span></span><br><span class="line"><span class="type">int</span> top;                   <span class="comment">//  下一个push操作的索引(栈顶/队列尾)</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务数组</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 当前工作队列的工作线程，共享模式下为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// 调用park阻塞期间为owner，其他情况为null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// 记录被join过来的任务</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// 记录从其他工作队列偷取过来的任务</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="1、异常处理"><a href="#1、异常处理" class="headerlink" title="1、异常处理"></a><strong>1、异常处理</strong></h3><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally())&#123;</span><br><span class="line">   System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p>getException 方法返回 Throwable 对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p>
<h3 id="2、ForkJoinPool构造函数"><a href="#2、ForkJoinPool构造函数" class="headerlink" title="2、ForkJoinPool构造函数"></a>2、ForkJoinPool构造函数</h3><p>其完整构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                     UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> mode,</span></span><br><span class="line"><span class="params">                     String workerNamePrefix)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    <span class="built_in">this</span>.ueh = handler;</span><br><span class="line">    <span class="built_in">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="type">long</span> <span class="variable">np</span> <span class="operator">=</span> (<span class="type">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="built_in">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p>重要参数解释</p>
<p>①parallelism：并行度（ the parallelism level），默认情况下跟我们机器的cpu个数保持一致，使用 Runtime.getRuntime().availableProcessors()可以得到我们机器运行时可用的CPU个数。</p>
<p>②factory：创建新线程的工厂（ the factory for creating new threads）。默认情况下使用ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory。</p>
<p>③handler：线程异常情况下的处理器（Thread.UncaughtExceptionHandler handler），该处理器在线程执行任务时由于某些无法预料到的错误而导致任务线程中断时进行一些处理，默认情况为null。</p>
<p>④asyncMode：这个参数要注意，在ForkJoinPool中，每一个工作线程都有一个独立的任务队列，<strong>asyncMode表示工作线程内的任务队列是采用何种方式进行调度，可以是先进先出FIFO，也可以是后进先出LIFO。如果为true，则线程池中的工作线程则使用先进先出方式进行任务调度，默认情况下是false。</strong></p>
<h3 id="3、ForkJoinTask-fork-方法"><a href="#3、ForkJoinTask-fork-方法" class="headerlink" title="3、ForkJoinTask fork 方法"></a><strong>3、ForkJoinTask fork 方法</strong></h3><p>fork() 做的工作只有一件事，既是<strong>把任务推入当前工作线程的工作队列里</strong>。可以参看以下的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="4、ForkJoinTask-join-方法"><a href="#4、ForkJoinTask-join-方法" class="headerlink" title="4、ForkJoinTask join 方法"></a><strong>4、ForkJoinTask join 方法</strong></h3><p>join() 的工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名的 Thread.join()。</p>
<ol>
<li>检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。</li>
<li>查看任务的完成状态，如果已经完成，直接返回结果。</li>
<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。</li>
<li>如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以 <em>FIFO</em> 方式），执行，以期帮助它早日完成欲 join 的任务。</li>
<li>如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务时，则找到小偷的小偷，帮助它完成它的任务。</li>
<li>递归地执行第5步。</li>
</ol>
<p>将上述流程画成序列图的话就是这个样子：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(61).png" alt="0"></p>
<h3 id="5、ForkJoinPool-submit-方法"><a href="#5、ForkJoinPool-submit-方法" class="headerlink" title="5、ForkJoinPool.submit 方法"></a><strong>5、ForkJoinPool.submit 方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="title function_">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="comment">//提交到工作队列</span></span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​            </p>
<p>ForkJoinPool 自身拥有工作队列，这些工作队列的作用是用来接收由外部线程（非 ForkJoinThread 线程）提交过来的任务，而这些工作队列被称为 <em>submitting queue</em> 。</p>
<p>submit() 和 fork() 其实没有本质区别，只是提交对象变成了 submitting queue 而已（还有一些同步，初始化的操作）。submitting queue 和其他 work queue 一样，是工作线程”窃取“的对象，因此当其中的任务被一个工作线程成功窃取时，就意味着提交的任务真正开始进入执行阶段。</p>
<h3 id="6、Fork-x2F-Join框架执行流程"><a href="#6、Fork-x2F-Join框架执行流程" class="headerlink" title="6、Fork&#x2F;Join框架执行流程"></a><strong>6、Fork&#x2F;Join框架执行流程</strong></h3><p>ForkJoinPool 中的任务执行分两种:</p>
<ul>
<li>直接通过 FJP 提交的外部任务(external&#x2F;submissions task)，存放在 workQueues 的偶数槽位；</li>
<li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20(62).png" alt="0"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="靓仔灬很忙"
      src="/images/WechatIMG1.jpeg">
  <p class="site-author-name" itemprop="name">靓仔灬很忙</p>
  <div class="site-description" itemprop="description">同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Floating-Dreamm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Floating-Dreamm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cl516729483@outlook.com" title="E-Mail → mailto:cl516729483@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">靓仔灬很忙</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">312k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
