<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"floating-dreamm.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
<meta property="og:type" content="website">
<meta property="og:title" content="Boyce">
<meta property="og:url" content="https://floating-dreamm.github.io/index.html">
<meta property="og:site_name" content="Boyce">
<meta property="og:description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="靓仔灬很忙">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://floating-dreamm.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Boyce</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Boyce</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-essays">

    <a href="/essays/" rel="section"><i class="fa fa-book fa-fw"></i>随笔</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-quickhelp">

    <a href="/categories/quickHelp/" rel="section"><i class="fa fa-bolt fa-fw"></i>快捷</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Floating-Dreamm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/03/%E4%B8%80%E4%BA%9B%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E4%B8%80%E4%BA%9B%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/" class="post-title-link" itemprop="url">前言</a>
        </h2>

        <div class="post-meta">

          
             <i class="fa fa-thumb-tack"></i>
             <font color=7D26CD>置顶</font>
             <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 17:08:22" itemprop="dateCreated datePublished" datetime="2022-03-03T17:08:22+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-08 19:10:28" itemprop="dateModified" datetime="2022-03-08T19:10:28+08:00">2022-03-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>616</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        首先想感谢一下提供这些开源软件及安装教程的开发者们。从零开始搭建一个博客，光靠一个人从头开始，耗时耗力耗神，有了这些工具之后，让我可以在很短时间内实现自己的博客。我是参考知乎上一位作者，每一步都讲的很详细，如果有读者也想自己搭建一个自己的博客，可以参考一下，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客</a>。</p>
<p>​        当程序员是件很酷的事，反正我一直是这么觉得。想做一名合格的java程序员，要学的东西还真不少，java基础、网络编程、多线程相关、框架源码、中间件、数据库等等。要真正把这些掌握，还是要花挺多时间的。很多知识点学过之后，可能自己似懂非懂，不如把这些以自己的理解讲出来，更加能加深印象。接下来我准备持续更新一些java开发中用到的一些技术，不一定能每天更新，但是尽量吧。</p>
<p>​        先介绍一些基本功能吧。</p>
<ul>
<li>在<strong>首页</strong>标签下，我会持续更新一些技术源码等；各位读者可以通过网站的搜索功能或者标签跳转到想看的专题；当然，由于个人能力有限，如果发现有错误的地方，可以点击导航栏最下面的<strong>E-mail</strong>标签与我联系，我会及时查看每一位读者的来信；</li>
<li>在<strong>随笔</strong>标签下，我会记录一些日常开发中遇到的bug，如果解决了会及时贴上去，各位读者可以通过搜索功能查看是否有与自己遇到相同的问题；另外，在随笔标签下，我开启了评论功能，如果读者有更好的解决方案，可以在下方留言。</li>
<li><strong>关于</strong>标签暂时还没想好要干啥，如果读者有什么需求可以联系我。</li>
</ul>
<p>目前更新内容只是为了方便自己随时复习，不用于任何商业用途，不得转载。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">CPU缓存一致协议</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 23:40:25" itemprop="dateCreated datePublished" datetime="2022-03-08T23:40:25+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:49:34" itemprop="dateModified" datetime="2022-03-13T10:49:34+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CPU缓存一致性协议MESI"><a href="#CPU缓存一致性协议MESI" class="headerlink" title="CPU缓存一致性协议MESI"></a><strong>CPU缓存一致性协议MESI</strong></h1><hr>
<h2 id="CPU高速缓存（Cache-Memory）"><a href="#CPU高速缓存（Cache-Memory）" class="headerlink" title="CPU高速缓存（Cache Memory）"></a><strong>CPU高速缓存（Cache Memory）</strong></h2><hr>
<h3 id="CPU为何要有高速缓存"><a href="#CPU为何要有高速缓存" class="headerlink" title="CPU为何要有高速缓存"></a><strong>CPU为何要有高速缓存</strong></h3><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p>
<p><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>
<p>比如循环、递归、方法的反复调用等。</p>
<p><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p>
<p>比如顺序执行的代码、连续创建的两个对象、数组等。</p>
<h4 id="带有高速缓存的CPU执行计算的流程"><a href="#带有高速缓存的CPU执行计算的流程" class="headerlink" title="带有高速缓存的CPU执行计算的流程"></a><strong>带有高速缓存的CPU执行计算的流程</strong></h4><ol>
<li>程序以及数据被加载到主内存</li>
<li>指令和数据被加载到CPU的高速缓存</li>
<li>CPU执行指令，把结果写到高速缓存</li>
<li>高速缓存中的数据写回主内存</li>
</ol>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/00-647146146.png" alt="0"></p>
<h4 id="目前流行的多级缓存结构"><a href="#目前流行的多级缓存结构" class="headerlink" title="目前流行的多级缓存结构"></a><strong>目前流行的多级缓存结构</strong></h4><p>由于CPU的运算速度超越了1级缓存的数据I\O能力，CPU厂商又引入了多级的缓存结构。</p>
<p>多级缓存结构</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/5-1411867425.png" alt="0"></p>
<h3 id="多核CPU多级缓存一致性协议MESI"><a href="#多核CPU多级缓存一致性协议MESI" class="headerlink" title="多核CPU多级缓存一致性协议MESI"></a><strong>多核CPU多级缓存一致性协议MESI</strong></h3><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。</p>
<h4 id="MESI协议缓存状态"><a href="#MESI协议缓存状态" class="headerlink" title="MESI协议缓存状态"></a><strong>MESI协议缓存状态</strong></h4><p>MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：</p>
<p><strong>缓存行（Cache line）</strong>:缓存存储数据的单元。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
<th>监听任务</th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>无</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p><strong>对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的</strong>。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p>
<h4 id="MESI状态转换"><a href="#MESI状态转换" class="headerlink" title="MESI状态转换"></a><strong>MESI状态转换</strong></h4><p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/0-2087402052.png" alt="0"></p>
<p>理解该图的前置说明：</p>
<p>1.触发事件</p>
<table>
<thead>
<tr>
<th>触发事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>本地读取（Local read）</td>
<td>本地cache读取本地cache数据</td>
</tr>
<tr>
<td>本地写入（Local write）</td>
<td>本地cache写入本地cache数据</td>
</tr>
<tr>
<td>远端读取（Remote read）</td>
<td>其他cache读取本地cache数据</td>
</tr>
<tr>
<td>远端写入（Remote write）</td>
<td>其他cache写入本地cache数据</td>
</tr>
</tbody></table>
<p>2.cache分类：</p>
<p>前提：所有的cache共同缓存了主内存中的某一条数据。</p>
<p>本地cache:指当前cpu的cache。</p>
<p>触发cache:触发读写事件的cache。</p>
<p>其他cache:指既除了以上两种之外的cache。</p>
<p>注意：本地的事件触发 本地cache和触发cache为相同。</p>
<p>上图的切换解释：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>触发本地读取</th>
<th>触发本地写入</th>
<th>触发远端读取</th>
<th>触发远端写入</th>
</tr>
</thead>
<tbody><tr>
<td><strong>M状态（修改）</strong></td>
<td>本地cache:M 触发cache:M其他cache:I</td>
<td>本地cache:M 触发cache:M其他cache:I</td>
<td>本地cache:M→E→S触发cache:I→S其他cache:I→S同步主内存后修改为E独享,同步触发、其他cache后本地、触发、其他cache修改为S共享</td>
<td>本地cache:M→E→S→I触发cache:I→S→E→M其他cache:I→S→I同步和读取一样,同步完成后触发cache改为M，本地、其他cache改为I</td>
</tr>
<tr>
<td><strong>E状态（独享）</strong></td>
<td>本地cache:E触发cache:E其他cache:I</td>
<td>本地cache:E→M触发cache:E→M其他cache:I本地cache变更为M,其他cache状态应当是I（无效）</td>
<td>本地cache:E→S触发cache:I→S其他cache:I→S当其他cache要读取该数据时，其他、触发、本地cache都被设置为S(共享)</td>
<td>本地cache:E→S→I触发cache:I→S→E→M其他cache:I→S→I当触发cache修改本地cache独享数据时时，将本地、触发、其他cache修改为S共享.然后触发cache修改为独享，其他、本地cache修改为I（无效），触发cache再修改为M</td>
</tr>
<tr>
<td><strong>S状态(共享)</strong></td>
<td>本地cache:S触发cache:S其他cache:S</td>
<td>本地cache:S→E→M触发cache:S→E→M其他cache:S→I 当本地cache修改时，将本地cache修改为E,其他cache修改为I,然后再将本地cache为M状态</td>
<td>本地cache:S触发cache:S其他cache:S</td>
<td>本地cache:S→I触发cache：S→E→M其他cache:S→I当触发cache要修改本地共享数据时，触发cache修改为E（独享）,本地、其他cache修改为I（无效）,触发cache再次修改为M(修改)</td>
</tr>
<tr>
<td><strong>I状态（无效）</strong></td>
<td>本地cache:I→S或者I→E触发cache:I→S或者I →E其他cache:E、M、I→S、I本地、触发cache将从I无效修改为S共享或者E独享，其他cache将从E、M、I 变为S或者I</td>
<td>本地cache:I→S→E→M触发cache:I→S→E→M其他cache:M、E、S→S→I</td>
<td>既然是本cache是I，其他cache操作与它无关</td>
<td>既然是本cache是I，其他cache操作与它无关</td>
</tr>
</tbody></table>
<p>下图示意了，当一个cache line的调整的状态的时候，另外一个cache line 需要调整的状态。</p>
<table>
<thead>
<tr>
<th></th>
<th>M</th>
<th>E</th>
<th>S</th>
<th><strong>I</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>M</strong></td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>举个栗子来说：</p>
<p>假设cache 1 中有一个变量x &#x3D; 0的cache line 处于S状态(共享)。</p>
<p>那么其他拥有x变量的cache 2、cache 3等x的cache line调整为S状态（共享）或者调整为 I 状态（无效）。</p>
<h4 id="多核缓存协同操作"><a href="#多核缓存协同操作" class="headerlink" title="多核缓存协同操作"></a><strong>多核缓存协同操作</strong></h4><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、 c。在主内存中定义了x的引用值为0。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/99-994420333.png" alt="0"></p>
<h4 id="单核读取"><a href="#单核读取" class="headerlink" title="单核读取"></a><strong>单核读取</strong></h4><p>那么执行流程是：</p>
<p>CPU A发出了一条指令，从主内存中读取x。</p>
<p>从主内存通过bus读取到缓存中（远端读取Remote read）,这是该Cache line修改为E状态（独享）.</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/68-681441242.png" alt="0"></p>
<h4 id="双核读取"><a href="#双核读取" class="headerlink" title="双核读取"></a><strong>双核读取</strong></h4><p>那么执行流程是：</p>
<p>CPU A发出了一条指令，从主内存中读取x。</p>
<p>CPU A从主内存通过bus读取到 cache a中并将该cache line 设置为E状态。</p>
<p>CPU B发出了一条指令，从主内存中读取x。</p>
<p>CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x 存储于cache a和cache b中，x在chche a和cache b中都被设置为S状态(共享)。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/34-683579600.png" alt="0"></p>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a><strong>修改数据</strong></h4><p>那么执行流程是：</p>
<p>CPU A 计算完成后发指令需要修改x.</p>
<p>CPU A 将x设置为M状态（修改）并通知缓存了x的CPU B, CPU B将本地cache b中的x设置为I状态(无效)</p>
<p>CPU A 对x进行赋值。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/9-1465275811.png" alt="0"></p>
<h4 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a><strong>同步数据</strong></h4><p>那么执行流程是：</p>
<p>CPU B 发出了要读取x的指令。</p>
<p>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）</p>
<p>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/40-382839091.png" alt="0"></p>
<h3 id="缓存行伪共享"><a href="#缓存行伪共享" class="headerlink" title="缓存行伪共享"></a><strong>缓存行伪共享</strong></h3><h4 id="什么是伪共享？"><a href="#什么是伪共享？" class="headerlink" title="什么是伪共享？"></a><strong>什么是伪共享？</strong></h4><p>CPU缓存系统中是以缓存行（cache line）为单位存储的。目前主流的CPU Cache 的 Cache Line 大小都是64Bytes。在多线程情况下，如果需要修改“共享同一个缓存行的变量”，就会无意中影响彼此的性能，这就是伪共享（False Sharing）。</p>
<p>举个例子: 现在有2个long 型变量 a 、b，如果有t1在访问a，t2在访问b，而a与b刚好在同一个cache line中，此时t1先修改a，将导致b被刷新！</p>
<h4 id="怎么解决伪共享？"><a href="#怎么解决伪共享？" class="headerlink" title="怎么解决伪共享？"></a><strong>怎么解决伪共享？</strong></h4><p>Java8中新增了一个注解：@sun.misc.Contended。加上这个注解的类会自动补齐缓存行，需要注意的是此注解默认是无效的，需要在jvm启动时设置 -XX:-RestrictContended 才会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TulingVolatileLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//public long p1, p2, p3, p4, p5, p6;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h3 id="MESI优化和他们引入的问题"><a href="#MESI优化和他们引入的问题" class="headerlink" title="MESI优化和他们引入的问题"></a><strong>MESI优化和他们引入的问题</strong></h3><hr>
<p>缓存的一致性消息传递是要时间的，这就使其切换时会产生延迟。当一个缓存被切换状态时其他缓存收到消息完成各自的切换并且发出回应消息这么一长串的时间中CPU都会等待所有缓存响应完成。可能出现的阻塞都会导致各种各样的性能问题和稳定性问题。</p>
<h4 id="CPU切换状态阻塞解决-存储缓存（Store-Bufferes）"><a href="#CPU切换状态阻塞解决-存储缓存（Store-Bufferes）" class="headerlink" title="CPU切换状态阻塞解决-存储缓存（Store Bufferes）"></a><strong>CPU切换状态阻塞解决-存储缓存（Store Bufferes）</strong></h4><p>比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。应为这个等待远远比一个指令的执行时间长的多。</p>
<h5 id="Store-Bufferes"><a href="#Store-Bufferes" class="headerlink" title="Store Bufferes"></a><strong>Store Bufferes</strong></h5><p>为了避免这种CPU运算能力的浪费，Store Bufferes被引入使用。处理器把它想要写入到主存的值写到缓存，然后继续去处理其他事情。当所有失效确认（Invalidate Acknowledge）都接收到时，数据才会最终被提交。</p>
<p>这么做有两个风险</p>
<h5 id="Store-Bufferes的风险"><a href="#Store-Bufferes的风险" class="headerlink" title="Store Bufferes的风险"></a><strong>Store Bufferes的风险</strong></h5><p>第一、就是处理器会尝试从存储缓存（Store buffer）中读取值，但它还没有进行提交。这个的解决方案称为Store Forwarding，它使得加载的时候，如果存储缓存中存在，则进行返回。</p>
<p>第二、保存什么时候会完成，这个并没有任何保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">3</span>；</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exeToCPUA</span><span class="params">()</span>&#123;</span><br><span class="line">  value = <span class="number">10</span>;</span><br><span class="line">  isFinsh = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">exeToCPUB</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isFinsh)&#123;</span><br><span class="line">    <span class="comment">//value一定等于10？！</span></span><br><span class="line">    <span class="type">assert</span> <span class="variable">value</span> <span class="operator">=</span>= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>即isFinsh的赋值在value赋值之前。</strong></p>
<p>这种在可识别的行为中发生的变化称为重排序（reordings）。注意，这不意味着你的指令的位置被恶意（或者好意）地更改。</p>
<p>它只是意味着其他的CPU会读到跟程序中写入的顺序不一样的结果。</p>
<p>顺便提一下NIO的设计和Store Bufferes的设计是非常相像的。</p>
<h5 id="硬件内存模型"><a href="#硬件内存模型" class="headerlink" title="硬件内存模型"></a><strong>硬件内存模型</strong></h5><p>执行失效也不是一个简单的操作，它需要处理器去处理。另外，存储缓存（Store Buffers）并不是无穷大的，所以处理器有时需要等待失效确认的返回。这两个操作都会使得性能大幅降低。为了应付这种情况，引入了失效队列。它们的约定如下：</p>
<ul>
<li>对于所有的收到的Invalidate请求，Invalidate Acknowlege消息必须立刻发送</li>
<li>Invalidate并不真正执行，而是被放在一个特殊的队列中，在方便的时候才会去执行。</li>
<li>处理器不会发送任何消息给所处理的缓存条目，直到它处理Invalidate。</li>
</ul>
<p>即便是这样处理器已然不知道什么时候优化是允许的，而什么时候并不允许。</p>
<p>干脆处理器将这个任务丢给了写代码的人。这就是内存屏障（Memory Barriers）。</p>
<blockquote>
<p>写屏障 Store Memory Barrier(a.k.a. ST, SMB, smp_wmb)是一条告诉处理器在执行这之后的指令之前，应用所有已经在存储缓存（store buffer）中的保存的指令。</p>
</blockquote>
<blockquote>
<p>读屏障Load Memory Barrier (a.k.a. LD, RMB, smp_rmb)是一条告诉处理器在执行任何的加载前，先应用所有已经在失效队列中的失效操作的指令。</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">executedOnCpu0</span><span class="params">()</span> &#123;</span><br><span class="line">    value = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//在更新数据之前必须将所有存储缓存（store buffer）中的指令执行完毕。</span></span><br><span class="line">    storeMemoryBarrier();</span><br><span class="line">    finished = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">executedOnCpu1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!finished);</span><br><span class="line">    <span class="comment">//在读取之前将所有失效队列中关于该数据的指令执行完毕。</span></span><br><span class="line">    loadMemoryBarrier();</span><br><span class="line">    <span class="type">assert</span> <span class="variable">value</span> <span class="operator">=</span>= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<p>引用资料</p>
<p><a target="_blank" rel="noopener" href="http://igoro.com/archive/gallery-of-processor-cache-effects/">http://igoro.com/archive/gallery-of-processor-cache-effects/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/volatile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/volatile/" class="post-title-link" itemprop="url">volatile</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 23:37:31" itemprop="dateCreated datePublished" datetime="2022-03-08T23:37:31+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:53:02" itemprop="dateModified" datetime="2022-03-13T10:53:02+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a><strong>volatile内存语义</strong></h1><p>volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用</p>
<ul>
<li>保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</li>
<li>禁止指令重排序优化。</li>
</ul>
<h2 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a><strong>volatile的可见性</strong></h2><p>关于volatile的可见性作用，我们必须意识到被volatile修饰的变量对所有线程总数立即可见的，对volatile变量的所有写操作总是能立刻反应到其他线程中</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibilitySample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.initFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadname</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span>+threadname+<span class="string">&quot;:修改共享变量initFlag&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadname</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">while</span> (!initFlag)&#123;</span><br><span class="line">            <span class="comment">//线程在此处空跑，等待initFlag状态改变</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span>+threadname+<span class="string">&quot;当前线程嗅探到initFlag的状态的改变&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">VolatileVisibilitySample</span> <span class="variable">sample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileVisibilitySample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            sample.save();</span><br><span class="line">        &#125;,<span class="string">&quot;threadA&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            sample.load();</span><br><span class="line">        &#125;,<span class="string">&quot;threadB&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        threadA.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>线程A改变initFlag属性之后，线程B马上感知到</p>
<h2 id="volatile无法保证原子性"><a href="#volatile无法保证原子性" class="headerlink" title="volatile无法保证原子性"></a><strong>volatile无法保证原子性</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileVisibility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>在并发场景下，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时调用increase()方法的话，就会出现线程安全问题，毕竟i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全，需要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见性，因此在这样种情况下就完全可以省去volatile修饰变量。</p>
<h2 id="volatile禁止重排优化"><a href="#volatile禁止重排优化" class="headerlink" title="volatile禁止重排优化"></a><strong>volatile禁止重排优化</strong></h2><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。 </p>
<h2 id="硬件层的内存屏障"><a href="#硬件层的内存屏障" class="headerlink" title="硬件层的内存屏障"></a><strong>硬件层的内存屏障</strong></h2><p>Intel硬件提供了一系列的内存屏障，主要有： </p>
<ol>
<li><p>lfence，是一种Load Barrier 读屏障 </p>
</li>
<li><p>sfence, 是一种Store Barrier 写屏障 </p>
</li>
<li><p>mfence, 是一种全能型的屏障，具备ifence和sfence的能力 </p>
</li>
<li><p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。</p>
</li>
</ol>
<p>不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。 JVM中提供了四类内存屏障指令：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody></table>
<p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。下面看一个非常典型的禁止重排优化的例子DCL，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckLock</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span>  <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>上述代码一个经典的单例的双重检测的代码，这段代码在单线程环境下并没有什么问题，但如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p>
<p>因为instance &#x3D; new DoubleCheckLock();可以分为以下3步完成(伪代码)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象</span></span><br><span class="line">instance = memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null         </span></span><br></pre></td></tr></table></figure>

<p>由于步骤1和步骤2间可能会重排序，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory=allocate();<span class="comment">//1.分配对象内存空间</span></span><br><span class="line">instance=memory;<span class="comment">//3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！</span></span><br><span class="line">instance(memory);<span class="comment">//2.初始化对象      </span></span><br></pre></td></tr></table></figure>

<p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//禁止指令重排优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br></pre></td></tr></table></figure>

<h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a><strong>volatile内存语义的实现</strong></h2><p>前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。</p>
<p>下图是JMM针对编译器制定的volatile重排序规则表。</p>
<table>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody><tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody></table>
<p>举例来说，第二行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上图可以看出：</p>
<ul>
<li><ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
</ul>
</li>
<li><ul>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读或写时，不能重排序。</li>
</ul>
</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p>
<ul>
<li><ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%284%29.png" alt="0"></p>
<p>上图中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</p>
<p>这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与 后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面 是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确 实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile 读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个 volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个 写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下图是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%285%29.png" alt="0"></p>
<p>上图中LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面通过具体的示例</p>
<p>代码进行说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileBarrierExample</span> &#123;</span><br><span class="line">       <span class="type">int</span> a;</span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">readAndWrite</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v1;　　    <span class="comment">// 第一个volatile读</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2;    　  <span class="comment">// 第二个volatile读</span></span><br><span class="line">           a = i + j;         <span class="comment">// 普通写</span></span><br><span class="line">           v1 = i + <span class="number">1</span>;     　 <span class="comment">// 第一个volatile写</span></span><br><span class="line">          v2 = j * <span class="number">2</span>;    　  <span class="comment">// 第二个 volatile写</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%286%29.png" alt="0"></p>
<p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编 译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插 入一个StoreLoad屏障。</p>
<p>上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模 型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，图3-21 中除最后的StoreLoad屏障外，其他的屏障都会被省略。</p>
<p>前面保守策略下的volatile读和写，在X86处理器平台可以优化成如下图所示。前文提到过，X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作 做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需 在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在 X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%287%29.png" alt="0"></p>
<p><strong>引用资料：</strong></p>
<p>1、《并发编程的艺术》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/JMM%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/JMM%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">JMM模型</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 23:34:47" itemprop="dateCreated datePublished" datetime="2022-03-08T23:34:47+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:52:05" itemprop="dateModified" datetime="2022-03-13T10:52:05+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是JMM模型？"><a href="#什么是JMM模型？" class="headerlink" title="什么是JMM模型？"></a><strong>什么是JMM模型？</strong></h1><p>Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p>
<h2 id="JMM不同于JVM内存区域模型"><a href="#JMM不同于JVM内存区域模型" class="headerlink" title="JMM不同于JVM内存区域模型"></a><strong>JMM不同于JVM内存区域模型</strong></h2><p>JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<strong>JMM是围绕原子性，有序性、可见性展开</strong>。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </p>
<p>线程，工作内存，主内存工作交互图（基于JMM规范）：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%289%29.png" alt="0"></p>
<h3 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a><strong>主内存</strong></h3><p>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。</p>
<h3 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a><strong>工作内存</strong></h3><p>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>
<p>根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存</p>
<p>模型如下图所示</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard.png" alt="0"></p>
<h3 id="Java内存模型与硬件内存架构的关系"><a href="#Java内存模型与硬件内存架构的关系" class="headerlink" title="Java内存模型与硬件内存架构的关系"></a><strong>Java内存模型与硬件内存架构的关系</strong></h3><p>通过对前面的硬件内存架构、Java内存模型以及Java多线程的实现原理的了解，我们应该已经意识到，多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。(注意对于Java内存区域划分也是同样的道理)</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%281%29.png" alt="0"></p>
<h2 id="JMM存在的必要性"><a href="#JMM存在的必要性" class="headerlink" title="JMM存在的必要性"></a><strong>JMM存在的必要性</strong></h2><p>在明白了Java内存区域划分、硬件内存架构、Java多线程的实现原理与Java内存模型的具体关系后，接着来谈谈Java内存模型存在的必要性。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。</p>
<p>假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x&#x3D;1进行操作，A&#x2F;B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x&#x3D;1拷贝到自己的工作内存中，这样B线程读取到的值就是x&#x3D;1，但如果A线程已将x&#x3D;2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x&#x3D;2，但到底是哪种情况先发生呢？</p>
<p>如以下示例图所示案例：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%282%29.png" alt="0"></p>
<p>以上关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。</p>
<h2 id="数据同步八大原子操作"><a href="#数据同步八大原子操作" class="headerlink" title="数据同步八大原子操作"></a><strong>数据同步八大原子操作</strong></h2><p>（1）lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</p>
<p>（2）unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p>
<p>（3）read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
<p>（4）load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</p>
<p>（5）use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</p>
<p>（6）assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</p>
<p>（7）store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</p>
<p>（8）write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p>
<p>如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%283%29.png" alt="0"></p>
<h3 id="同步规则分析"><a href="#同步规则分析" class="headerlink" title="同步规则分析"></a><strong>同步规则分析</strong></h3><p>1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</p>
<p>2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</p>
<p>3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</p>
<p>4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</p>
<p>5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p>
<p>6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p>
<h2 id="并发编程的可见性，原子性与有序性问题"><a href="#并发编程的可见性，原子性与有序性问题" class="headerlink" title="并发编程的可见性，原子性与有序性问题"></a><strong>并发编程的可见性，原子性与有序性问题</strong></h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h3><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p>
<p>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">10</span>;  <span class="comment">//原子性（简单的读取、将数字赋值给变量）</span></span><br><span class="line">Y = x;  <span class="comment">//变量之间的相互赋值，不是原子操作</span></span><br><span class="line">X++;  <span class="comment">//对变量进行计算操作</span></span><br><span class="line">X = x+<span class="number">1</span>;     </span><br></pre></td></tr></table></figure>

<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h3><p>理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。</p>
<p>但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a><strong>有序性</strong></h3><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p>
<h2 id="JMM如何解决原子性-amp-可见性-amp-有序性问题"><a href="#JMM如何解决原子性-amp-可见性-amp-有序性问题" class="headerlink" title="JMM如何解决原子性&amp;可见性&amp;有序性问题"></a><strong>JMM如何解决原子性&amp;可见性&amp;有序性问题</strong></h2><p><strong>代码示例参见本节课程的相关源码Demo</strong></p>
<h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a><strong>原子性问题</strong></h3><p>除了JVM自身提供的对基本数据类型读写操作的原子性外，可以通过 synchronized和Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p>
<h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a><strong>可见性问题</strong></h3><p>volatile关键字保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值。synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。</p>
<h3 id="有序性问题"><a href="#有序性问题" class="headerlink" title="有序性问题"></a><strong>有序性问题</strong></h3><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述volatile关键字）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p><strong>Java内存模型</strong>：每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p><strong>指令重排序</strong>：java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。指令重排序的意义是什么？JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<p>下图为从源码到最终执行的指令序列示意图：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/clipboard%20%288%29.png" alt="0"></p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><strong>as-if-serial语义</strong></h3><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a><strong>happens-before 原则</strong></h3><p>只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，从JDK 5开始，Java使用新的JSR-133内存模型，提供了happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下</p>
<ol>
<li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li>
<li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li>
<li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li>
<li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li>
<li>传递性 A先于B ，B先于C 那么A必然先于C</li>
<li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li>
<li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li>
<li>对象终结规则对象的构造函数执行，结束先于finalize()方法</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">操作系统底层原理</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 23:29:59" itemprop="dateCreated datePublished" datetime="2022-03-08T23:29:59+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:49:30" itemprop="dateModified" datetime="2022-03-13T10:49:30+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="冯诺依曼计算机模型详解"><a href="#冯诺依曼计算机模型详解" class="headerlink" title="冯诺依曼计算机模型详解"></a><strong>冯诺依曼计算机模型详解</strong></h1><hr>
<p>现代计算机模型是基于-<strong>冯诺依曼计算机模型</strong></p>
<p>计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停止指令。</p>
<p>程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型。这一原理最初是由美籍匈牙利数学家冯.诺依曼于1945年提出来的，故称为冯.诺依曼计算机模型。</p>
<h2 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a><strong>计算机五大核心组成部分</strong></h2><ol>
<li><p>控制器(Control)：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</p>
</li>
<li><p>运算器(Datapath)：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</p>
</li>
<li><p>存储器(Memory)：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p>
</li>
<li><p>输入(Input system)：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</p>
</li>
<li><p>输出(Output system)：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</p>
</li>
</ol>
<p>下图-冯诺依曼计算机模型图</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%288%29.png" alt="0"></p>
<p>上面的模型是一个理论的抽象简化模型，它的具体应用就是现代计算机当中的硬件结构设计：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%281%29.png" alt="0"></p>
<p>在上图硬件结构当中，配件很多，但最核心的只有两部分：CPU、内存。所以我们重点学习的也是这两部分。</p>
<h2 id="CPU指令结构"><a href="#CPU指令结构" class="headerlink" title="CPU指令结构"></a><strong>CPU指令结构</strong></h2><p>CPU内部结构</p>
<ul>
<li>控制单元</li>
<li>运算单元</li>
<li>数据单元</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%282%29.png" alt="0"></p>
<h3 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a><strong>控制单元</strong></h3><p>控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p>
<h3 id="运算单元"><a href="#运算单元" class="headerlink" title="运算单元"></a><strong>运算单元</strong></h3><p>运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。</p>
<h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a><strong>存储单元</strong></h3><p>存储单元包括 CPU 片内缓存Cache和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访问内存的时间短。 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。</p>
<p>下表列出了CPU关键技术的发展历程以及代表系列，每一个关键技术的诞生都是环环相扣的，处理器这些技术发展历程都围绕着如何不让“CPU闲下来”这一个核心目标展开。</p>
<table>
<thead>
<tr>
<th>关键技术</th>
<th>时间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>指令缓存(L1)</td>
<td>1982</td>
<td>预读多条指令</td>
</tr>
<tr>
<td>数据缓存(L1)</td>
<td>1985</td>
<td>预读一定长度的数据</td>
</tr>
<tr>
<td>流水线</td>
<td>1989</td>
<td>一条指令被拆分由多个单元协同处理, i486</td>
</tr>
<tr>
<td>多流水线</td>
<td>1993</td>
<td>多运算单元多流水线并行处理, 奔腾1</td>
</tr>
<tr>
<td>乱序+分支预测</td>
<td>1995</td>
<td>充分利用不同组件协同处理, 奔腾Pro</td>
</tr>
<tr>
<td>超线程</td>
<td>2002</td>
<td>引入多组前端部件共享执行引擎, 奔腾4</td>
</tr>
<tr>
<td>多核处理器</td>
<td>2006</td>
<td>取消超线程，降低时钟频率，改用多核心, Core酷睿</td>
</tr>
<tr>
<td>多核超线程</td>
<td>2008</td>
<td>重新引入超线程技术，iX系列</td>
</tr>
</tbody></table>
<h2 id="CPU缓存结构"><a href="#CPU缓存结构" class="headerlink" title="CPU缓存结构"></a><strong>CPU缓存结构</strong></h2><p>现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构</p>
<ul>
<li>L1 Cache，分为数据缓存和指令缓存，逻辑核独占</li>
<li>L2 Cache，物理核独占，逻辑核共享</li>
<li>L3 Cache，所有物理核共享</li>
</ul>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%283%29.png" alt="0"></p>
<p>存储器存储空间大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器；</p>
<p>存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存；</p>
<p>还有一点值得注意的是：缓存是由最小的存储区块-缓存行(cacheline)组成，缓存行大小通常为64byte。</p>
<p>缓存行是什么意思呢？</p>
<p>比如你的L1缓存大小是512kb,而cacheline &#x3D; 64byte,那么就是L1里有512 * 1024&#x2F;64个cacheline</p>
<h3 id="CPU读取存储器数据过程"><a href="#CPU读取存储器数据过程" class="headerlink" title="CPU读取存储器数据过程"></a><strong>CPU读取存储器数据过程</strong></h3><p>1、CPU要取寄存器X的值，只需要一步：直接读取。</p>
<p>2、CPU要取L1 cache的某个值，需要1-3步（或者更多）：把cache行锁住，把某个数据拿来，解锁，如果没锁住就慢了。</p>
<p>3、CPU要取L2 cache的某个值，先要到L1 cache里取，L1当中不存在，在L2里，L2开始加锁，加锁以后，把L2里的数据复制到L1，再执行读L1的过程，上面的3步，再解锁。</p>
<p>4、CPU取L3 cache的也是一样，只不过先由L3复制到L2，从L2复制到L1，从L1到CPU。</p>
<p>5、CPU取内存则最复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存到L3（如果没有就到L2），再从L3&#x2F;2到L1，再从L1到CPU，之后解除总线锁定。</p>
<h3 id="CPU为何要有高速缓存"><a href="#CPU为何要有高速缓存" class="headerlink" title="CPU为何要有高速缓存"></a><strong>CPU为何要有高速缓存</strong></h3><p>CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。</p>
<p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。</p>
<p><strong>时间局部性（Temporal Locality）</strong>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>
<p>比如循环、递归、方法的反复调用等。</p>
<p><strong>空间局部性（Spatial Locality）</strong>：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p>
<p>比如顺序执行的代码、连续创建的两个对象、数组等。</p>
<p>举个空间局部性原则例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoDimensionalArraySum</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DIMENSION_1</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DIMENSION_2</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span>[][] longs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 初始化数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        longs = <span class="keyword">new</span> <span class="title class_">long</span>[DIMENSION_1][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DIMENSION_1; i++) &#123;</span><br><span class="line">            longs[i] = <span class="keyword">new</span> <span class="title class_">long</span>[DIMENSION_2];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; DIMENSION_2; j++) &#123;</span><br><span class="line">                longs[i][j] = <span class="number">1L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Array初始化完毕....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DIMENSION_1; i++) &#123;<span class="comment">//DIMENSION_1=1024*1024</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;DIMENSION_2;j++)&#123;<span class="comment">//6</span></span><br><span class="line">                    sum+=longs[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;spend time1:&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        System.out.println(<span class="string">&quot;sum1:&quot;</span>+sum);</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; RUNS; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;DIMENSION_2;j++) &#123;<span class="comment">//6</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; DIMENSION_1; i++)&#123;<span class="comment">//1024*1024</span></span><br><span class="line">                    sum+=longs[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;spend time2:&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        System.out.println(<span class="string">&quot;sum2:&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带有高速缓存的CPU执行计算的流程"><a href="#带有高速缓存的CPU执行计算的流程" class="headerlink" title="带有高速缓存的CPU执行计算的流程"></a><strong>带有高速缓存的CPU执行计算的流程</strong></h3><ol>
<li>程序以及数据被加载到主内存</li>
<li>指令和数据被加载到CPU的高速缓存</li>
<li>CPU执行指令，把结果写到高速缓存</li>
<li>高速缓存中的数据写回主内存</li>
</ol>
<h2 id="CPU运行安全等级"><a href="#CPU运行安全等级" class="headerlink" title="CPU运行安全等级"></a><strong>CPU运行安全等级</strong></h2><p>CPU有4个运行级别，分别为：</p>
<ul>
<li>ring0</li>
<li>ring1</li>
<li>ring2</li>
<li>ring3</li>
</ul>
<p>Linux与Windows只用到了2个级别:ring0、ring3，操作系统内部内部程序指令通常运行在ring0级别，操作系统以外的第三方程序运行在ring3级别，第三方程序如果要调用操作系统内部函数功能，由于运行安全级别不够,必须切换CPU运行状态，从ring3切换到ring0,然后执行系统函数，说到这里相信同学们明白为什么JVM创建线程，线程阻塞唤醒是重型操作了，因为CPU要切换运行状态。</p>
<p>下面我大概梳理一下JVM创建线程CPU的工作过程</p>
<p>step1：CPU从ring3切换ring0创建线程</p>
<p>step2：创建完毕,CPU从ring0切换回ring3</p>
<p>step3：线程执行JVM程序</p>
<p>step4：线程执行完毕，销毁还得切回ring0</p>
<p>讲完了CPU部分，我们来看下内存部分。</p>
<h1 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a><strong>操作系统内存管理</strong></h1><hr>
<h2 id="执行空间保护"><a href="#执行空间保护" class="headerlink" title="执行空间保护"></a><strong>执行空间保护</strong></h2><p>操作系统有用户空间与内核空间两个概念，目的也是为了做到程序运行安全隔离与稳定，以32位操作系统4G大小的内存空间为例</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%284%29.png" alt="0"></p>
<p>Linux为内核代码和数据结构预留了几个页框，这些页永远不会被转出到磁盘上。从 0x00000000 到 0xC0000000（PAGE_OFFSET） 的线性地址可由用户代码 和 内核代码进行引用（<strong>即用户空间</strong>）。从0xC0000000（PAGE_OFFSET）到 0xFFFFFFFFF的线性地址只能由内核代码进行访问（<strong>即内核空间</strong>）。内核代码及其数据结构都必须位于这 1 GB的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址的虚拟映射。</p>
<p>这意味着在 4 GB 的内存空间中，只有 3 GB 可以用于用户应用程序。进程与线程只能运行在用户方式（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。在这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈(用户空间的堆栈)，而内核方式下用的是固定大小的堆栈（内核空间的对战，一般为一个内存页的大小），即每个进程与线程其实有两个堆栈，分别运行与用户态与内核态。</p>
<p>由空间划分我们再引深一下，CPU调度的基本单位线程，也划分为：</p>
<p><strong>1、内核线程模型(KLT)</strong></p>
<p><strong>2、用户线程模型(ULT)</strong></p>
<h3 id="内核线程模型"><a href="#内核线程模型" class="headerlink" title="内核线程模型"></a><strong>内核线程模型</strong></h3><p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%285%29.png" alt="0"></p>
<p>内核线程(KLT)：系统内核管理线程(KLT),内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。在多处理器系统上，多线程在多处理器上并行运行。线程的创建、调度和管理由内核完成，效率比ULT要慢，比进程操作快。 </p>
<h3 id="用户线程模型"><a href="#用户线程模型" class="headerlink" title="用户线程模型"></a><strong>用户线程模型</strong></h3><p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%286%29.png" alt="0"></p>
<p>用户线程(ULT)：用户程序实现,不依赖操作系统核心,应用提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态&#x2F;内核态切换，速度快。内核对ULT无感知，线程阻塞则进程（包括它的所有线程）阻塞。</p>
<p><strong>到这里，大家不妨思考一下，jvm是采用的哪一种线程模型？</strong></p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h1><p><strong>什么是进程？</strong></p>
<p>现代操作系统在运行一个程序时，会为其创建一个进程；例如，启动一个Java程序，操作系统就会创建一个Java进程。进程是OS(操作系统)资源分配的最小单位。</p>
<p><strong>什么是线程？</strong></p>
<p>线程是OS(操作系统)调度CPU的最小单元，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。CPU在这些线程上高速切换，让使用者感觉到这些线程在同时执行，即并发的概念，相似的概念还有并行！</p>
<p>线程上下文切换过程：</p>
<p>​    <img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/clipboard%20%287%29.png" alt="0"></p>
<h2 id="虚拟机指令集架构"><a href="#虚拟机指令集架构" class="headerlink" title="虚拟机指令集架构"></a><strong>虚拟机指令集架构</strong></h2><hr>
<p>虚拟机指令集架构主要分两种：</p>
<p>1、栈指令集架构</p>
<p>2、寄存器指令集架构</p>
<p>关于指令集架构的wiki详细说明：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B</a></p>
<h2 id="栈指令集架构"><a href="#栈指令集架构" class="headerlink" title="栈指令集架构"></a><strong>栈指令集架构</strong></h2><ol>
<li>设计和实现更简单,适用于资源受限的系统;</li>
<li>避开了寄存器的分配难题:使用零地址指令方式分配;</li>
<li>指令流中的指令大部分是零地址指令,其执行过程依赖与操作栈,指令集更小,编译器容易实现;</li>
<li>不需要硬件支持,可移植性更好,更好实现跨平台。</li>
</ol>
<h2 id="寄存器指令集架构"><a href="#寄存器指令集架构" class="headerlink" title="寄存器指令集架构"></a><strong>寄存器指令集架构</strong></h2><ol>
<li>典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件,可移植性差。</li>
<li>性能优秀和执行更高效。</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下,基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主,而基于栈式架构的指令集却是以零地址指令为主。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/RocketMQ%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">RocketMQ开发模型</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 19:15:12" itemprop="dateCreated datePublished" datetime="2022-03-08T19:15:12+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-10 22:54:43" itemprop="dateModified" datetime="2022-03-10T22:54:43+08:00">2022-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、RocketMQ原生API使用"><a href="#一、RocketMQ原生API使用" class="headerlink" title="一、RocketMQ原生API使用"></a>一、RocketMQ原生API使用</h1><p> 使用RocketMQ的原生API开发是最简单也是目前看来最牢靠的方式。这里我们用SpringBoot来搭建一系列消息生产者和消息消费者，来访问我们之前搭建的RocketMQ集群。</p>
<h2 id="1、测试环境搭建"><a href="#1、测试环境搭建" class="headerlink" title="1、测试环境搭建"></a>1、测试环境搭建</h2><p> 首先创建一个基于Maven的SpringBoot工程，引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 另外还与一些依赖，例如openmessage、acl等扩展功能还需要添加对应的依赖。具体可以参见RocketMQ源码中的example模块。在RocketMQ源码包中的example模块提供了非常详尽的测试代码，也可以拿来直接调试。我们这里就用源码包中的示例来连接我们自己搭建的RocketMQ集群来进行演示。</p>
<blockquote>
<p>RocketMQ的官网上有很多经典的测试代码，这些代码虽然依赖的版本比较老，但是还是都可以运行的。所以我们还是以官网上的顺序进行学习。</p>
</blockquote>
<p> 但是在调试这些代码的时候要注意一个问题：这些测试代码中的生产者和消费者都需要依赖NameServer才能运行，只需要将NameServer指向我们自己搭建的RocketMQ集群，而不需要管Broker在哪里，就可以连接我们自己的自己的RocketMQ集群。而RocketMQ提供的生产者和消费者寻找NameServer的方式有两种：</p>
<p> 1、在代码中指定namesrvAddr属性。例如：consumer.setNamesrvAddr(“127.0.0.1:9876”);</p>
<p> 2、通过NAMESRV_ADDR环境变量来指定。多个NameServer之间用分号连接。</p>
<h2 id="2、RocketMQ的编程模型"><a href="#2、RocketMQ的编程模型" class="headerlink" title="2、RocketMQ的编程模型"></a>2、RocketMQ的编程模型</h2><p> 然后RocketMQ的生产者和消费者的编程模型都是有个比较固定的步骤的，掌握这个固定的步骤，对于我们学习源码以及以后使用都是很有帮助的。</p>
<ul>
<li><p>消息发送者的固定步骤</p>
<p>1.创建消息生产者producer，并制定生产者组名<br>2.指定Nameserver地址<br>3.启动producer<br>4.创建消息对象，指定主题Topic、Tag和消息体<br>5.发送消息<br>6.关闭生产者producer</p>
</li>
<li><p>消息消费者的固定步骤</p>
<p>1.创建消费者Consumer，制定消费者组名<br>2.指定Nameserver地址<br>3.订阅主题Topic和Tag<br>4.设置回调函数，处理消息<br>5.启动消费者consumer</p>
</li>
</ul>
<h2 id="3、RocketMQ的消息样例"><a href="#3、RocketMQ的消息样例" class="headerlink" title="3、RocketMQ的消息样例"></a>3、RocketMQ的消息样例</h2><p> 那我们来逐一连接下RocketMQ都支持哪些类型的消息：</p>
<h3 id="3-1-基本样例"><a href="#3-1-基本样例" class="headerlink" title="3.1 基本样例"></a>3.1 基本样例</h3><p> 基本样例部分我们使用消息生产者分别通过三种方式发送消息，同步发送、异步发送以及单向发送。</p>
<p> 然后使用消费者来消费这些消息。</p>
<p> 1、同步发送消息的样例见：org.apache.rocketmq.example.simple.Producer</p>
<blockquote>
<p>等待消息返回后再继续进行下面的操作。</p>
</blockquote>
<p> 2、异步发送消息的样例见：org.apache.rocketmq.example.simple.AsyncProducer</p>
<blockquote>
<p>这个示例有个比较有趣的地方就是引入了一个countDownLatch来保证所有消息回调方法都执行完了再关闭Producer。 所以从这里可以看出，RocketMQ的Producer也是一个服务端，在往Broker发送消息的时候也要作为服务端提供服务。</p>
</blockquote>
<p> 3、单向发送消息的样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Wait for sending to complete</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);        </span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关键点就是使用producer.sendOneWay方式来发送消息，这个方法没有返回值，也没有回调。就是只管把消息发出去就行了。</p>
</blockquote>
<p> 4、使用消费者消费消息。</p>
<p> 消费者消费消息有两种模式，一种是消费者主动去Broker上拉取消息的拉模式，另一种是消费者等待Broker把消息推送过来的推模式。</p>
<p> 拉模式的样例见：org.apache.rocketmq.example.simple.PullConsumer</p>
<p> 推模式的样例见：org.apache.rocketmq.example.simple.PushConsumer</p>
<blockquote>
<p>通常情况下，用推模式比较简单。</p>
<p>实际上RocketMQ的推模式也是由拉模式封装出来的。</p>
<p>4.7.1版本中DefaultMQPullConsumerImpl这个消费者类已标记为过期，但是还是可以使用的。替换的类是DefaultLitePullConsumerImpl。</p>
</blockquote>
<h3 id="3-2-顺序消息"><a href="#3-2-顺序消息" class="headerlink" title="3.2 顺序消息"></a>3.2 顺序消息</h3><p>顺序消息生产者样例见：org.apache.rocketmq.example.order.Producer</p>
<p>顺序消息消费者样例见：org.apache.rocketmq.example.order.Consumer</p>
<blockquote>
<p>验证时，可以启动多个Consumer实例，观察下每一个订单的消息分配以及每个订单下多个步骤的消费顺序。</p>
<p>不管订单在多个Consumer实例之前是如何分配的，每个订单下的多条消息顺序都是固定从0~5的。</p>
<p>RocketMQ保证的是消息的局部有序，而不是全局有序。</p>
</blockquote>
<blockquote>
<p>先从控制台上看下List<MessageQueue> mqs是什么。</p>
<p>再回看我们的样例，实际上，RocketMQ也只保证了每个OrderID的所有消息有序(发到了同一个queue)，而并不能保证所有消息都有序。所以这就涉及到了RocketMQ消息有序的原理。要保证最终消费到的消息是有序的，需要从Producer、Broker、Consumer三个步骤都保证消息有序才行。</p>
<p>首先在发送者端：在默认情况下，消息发送者会采取Round Robin轮询方式把消息发送到不同的MessageQueue(分区队列)，而消费者消费的时候也从多个MessageQueue上拉取消息，这种情况下消息是不能保证顺序的。而只有当一组有序的消息发送到同一个MessageQueue上时，才能利用MessageQueue先进先出的特性保证这一组消息有序。</p>
<p>而Broker中一个队列内的消息是可以保证有序的。</p>
<p>然后在消费者端：消费者会从多个消息队列上去拿消息。这时虽然每个消息队列上的消息是有序的，但是多个队列之间的消息仍然是乱序的。消费者端要保证消息有序，就需要按队列一个一个来取消息，即取完一个队列的消息后，再去取下一个队列的消息。而给consumer注入的MessageListenerOrderly对象，在RocketMQ内部就会通过锁队列的方式保证消息是一个一个队列来取的。MessageListenerConcurrently这个消息监听器则不会锁队列，每次都是从多个Message中取一批数据（默认不超过32条）。因此也无法保证消息有序。</p>
</blockquote>
<h3 id="3-3-广播消息"><a href="#3-3-广播消息" class="headerlink" title="3.3 广播消息"></a>3.3 广播消息</h3><p> 广播消息的消息生产者样例见：org.apache.rocketmq.example.broadcast.PushConsumer</p>
<blockquote>
<p>广播消息并没有特定的消息消费者样例，这是因为这涉及到消费者的集群消费模式。在集群状态(MessageModel.CLUSTERING)下，每一条消息只会被同一个消费者组中的一个实例消费到(这跟kafka和rabbitMQ的集群模式是一样的)。而广播模式则是把消息发给了所有订阅了对应主题的消费者，而不管消费者是不是同一个消费者组。</p>
</blockquote>
<h3 id="3-4-延迟消息"><a href="#3-4-延迟消息" class="headerlink" title="3.4 延迟消息"></a>3.4 延迟消息</h3><p> 延迟消息的生产者案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledMessageProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Instantiate a producer to send scheduled messages</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// Launch producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">            <span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// Send the message</span></span><br><span class="line">            producer.send(message);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// Shutdown producer after use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>延迟消息实现的效果就是在调用producer.send方法后，消息并不会立即发送出去，而是会等一段时间再发送出去。这是RocketMQ特有的一个功能。</p>
<p>那会延迟多久呢？延迟时间的设置就是在Message消息对象上设置一个延迟级别message.setDelayTimeLevel(3);</p>
<p>开源版本的RocketMQ中，对延迟消息并不支持任意时间的延迟设定(商业版本中支持)，而是只支持18个固定的延迟级别，1到18分别对应messageDelayLevel&#x3D;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。这从哪里看出来的？其实从rocketmq-console控制台就能看出来。而这18个延迟级别也支持自行定义，不过一般情况下最好不要自定义修改。</p>
<p>那这么好用的延迟消息是怎么实现的？这18个延迟级别除了在延迟消息中用，还有什么地方用到了？别急，我们会在后面部分进行详细讲解。</p>
</blockquote>
<h3 id="3-5-批量消息"><a href="#3-5-批量消息" class="headerlink" title="3.5 批量消息"></a>3.5 批量消息</h3><p>批量消息是指将多条消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。</p>
<p>批量消息的消息生产者样例见：org.apache.rocketmq.example.batch.SimpleBatchProducer和org.apache.rocketmq.example.batch.SplitBatchProducer</p>
<blockquote>
<p>相信大家在官网以及测试代码中都看到了关键的注释：如果批量消息大于1MB就不要用一个批次发送，而要拆分成多个批次消息发送。也就是说，一个批次消息的大小不要超过1MB</p>
<p>实际使用时，这个1MB的限制可以稍微扩大点，实际最大的限制是4194304字节，大概4MB。但是使用批量消息时，这个消息长度确实是必须考虑的一个问题。而且批量消息的使用是有一定限制的，这些消息应该有相同的Topic，相同的waitStoreMsgOK。而且不能是延迟消息、事务消息等。</p>
</blockquote>
<h3 id="3-6-过滤消息"><a href="#3-6-过滤消息" class="headerlink" title="3.6 过滤消息"></a>3.6 过滤消息</h3><p>在大多数情况下，可以使用Message的Tag属性来简单快速的过滤信息。</p>
<p>使用Tag过滤消息的消息生产者案例见：org.apache.rocketmq.example.filter.TagFilterProducer</p>
<p>使用Tag过滤消息的消息消费者案例见：org.apache.rocketmq.example.filter.TagFilterConsumer</p>
<blockquote>
<p>主要是看消息消费者。consumer.subscribe(“TagFilterTest”, “TagA || TagC”); 这句只订阅TagA和TagC的消息。</p>
<p>TAG是RocketMQ中特有的一个消息属性。RocketMQ的最佳实践中就建议，使用RocketMQ时，一个应用可以就用一个Topic，而应用中的不同业务就用TAG来区分。</p>
</blockquote>
<p>但是，这种方式有一个很大的限制，就是一个消息只能有一个TAG，这在一些比较复杂的场景就有点不足了。 这时候，可以使用SQL表达式来对消息进行过滤。</p>
<p>SQL过滤的消息生产者案例见：org.apache.rocketmq.example.filter.SqlFilterProducer</p>
<p>SQL过滤的消息消费者案例见：org.apache.rocketmq.example.filter.SqlFilterConsumer</p>
<blockquote>
<p>这个模式的关键是在消费者端使用MessageSelector.bySql(String sql)返回的一个MessageSelector。这里面的sql语句是按照SQL92标准来执行的。sql中可以使用的参数有默认的TAGS和一个在生产者中加入的a属性。</p>
<p>SQL92语法：</p>
<p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p>
<ul>
<li>数值比较，比如：**&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;；**</li>
<li>字符比较，比如：**&#x3D;，&lt;&gt;，IN；**</li>
<li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li>
<li>逻辑符号 <strong>AND，OR，NOT；</strong></li>
</ul>
<p>常量支持类型为：</p>
<ul>
<li>数值，比如：<strong>123，3.1415；</strong></li>
<li>字符，比如：**’abc’，必须用单引号包裹起来；**</li>
<li><strong>NULL</strong>，特殊的常量</li>
<li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li>
</ul>
<p>使用注意：只有推模式的消费者可以使用SQL过滤。拉模式是用不了的。</p>
</blockquote>
<blockquote>
<p>大家想一下，这个消息过滤是在Broker端进行的还是在Consumer端进行的？</p>
</blockquote>
<h3 id="3-7-事务消息"><a href="#3-7-事务消息" class="headerlink" title="3.7 事务消息"></a>3.7 事务消息</h3><p>这个事务消息是RocketMQ提供的一个非常有特色的功能，需要着重理解。</p>
<p> <strong>首先</strong>，我们了解下什么是事务消息。官网的介绍是：事务消息是在分布式系统中保证最终一致性的两阶段提交的消息实现。他可以保证本地事务执行与消息发送两个操作的原子性，也就是这两个操作一起成功或者一起失败。</p>
<p> <strong>其次</strong>，我们来理解下事务消息的编程模型。事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性，因此，事务消息的示例只涉及到消息发送者，对于消息消费者来说，并没有什么特别的。</p>
<p>事务消息生产者的案例见：org.apache.rocketmq.example.transaction.TransactionProducer</p>
<blockquote>
<p>事务消息的关键是在TransactionMQProducer中指定了一个TransactionListener事务监听器，这个事务监听器就是事务消息的关键控制器。源码中的案例有点复杂，我这里准备了一个更清晰明了的事务监听器示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"> <span class="comment">//在提交完事务消息后执行。</span></span><br><span class="line"> <span class="comment">//返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。</span></span><br><span class="line"> <span class="comment">//返回ROLLBACK_MESSAGE状态的消息会被丢弃。</span></span><br><span class="line"> <span class="comment">//返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> msg.getTags();</span><br><span class="line">        <span class="comment">//TagA的消息会立即被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagB的消息会被丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//其他消息会等待Broker进行事务状态回查。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//在对UNKNOWN状态的消息进行状态回查时执行。返回的结果是一样的。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> msg.getTags();</span><br><span class="line">        <span class="comment">//TagC的消息过一段时间会被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagC&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        <span class="comment">//TagD的消息也会在状态回查时被丢弃掉</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagD&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        <span class="comment">//剩下TagE的消息会在多次状态回查后最终丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>然后</strong>，我们要了解下事务消息的使用限制：</p>
<p> 1、事务消息不支持延迟消息和批量消息。</p>
<p> 2、为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N &#x3D; <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</p>
<blockquote>
<p>回查次数是由BrokerConfig.transactionCheckMax这个参数来配置的，默认15次，可以在broker.conf中覆盖。<br>然后实际的检查次数会在message中保存一个用户属性MessageConst.PROPERTY_TRANSACTION_CHECK_TIMES。这个属性值大于transactionCheckMax，就会丢弃。 这个用户属性值会按回查次数递增，也可以在Producer中自行覆盖这个属性。</p>
</blockquote>
<p> 3、事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</p>
<blockquote>
<p>由BrokerConfig.transactionTimeOut这个参数来配置。默认6秒，可以在broker.conf中进行修改。<br>另外，也可以给消息配置一个MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS属性来给消息指定一个特定的消息回查时间。<br>msg.putUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS, “10000”); 这样就是10秒。</p>
</blockquote>
<p> 4、事务性消息可能不止一次被检查或消费。</p>
<p> 5、提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</p>
<p> 6、事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</p>
<p> <strong>接下来</strong>，我们还要了解下事务消息的实现机制，参见下图：</p>
<p><img src="https://picture-manager.oss-cn-hangzhou.aliyuncs.com/Blog_Img/JMM/rocketmq.png" alt="RocketMQ事务消息"></p>
<p> 事务消息机制的关键是在发送消息时，会将消息转为一个half半消息，并存入RocketMQ内部的一个 RMQ_SYS_TRANS_HALF_TOPIC 这个Topic，这样对消费者是不可见的。再经过一系列事务检查通过后，再将消息转存到目标Topic，这样对消费者就可见了。</p>
<p> <strong>最后</strong>，我们还需要思考下事务消息的作用。</p>
<p> 大家想一下这个事务消息跟分布式事务有什么关系？为什么扯到了分布式事务相关的两阶段提交上了？事务消息只保证了发送者本地事务和发送消息这两个操作的原子性，但是并不保证消费者本地事务的原子性，所以，事务消息只保证了分布式事务的一半。但是即使这样，<strong>对于复杂的分布式事务，RocketMQ提供的事务消息也是目前业内最佳的降级方案</strong>。</p>
<h3 id="3-8-ACL权限控制"><a href="#3-8-ACL权限控制" class="headerlink" title="3.8 ACL权限控制"></a>3.8 ACL权限控制</h3><p> 权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制。用户在使用RocketMQ权限控制时，可以在Client客户端通过 RPCHook注入AccessKey和SecretKey签名；同时，将对应的权限控制属性（包括Topic访问权限、IP白名单和AccessKey和SecretKey签名等）设置在$ROCKETMQ_HOME&#x2F;conf&#x2F;plain_acl.yml的配置文件中。Broker端对AccessKey所拥有的权限进行校验，校验不过，抛出异常； ACL客户端可以参考：<strong>org.apache.rocketmq.example.simple</strong>包下面的<strong>AclClient</strong>代码。</p>
<blockquote>
<p>注意，如果要在自己的客户端中使用RocketMQ的ACL功能，还需要引入一个单独的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;rocketmq-acl&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.7.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p> 而Broker端具体的配置信息可以参见源码包下docs&#x2F;cn&#x2F;acl&#x2F;user_guide.md。主要是在broker.conf中打开acl的标志：aclEnable&#x3D;true。然后就可以用plain_acl.yml来进行权限配置了。并且这个配置文件是热加载的，也就是说要修改配置时，只要修改配置文件就可以了，不用重启Broker服务。我们来简单分析下源码中的plan_acl.yml的配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局白名单，不受ACL控制</span></span><br><span class="line"><span class="comment">#通常需要将主从架构中的所有节点加进来</span></span><br><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.10</span><span class="number">.103</span><span class="string">.*</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">192.168</span><span class="number">.0</span><span class="string">.*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line"><span class="comment">#第一个账户</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span> <span class="comment">#默认Topic访问策略是拒绝</span></span><br><span class="line">  <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span> <span class="comment">#默认Group访问策略是只允许订阅</span></span><br><span class="line">  <span class="attr">topicPerms:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicA=DENY</span> <span class="comment">#topicA拒绝</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicB=PUB|SUB</span> <span class="comment">#topicB允许发布和订阅消息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">topicC=SUB</span> <span class="comment">#topicC只允许订阅</span></span><br><span class="line">  <span class="attr">groupPerms:</span></span><br><span class="line">  <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupA=DENY</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupB=PUB|SUB</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">groupC=SUB</span></span><br><span class="line"><span class="comment">#第二个账户，只要是来自192.168.1.*的IP，就可以访问所有资源</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">rocketmq2</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span> <span class="number">192.168</span><span class="number">.1</span><span class="string">.*</span></span><br><span class="line">  <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="二、SpringBoot整合RocketMQ"><a href="#二、SpringBoot整合RocketMQ" class="headerlink" title="二、SpringBoot整合RocketMQ"></a>二、SpringBoot整合RocketMQ</h1><h2 id="1、快速实战"><a href="#1、快速实战" class="headerlink" title="1、快速实战"></a>1、快速实战</h2><p>这部分我们看下SpringBoot如何快速集成RocketMQ。</p>
<blockquote>
<p>在使用SpringBoot的starter集成包时，要特别注意版本。因为SpringBoot集成RocketMQ的starter依赖是由Spring社区提供的，目前正在快速迭代的过程当中，不同版本之间的差距非常大，甚至基础的底层对象都会经常有改动。例如如果使用rocketmq-spring-boot-starter:2.0.4版本开发的代码，升级到目前最新的rocketmq-spring-boot-starter:2.1.1后，基本就用不了了。</p>
</blockquote>
<p>我们创建一个maven工程，引入关键依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>rocketmq-spring-boot-starter:2.1.1引入的SpringBoot包版本是2.0.5.RELEASE，这里把SpringBoot的依赖包升级了一下。</p>
</blockquote>
<p>然后我们以SpringBoot的方式，快速创建一个简单的Demo</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMQScApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RocketMQScApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件 application.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#NameServer地址</span></span><br><span class="line"><span class="attr">rocketmq.name-server</span>=<span class="string">192.168.232.128:9876</span></span><br><span class="line"><span class="comment">#默认的消息生产者组</span></span><br><span class="line"><span class="attr">rocketmq.producer.group</span>=<span class="string">springBootGroup</span></span><br></pre></td></tr></table></figure>

<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"> <span class="comment">//发送普通消息的示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String topic,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.rocketMQTemplate.convertAndSend(topic,msg);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//发送事务消息的示例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageInTransaction</span><span class="params">(String topic,String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build();</span><br><span class="line">            <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span>topic+<span class="string">&quot;:&quot;</span>+tags[i % tags.length];</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.sendMessageInTransaction(destination, message,destination);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQMessageListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;MyConsumerGroup&quot;, topic = &quot;TestTopic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message : &quot;</span>+ message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SpringBoot集成RocketMQ，消费者部分的核心就在这个@RocketMQMessageListener注解上。所有消费者的核心功能也都会集成到这个注解中。所以我们还要注意下这个注解里面的属性：</p>
<p>例如：消息过滤可以由里面的selectorType属性和selectorExpression来定制</p>
<p>消息有序消费还是并发消费则由consumeMode属性定制。</p>
<p>消费者是集群部署还是广播部署由messageModel属性定制。</p>
</blockquote>
<p>然后关于事务消息，还需要配置一个事务消息监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.rocket.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.annotation.RocketMQTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.core.RocketMQLocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.spring.support.RocketMQUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.converter.StringMessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/11/5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(rocketMQTemplateBeanName = &quot;rocketMQTemplate&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTransactionImpl</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Object, String&gt; localTrans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">id</span> <span class="operator">=</span> msg.getHeaders().get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">destination</span> <span class="operator">=</span> arg.toString();</span><br><span class="line">        localTrans.put(id,destination);</span><br><span class="line">        org.apache.rocketmq.common.message.<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> RocketMQUtil.convertToRocketMessage(<span class="keyword">new</span> <span class="title class_">StringMessageConverter</span>(),<span class="string">&quot;UTF-8&quot;</span>,destination, msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> message.getTags();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.UNKNOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">//SpringBoot的消息对象中，并没有transactionId这个属性。跟原生API不一样。</span></span><br><span class="line"><span class="comment">//        String destination = localTrans.get(msg.getTransactionId());</span></span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们启动应用后，就能够通过访问 <a target="_blank" rel="noopener" href="http://localhost:8080/MQTest/sendMessage?message=123">http://localhost:8080/MQTest/sendMessage?message=123</a> 接口来发送一条简单消息。并在SpringConsumer中消费到。</p>
<p>也可以通过访问<a target="_blank" rel="noopener" href="http://localhost:8080/MQTest/sendTransactionMessage?message=123">http://localhost:8080/MQTest/sendTransactionMessage?message=123</a> ，来发送一条事务消息。</p>
<blockquote>
<p>这里可以看到，对事务消息，SpringBoot进行封装时，就缺少了transactionId，这在事务控制中是非常关键的。</p>
</blockquote>
<h2 id="2、其他更多消息类型："><a href="#2、其他更多消息类型：" class="headerlink" title="2、其他更多消息类型："></a>2、其他更多消息类型：</h2><p>对于其他的消息类型，文档中就不一一记录了。具体可以参见源码中的junit测试案例。</p>
<h2 id="3、总结："><a href="#3、总结：" class="headerlink" title="3、总结："></a>3、总结：</h2><ul>
<li>SpringBoot 引入org.apache.rocketmq:rocketmq-spring-boot-starter依赖后，就可以通过内置的RocketMQTemplate来与RocketMQ交互。相关属性都以rockemq.开头。具体所有的配置信息可以参见org.apache.rocketmq.spring.autoconfigure.RocketMQProperties这个类。</li>
<li>SpringBoot依赖中的Message对象和RocketMQ-client中的Message对象是两个不同的对象，这在使用的时候要非常容易弄错。例如RocketMQ-client中的Message里的TAG属性，在SpringBoot依赖中的Message中就没有。Tag属性被移到了发送目标中，与Topic一起，以Topic:Tag的方式指定。</li>
<li>最后强调一次，一定要注意版本。rocketmq-spring-boot-starter的更新进度一般都会略慢于RocketMQ的版本更新，并且版本不同会引发很多奇怪的问题。apache有一个官方的rocketmq-spring示例，地址：<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq-spring.git">https://github.com/apache/rocketmq-spring.git</a> 以后如果版本更新了，可以参考下这个示例代码。</li>
</ul>
<h1 id="三、SpringCloudStream整合RocketMQ"><a href="#三、SpringCloudStream整合RocketMQ" class="headerlink" title="三、SpringCloudStream整合RocketMQ"></a>三、SpringCloudStream整合RocketMQ</h1><p> SpringCloudStream是Spring社区提供的一个统一的消息驱动框架，目的是想要以一个统一的编程模型来对接所有的MQ消息中间件产品。我们还是来看看SpringCloudStream如何来集成RocketMQ。</p>
<h2 id="1、快速实战-1"><a href="#1、快速实战-1" class="headerlink" title="1、快速实战"></a>1、快速实战</h2><p> 创建Maven工程，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-acl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>应用启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@EnableBinding(&#123;Source.class, Sink.class&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScRocketMQApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ScRocketMQApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这个@EnableBinding({Source.class, Sink.class})注解，这是SpringCloudStream引入的Binder配置。</p>
</blockquote>
<p>然后增加配置文件application.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ScStream通用的配置以spring.cloud.stream开头</span></span><br><span class="line"><span class="attr">spring.cloud.stream.bindings.input.destination</span>=<span class="string">TestTopic</span></span><br><span class="line"><span class="attr">spring.cloud.stream.bindings.input.group</span>=<span class="string">scGroup</span></span><br><span class="line"><span class="attr">spring.cloud.stream.bindings.output.destination</span>=<span class="string">TestTopic</span></span><br><span class="line"><span class="comment">#rocketMQ的个性化配置以spring.cloud.stream.rocketmq开头</span></span><br><span class="line"><span class="comment">#spring.cloud.stream.rocketmq.binder.name-server=192.168.232.128:9876;192.168.232.129:9876;192.168.232.130:9876</span></span><br><span class="line"><span class="attr">spring.cloud.stream.rocketmq.binder.name-server</span>=<span class="string">192.168.232.128:9876</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>SpringCloudStream中，一个binding对应一个消息通道。这其中配置的input，是在Sink.class中定义的，对应一个消息消费者。而output，是在Source.class中定义的，对应一个消息生产者。</p>
</blockquote>
<p>然后就可以增加消息消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.StreamListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Sink;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String messsage)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;received message:&quot;</span>+messsage+<span class="string">&quot; from binding:&quot;</span>+ Sink.INPUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageConst;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headers.put(MessageConst.PROPERTY_TAGS, <span class="string">&quot;testTag&quot;</span>);</span><br><span class="line">        <span class="type">MessageHeaders</span> <span class="variable">messageHeaders</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageHeaders</span>(headers);</span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder.createMessage(msg, messageHeaders);</span><br><span class="line">        <span class="built_in">this</span>.source.output().send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后增加一个Controller类用于测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.roy.scrocket.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.roy.scrocket.basic.ScProducer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：楼兰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2020/10/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/MQTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQTestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ScProducer producer;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        producer.sendMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息发送完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动应用后，就可以访问<a target="_blank" rel="noopener" href="http://localhost:8080/MQTest/sendMessage?message=123%EF%BC%8C%E7%BB%99RocketMQ%E5%8F%91%E9%80%81%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E5%88%B0TestTopic%EF%BC%8C%E5%B9%B6%E5%9C%A8ScConsumer%E4%B8%AD%E6%B6%88%E8%B4%B9%E5%88%B0%E4%BA%86%E3%80%82">http://localhost:8080/MQTest/sendMessage?message=123，给RocketMQ发送一条消息到TestTopic，并在ScConsumer中消费到了。</a></p>
<h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><ul>
<li>关于SpringCloudStream。这是一套几乎通用的消息中间件编程框架，例如从对接RocketMQ换到对接Kafka，业务代码几乎不需要动，只需要更换pom依赖并且修改配置文件就行了。但是，由于各个MQ产品都有自己的业务模型，差距非常大，所以使用使用SpringCloudStream时要注意业务模型转换。并且在实际使用中，要非常注意各个MQ的个性化配置属性。例如RocketMQ的个性化属性都是以spring.cloud.stream.rocketmq开头，只有通过这些属性才能用上RocketMQ的延迟消息、排序消息、事务消息等个性化功能。</li>
<li>SpringCloudStream是Spring社区提供的一套统一框架，但是官方目前只封装了kafka、kafka Stream、RabbitMQ的具体依赖。而RocketMQ的依赖是交由厂商自己维护的，也就是由阿里巴巴自己来维护。这个维护力度显然是有不小差距的。所以一方面可以看到之前在使用SpringBoot时着重强调的版本问题，在使用SpringCloudStream中被放大了很多。spring-cloud-starter-stream-rocketmq目前最新的2.2.3.RELEASE版本中包含的rocketmq-client版本还是4.4.0。这个差距就非常大了。另一方面，RocketMQ这帮大神不屑于写文档的问题也特别严重，SpringCloudStream中关于RocketMQ的个性化配置几乎很难找到完整的文档。</li>
<li>总之，对于RocketMQ来说，SpringCloudStream目前来说还并不是一个非常好的集成方案。这方面跟kafka和Rabbit还没法比。所以使用时要慎重。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/RocketMQ%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/RocketMQ%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">RocketMQ介绍</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-08 19:12:56" itemprop="dateCreated datePublished" datetime="2022-03-08T19:12:56+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:51:09" itemprop="dateModified" datetime="2022-03-13T10:51:09+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、MQ介绍"><a href="#一、MQ介绍" class="headerlink" title="一、MQ介绍"></a>一、MQ介绍</h1><h2 id="1、什么是MQ？为什么要用MQ？"><a href="#1、什么是MQ？为什么要用MQ？" class="headerlink" title="1、什么是MQ？为什么要用MQ？"></a>1、什么是MQ？为什么要用MQ？</h2><p>MQ：MessageQueue，消息队列。 队列，是一种FIFO 先进先出的数据结构。消息由生产者发送到MQ进行排队，然后按原来的顺序交由消息的消费者进行处理。QQ和微信就是典型的MQ。</p>
<p>MQ的作用主要有以下三个方面：</p>
<ul>
<li><p>异步</p>
<p>例子：快递员发快递，直接到客户家效率会很低。引入菜鸟驿站后，快递员只需要把快递放到菜鸟驿站，就可以继续发其他快递去了。客户再按自己的时间安排去菜鸟驿站取快递。</p>
<p>作用：异步能提高系统的响应速度、吞吐量。</p>
</li>
<li><p>解耦</p>
<p>例子：《Thinking in JAVA》很经典，但是都是英文，我们看不懂，所以需要编辑社，将文章翻译成其他语言，这样就可以完成英语与其他语言的交流。</p>
<p>作用：</p>
<p>1、服务之间进行解耦，才可以减少服务之间的影响。提高系统整体的稳定性以及可扩展性。</p>
<p>2、另外，解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行消费，并且消费者的增加或者减少对生产者没有影响。</p>
</li>
<li><p>削峰</p>
<p>例子：长江每年都会涨水，但是下游出水口的速度是基本稳定的，所以会涨水。引入三峡大坝后，可以把水储存起来，下游慢慢排水。</p>
<p>作用：以稳定的系统资源应对突发的流量冲击。</p>
</li>
</ul>
<h2 id="2、MQ的优缺点"><a href="#2、MQ的优缺点" class="headerlink" title="2、MQ的优缺点"></a>2、MQ的优缺点</h2><p> 上面MQ的所用也就是使用MQ的优点。 但是引入MQ也是有他的缺点的：</p>
<ul>
<li>系统可用性降低</li>
</ul>
<p>系统引入的外部依赖增多，系统的稳定性就会变差。一旦MQ宕机，对业务会产生影响。这就需要考虑如何保证MQ的高可用。</p>
<ul>
<li>系统复杂度提高</li>
</ul>
<p>引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变为异步调用，数据的链路就会变得更复杂。并且还会带来其他一些问题。比如：如何保证消费不会丢失？不会被重复调用？怎么保证消息的顺序性等问题。</p>
<ul>
<li>消息一致性问题</li>
</ul>
<p>A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统处理成功，C系统处理失败怎么办？这就需要考虑如何保证消息数据处理的一致性。</p>
<h2 id="3、几大MQ产品特点比较"><a href="#3、几大MQ产品特点比较" class="headerlink" title="3、几大MQ产品特点比较"></a>3、几大MQ产品特点比较</h2><p> 常用的MQ产品包括Kafka、RabbitMQ和RocketMQ。我们对这三个产品做下简单的比较，重点需要理解他们的适用场景。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9a677e8cbccb2808802d608abe2b8a8d/710A1EF3885B44C5A953162F8FAEF048?ynotemdtimestamp=1646737866265" alt="MQ产品比较"></p>
<p>另外，关于这三大产品更详细的比较，可以参见《kafka vs rabbitmq vs rocketmq.pdf》</p>
<h1 id="二、RocketMQ快速实战"><a href="#二、RocketMQ快速实战" class="headerlink" title="二、RocketMQ快速实战"></a>二、RocketMQ快速实战</h1><p> RocketMQ是阿里巴巴开源的一个消息中间件，在阿里内部历经了双十一等很多高并发场景的考验，能够处理亿万级别的消息。2016年开源后捐赠给Apache，现在是Apache的一个顶级项目。</p>
<p> 目前RocketMQ在阿里云上有一个购买即可用的商业版本，商业版本集成了阿里内部一些更深层次的功能及运维定制。我们这里学习的是Apache的开源版本。开源版本相对于阿里云上的商业版本，功能上略有缺失，但是大体上功能是一样的。</p>
<p> RocketMQ的官网地址： <a target="_blank" rel="noopener" href="http://rocketmq.apache.org/">http://rocketmq.apache.org</a> ，github地址是 <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a> ，当前最新的版本是4.7.1。我们就用这个4.7.1版本来进行学习。</p>
<h2 id="1、下载RocketMQ-4-7-1版本"><a href="#1、下载RocketMQ-4-7-1版本" class="headerlink" title="1、下载RocketMQ 4.7.1版本"></a>1、下载RocketMQ 4.7.1版本</h2><p> RocketMQ运行版本下载地址： <a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip</a></p>
<p> RocketMQ源码版本下载地址： <a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-source-release.zip</a></p>
<p> 这两个版本我们都下载下来。</p>
<h2 id="2、快速安装RocketMQ"><a href="#2、快速安装RocketMQ" class="headerlink" title="2、快速安装RocketMQ"></a>2、快速安装RocketMQ</h2><p> RocketMQ的安装非常简单，就是上传解压就可以了。</p>
<p> 然后我们准备一台CentOS7的Linux机器，快速把RocketMQ给运行起来。我使用的Linux版本如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[oper@worker1 jdk1.8]$ uname -a</span><br><span class="line">Linux worker1 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p> 我们需要创建一个操作用户用来运行自己的程序，与root用户区分开。使用root用户创建一个oper用户，并给他创建一个工作目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@worker1 ~]# useradd oper</span><br><span class="line">[root@worker1 ~]# passwd oper </span><br><span class="line">设置用户密码</span><br><span class="line">[root@worker1 ~]# mkdir /app</span><br><span class="line">[root@worker1 ~]# chown oper:oper /app</span><br></pre></td></tr></table></figure>

<p> 运行RocketMQ需要先安装JDK。我们采用目前最稳定的JDK1.8版本。CentOS可以采用课件资料中的jdk-8u171-linux-x64.tar.gz，也可以自行去Oracle官网上下载。然后用FTP上传到oper用户的工作目录下。由oper用户解压到&#x2F;app&#x2F;jdk1.8目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[oper@worker1 tools]$ tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br><span class="line">[oper@worker1 tools]$ mv jdk1.8.0_171/ /app/jdk1.8</span><br></pre></td></tr></table></figure>

<p> 配置环境变量。使用 vi ~&#x2F;.bash_profile编辑文件，在下面加入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/app/jdk1.8/</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:$HOME/.local/bin:$HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p> 编辑完成后，执行 source ~&#x2F;.bash_profile让环境变量生效。输入java -version能查看到以下内容表明JDK安装成功了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[oper@worker1 ~]$ java -version</span><br><span class="line">java version &quot;1.8.0_171&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_171-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)</span><br></pre></td></tr></table></figure>

<p> 然后我们把下载的rocketmq-all-4.7.1-bin-release.zip在本地完成解压，并上传到&#x2F;app&#x2F;rocketmq目录。完成后，把rocketmq的bin目录也配置到环境变量当中。 vi ~&#x2F;.bash_profile，加入以下内容，并执行source ~&#x2F;.bash_profile让环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/app/jdk1.8/</span><br><span class="line">export ROCKETMQ_HOME=/app/rocketmq/rocketmq-all-4.7.1-bin-release</span><br><span class="line">PATH=$ROCKETMQ_HOME/bin:$JAVA_HOME/bin:$PATH:$HOME/.local/bin:$HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p> 这样RocketMQ就安装完成了。我们把他运行起来。</p>
<blockquote>
<p>这个ROCKETMQ_HOME的环境变量是必须要单独配置的，如果不配置的话，启动NameSever和Broker都会报错。</p>
<p>这个环境变量的作用是用来加载$ROCKETMQ_HOME&#x2F;conf下的除broker.conf以外的几个配置文件。所以实际情况中，可以不按这个配置，但是一定要能找到配置文件。</p>
</blockquote>
<h2 id="3、-快速运行RocketMQ"><a href="#3、-快速运行RocketMQ" class="headerlink" title="3、 快速运行RocketMQ"></a>3、 快速运行RocketMQ</h2><p> 运行之前，我们需要对RocketMQ的组件结构有个大致的了解。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9a677e8cbccb2808802d608abe2b8a8d/BAD094A2F5B249EA87FB5B9048B62B19?ynotemdtimestamp=1646737866265" alt="RocketMQ组件"></p>
<p> RocketMQ由以下这几个组件组成</p>
<ul>
<li>NameServer : 提供轻量级的Broker路由服务。</li>
<li>Broker：实际处理消息存储、转发等服务的核心组件。</li>
<li>Producer：消息生产者集群。通常是业务系统中的一个功能模块。</li>
<li>Consumer：消息消费者集群。通常也是业务系统中的一个功能模块。</li>
</ul>
<p>所以我们要启动RocketMQ服务，需要先启动NameServer。</p>
<h3 id="3-1-启动NameServer"><a href="#3-1-启动NameServer" class="headerlink" title="3.1 启动NameServer"></a>3.1 启动NameServer</h3><p> 启动NameServer非常简单， 在$ROCKETMQ_HOME&#x2F;bin目录下有个mqnamesrv。直接执行这个脚本就可以启动RocketMQ的NameServer服务。</p>
<p> 但是要注意，RocketMQ默认预设的JVM内存是4G，这是RocketMQ给我们的最佳配置。但是通常我们用虚拟机的话都是不够4G内存的，所以需要调整下JVM内存大小。<a target="_blank" rel="noopener" href="http://修改的方式是直接修改runserver.sh/">修改的方式是直接修改runserver.sh</a>。 用vi runserver.sh编辑这个脚本，在脚本中找到这一行调整内存大小为512M</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -</span><br><span class="line">XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure>

<p> 然后我们用静默启动的方式启动NameServer服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/mqnamesrv &amp; </span><br></pre></td></tr></table></figure>

<p> 启动完成后，在nohup.out里看到这一条关键日志就是启动成功了。并且使用jps指令可以看到有一个NamesrvStartup进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS</span><br><span class="line">collector is deprecated and will likely be removed in a future release</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and</span><br><span class="line">will likely be removed in a future release.</span><br><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>

<h3 id="3-2-启动Broker"><a href="#3-2-启动Broker" class="headerlink" title="3.2 启动Broker"></a>3.2 启动Broker</h3><p> <a target="_blank" rel="noopener" href="http://启动broker的脚本是runbroker.sh/">启动Broker的脚本是runbroker.sh</a>。Broker的默认预设内存是8G，启动前，如果内存不够，同样需要调整下JVM内存。vi <a target="_blank" rel="noopener" href="http://runbroker.sh/">runbroker.sh</a>，找到这一行，进行内存调整</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></pre></td></tr></table></figure>

<p> 然后我们需要找到$ROCKETMQ_HOME&#x2F;conf&#x2F;broker.conf， vi指令进行编辑，在最下面加入一个配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoCreateTopicEnable=true</span><br></pre></td></tr></table></figure>

<p> <a target="_blank" rel="noopener" href="http://然后也以静默启动的方式启动runbroker.sh/">然后也以静默启动的方式启动runbroker.sh</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./mqbroker &amp;</span><br></pre></td></tr></table></figure>

<p> 启动完成后，同样是检查nohup.out日志，有这一条关键日志就标识启动成功了。 并且jps指令可以看到一个BrokerStartup进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[worker1, 192.168.232.128:10911] boot success. serializeType=JSON</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在观察runserver.sh和runbroker.sh时，我们还可以查看到其他的JVM执行参数，这些参数都可以进行定制。例如我们观察到一个比较有意思的地方，nameServer使用的是CMS垃圾回收器，而Broker使用的是G1垃圾回收器。 关于垃圾回收器的知识你还记得吗？</p>
</blockquote>
<h3 id="3-3-命令行快速验证"><a href="#3-3-命令行快速验证" class="headerlink" title="3.3 命令行快速验证"></a>3.3 命令行快速验证</h3><p> 在RocketMQ的安装包中，提供了一个tools.sh工具可以用来在命令行快速验证RocketMQ服务。我们在worker2上进入RocketMQ的安装目录：</p>
<p>首先需要配置一个环境变量NAMESRV_ADDR指向我们启动的NameServer服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=&#x27;localhost:9876&#x27; </span><br></pre></td></tr></table></figure>

<p>然后启动消息生产者发送消息：默认会发1000条消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>

<p>我们可以看到发送消息的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A8E88007AC3764951D891CE9A003E7, offsetMsgId=C0A8E88000002A9F00000000000317BF, messageQueue=MessageQueue [topic=TopicTest, brokerName=worker1, queueId=1], queueOffset=249]</span><br><span class="line">14:59:33.418 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[127.0.0.1:9876] result: true</span><br><span class="line">14:59:33.423 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[192.168.232.128:10911] result: true</span><br></pre></td></tr></table></figure>

<p>这日志中，上面部分就是我们发送的消息的内容。后面两句标识消息生产者正常关闭。</p>
<p>然后启动消息消费者接收消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh  org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>

<p>启动后，可以看到消费到的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">ConsumeMessageThread_19 Receive New Messages: [MessageExt [brokerName=worker1, queueId=2, storeSize=203, queueOffset=53, sysFlag=0, bornTimestamp=1606460371999, bornHost=/192.168.232.128:43436, storeTimestamp=1606460372000, storeHost=/192.168.232.128:10911, msgId=C0A8E88000002A9F000000000000A7AE, commitLogOffset=42926, bodyCRC=1968636794, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message&#123;topic=&#x27;TopicTest&#x27;, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=250, CONSUME_START_TIME=1606460450150, UNIQ_KEY=C0A8E88007AC3764951D891CE41F00D4, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA&#125;, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 50, 49, 50], transactionId=&#x27;null&#x27;&#125;]] </span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志中MessageExt后的整个内容就是一条完整的RocketMQ消息。我们要对这个消息的结构有个大概的了解，后面会对这个消息进行深入的理解。</p>
<p>其中比较关键的属性有：brokerName，queueId，msgId，topic，cluster，tags，body，transactionId。先找下这些属性在哪里。</p>
</blockquote>
<p>而这个Consume指令并不会结束，他会继续挂起，等待消费其他的消息。我们可以使用CTRL+C停止该进程。</p>
<h3 id="3-4-关闭RocketMQ服务"><a href="#3-4-关闭RocketMQ服务" class="headerlink" title="3.4 关闭RocketMQ服务"></a>3.4 关闭RocketMQ服务</h3><p>要关闭RocketMQ服务可以通过mqshutdown脚本直接关闭</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1.关闭NameServer</span></span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"><span class="meta"># </span><span class="language-bash">2.关闭Broker</span></span><br><span class="line">sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure>

<h1 id="三、RocketMQ集群架构"><a href="#三、RocketMQ集群架构" class="headerlink" title="三、RocketMQ集群架构"></a>三、RocketMQ集群架构</h1><p> 刚才的演示中，我们已经体验到了RocketMQ是如何工作的。这样，我们回头看RocketMQ的集群架构，就能够有更全面的理解了。</p>
<p><img src="https://note.youdao.com/yws/public/resource/9a677e8cbccb2808802d608abe2b8a8d/BAD094A2F5B249EA87FB5B9048B62B19?ynotemdtimestamp=1646737866265" alt="RocketMQ组件"></p>
<h2 id="1、RocketMQ集群中的各个角色"><a href="#1、RocketMQ集群中的各个角色" class="headerlink" title="1、RocketMQ集群中的各个角色"></a>1、RocketMQ集群中的各个角色</h2><p>一个完整的RocketMQ集群中，有如下几个角色</p>
<ul>
<li>Producer：消息的发送者；举例：发信者</li>
<li>Consumer：消息接收者；举例：收信者</li>
<li>Broker：暂存和传输消息；举例：邮局</li>
<li>NameServer：管理Broker；举例：各个邮局的管理机构</li>
<li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li>
</ul>
<blockquote>
<p>我们之前的测试案例中，Topic是什么？topic&#x3D;’TopicTest’</p>
<p>现在你能看懂我们之前在broker.conf中添加的autoCreateTopicEnable&#x3D;true这个属性的用处了吗？</p>
</blockquote>
<ul>
<li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li>
</ul>
<blockquote>
<p>在我们之前的测试案例中，一个queueId就代表了一个MessageQueue。有哪些queueId？ 0，1，2，3四个MessageQueue，你都找到了吗？</p>
</blockquote>
<h2 id="2、RocketMQ集群搭建"><a href="#2、RocketMQ集群搭建" class="headerlink" title="2、RocketMQ集群搭建"></a>2、RocketMQ集群搭建</h2><p>为了方便阅读，RocketMQ集群以及RocketMQ配套的管理页面rocketmq-console的搭建写到了另外一个文档中。参见《<a target="_blank" rel="noopener" href="http://rocketmq集群搭建详解.md/">RocketMQ集群搭建详解.MD</a>》</p>
<h2 id="3、RocketMQ的其他参考资料"><a href="#3、RocketMQ的其他参考资料" class="headerlink" title="3、RocketMQ的其他参考资料"></a>3、RocketMQ的其他参考资料</h2><p>还记得我们之前把RocketMQ的源代码也下载下来了吗？我们现在不需要去看源代码，但是在源码中有个docs目录，里面有非常有用的资料。例如，在他的docs&#x2F;cn&#x2F;architecture.md文档中，有对RocketMQ架构的更详细的介绍。这里面的内容就不再搬运了，我们直接看看把。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 到这里，我们可以完整的搭建RocketMQ，并进行简单的使用了。</p>
<p> 首先，我们要对MQ的优缺点以及适用场景开始要有逐渐清晰的概念。成熟的MQ产品上手使用都很简单，所以，使用和面试的重点从来都不会是怎么编程，而是能结合项目场景完整落地，这才是考验程序员功力的地方。而这个功力的要点就在于对异步消息驱动场景的理解深度。这一部分的学习最好能够结合kafka、RabbitMQ和RocketMQ这几个产品一起进行横向对比。当然，没有基础的同学也不用着急，但是在以后的学习中要有这个意识。</p>
<p> 然后，我们要对RocketMQ整体的产品架构以及应用生态有个大致的了解。商业版本的RocketMQ提供了购买即用的高可用特性，并且功能也比开源版本略有改进。而在RocketMQ的开源版本之外，围绕RocketMQ的扩展生态包括管理控制台，大都整合在了rocketmq-externals社区项目中。关于RocketMQ的周边生态，其实跟kafka和RabbitMQ还是有差距的，但是RocketMQ相比这两个产品，不管是开发语言还是架构思维，对我们都更为友好，而且周边生态发展也有后发优势，所以对RocketMQ要抱着学习，改进的态度，从点到面横向拓宽技术视野。</p>
<p> 最后，我们要对RocketMQ的整体架构有一个全面的了解。并且在后续的细节学习时，要保持对第一个问题的好奇心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/RocketMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/RocketMQ%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">RocketMQ集群搭建</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-08 19:06:31 / 修改时间：20:51:17" itemprop="dateCreated datePublished" datetime="2022-03-08T19:06:31+08:00">2022-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、机器环境"><a href="#1、机器环境" class="headerlink" title="1、机器环境"></a>1、机器环境</h2><p>准备三台虚拟机，root密码 root ;IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.232.128 worker1</span><br><span class="line">192.168.232.129 worker2</span><br><span class="line">192.168.232.130 worker3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里特意不把每个机器的机器名定义得太过规范，比如master slave这样的，有助于更理解各项配置。</p>
</blockquote>
<h2 id="2、创建用户"><a href="#2、创建用户" class="headerlink" title="2、创建用户"></a>2、创建用户</h2><p>useradd oper</p>
<p>passwd oper (密码输入 123qweasd)</p>
<h2 id="3、系统配置"><a href="#3、系统配置" class="headerlink" title="3、系统配置"></a>3、系统配置</h2><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>切换oper用户，在worker1上 生成key</p>
<p>ssh-kengen</p>
<p>然后分发给其他机器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id worker1</span><br><span class="line">ssh-copy-id worker2</span><br><span class="line">ssh-copy-id worker3</span><br></pre></td></tr></table></figure>

<p>这样就可以在worker1上直接ssh 或者scp到另外的机器，不需要输密码了。</p>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">firewall-cmd --state </span><br></pre></td></tr></table></figure>

<h2 id="4、安装java"><a href="#4、安装java" class="headerlink" title="4、安装java"></a>4、安装java</h2><p>给oper创建&#x2F;app目录</p>
<p>上传jdk的tar包</p>
<p>修改~&#x2F;.bash_profile，配置环境变量。source生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/app/jdk1.8/</span><br></pre></td></tr></table></figure>

<h2 id="5、安装RocketMQ"><a href="#5、安装RocketMQ" class="headerlink" title="5、安装RocketMQ"></a>5、安装RocketMQ</h2><p>上传tar包，直接解压。然后配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ROCKETMQ_HOME=/app/rocketmq/rocketmq-all-4.7.1-bin-release</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RocketMQ在4.5版本之前都不支持master宕机后slave自动切换。在4.5版本后，增加了基于Dleger实现的主从切换。这里用的目前最新的4.7.1版本</p>
</blockquote>
<h2 id="6、配置RocketMQ集群"><a href="#6、配置RocketMQ集群" class="headerlink" title="6、配置RocketMQ集群"></a>6、配置RocketMQ集群</h2><p>我们为了便于观察，这次搭建一个2主2从异步刷盘的集群，所以我们会使用conf&#x2F;2m-2s-async下的配置文件，实际项目中，为了达到高可用，一般会使用dleger。预备设计的集群情况如下：</p>
<table>
<thead>
<tr>
<th>机器名</th>
<th>nemaeServer节点部署</th>
<th>broker节点部署</th>
</tr>
</thead>
<tbody><tr>
<td>worker1</td>
<td>nameserver</td>
<td></td>
</tr>
<tr>
<td>worker2</td>
<td>nameserver</td>
<td>broker-a, broker-b-s</td>
</tr>
<tr>
<td>worker3</td>
<td>nameserver</td>
<td>broker-b,broker-a-s</td>
</tr>
</tbody></table>
<p>所以修改的配置文件是进入rocketmq的config目录下修改2m-2s-async的配置文件。–只需要配置broker.conf。</p>
<blockquote>
<p>在rocketmq的config目录下可以看到rocketmq建议的各种配置方式：</p>
<ul>
<li>2m-2s-async: 2主2从异步刷盘(吞吐量较大，但是消息可能丢失),</li>
<li>2m-2s-sync:2主2从同步刷盘(吞吐量会下降，但是消息更安全)，</li>
<li>2m-noslave:2主无从(单点故障)，然后还可以直接配置broker.conf，进行单点环境配置。</li>
<li>而dleger就是用来实现主从切换的。集群中的节点会基于Raft协议随机选举出一个leader，其他的就都是follower。通常正式环境都会采用这种方式来搭建集群。</li>
</ul>
</blockquote>
<p>我们这次采用2m-2s-async的方式搭建集群。</p>
<h3 id="1、配置第一组broker-a"><a href="#1、配置第一组broker-a" class="headerlink" title="1、配置第一组broker-a"></a>1、配置第一组broker-a</h3><p>在<strong>worker2</strong>上先配置borker-a的master节点。先配置2m-2s-async&#x2F;broker-a.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/app/rocketmq/store</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/app/rocketmq/store/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/app/rocketmq/store/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/app/rocketmq/store/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/app/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/app/rocketmq/store/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<p>该节点对应的从节点在<strong>worker3</strong>上。修改2m-2s-async&#x2F;broker-a-s.properties <code>只需要修改brokerId和brokerRole</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">11011</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/app/rocketmq/storeSlave</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/app/rocketmq/storeSlave/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/app/rocketmq/storeSlave/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/app/rocketmq/storeSlave/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/app/rocketmq/storeSlave/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/app/rocketmq/storeSlave/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<p>2、配置第二组Broker-b</p>
<p>这一组broker的主节点在<strong>worker3</strong>上，所以需要配置worker3上的config&#x2F;2m-2s-async&#x2F;broker-b.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/app/rocketmq/store</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/app/rocketmq/store/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/app/rocketmq/store/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/app/rocketmq/store/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/app/rocketmq/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/app/rocketmq/store/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<p>然后他对应的slave在worker2上，修改work2上的 conf&#x2F;2m-2s-async&#x2F;broker-b-s.properties</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">rocketmq-cluster</span></span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-b</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">11011</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/app/rocketmq/storeSlave</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/app/rocketmq/storeSlave/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/app/rocketmq/storeSlave/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/app/rocketmq/storeSlave/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/app/rocketmq/storeSlave/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/app/rocketmq/storeSlave/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SLAVE</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样broker就配置完成了。</p>
<p>需要注意的配置项：1、同一机器上两个实例的store目录不能相同，否则会报错 Lock failed,MQ already started</p>
<p>2、同一机器上两个实例的listenPort也不能相同。否则会报端口占用的错</p>
<p>nameserver不需要进行配置，直接启动就行。这也看出nameserver是无状态的。</p>
<p>3、其他的配置项参见《RcoketMQ全部配置表.pdf》</p>
</blockquote>
<h2 id="7、启动RocketMQ"><a href="#7、启动RocketMQ" class="headerlink" title="7、启动RocketMQ"></a>7、启动RocketMQ</h2><p>启动就比较简单了，直接调用bin目录下的脚本就行。只是启动之前要注意看下他们的JVM内存配置，默认的配置都比较高。</p>
<h3 id="1、先启动nameServer。"><a href="#1、先启动nameServer。" class="headerlink" title="1、先启动nameServer。"></a>1、先启动nameServer。</h3><p>修改三个节点上的bin&#x2F;runserver.sh，调整里面的jvm内存配置。找到下面这一行调整下内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure>

<p>直接在三个节点上启动nameServer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p>启动完成后，在nohup.out里看到这一条关键日志就是启动成功了。</p>
<p>Java HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future release<br>Java HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.<br>The Name Server boot success. serializeType&#x3D;JSON</p>
<p>使用jps指令可以看到一个NamesrvStartup进程。</p>
<blockquote>
<p>这里也看到，RocketMQ在runserver.sh中是使用的CMS垃圾回收期，而在runbroker.sh中使用的是G1垃圾回收期。</p>
</blockquote>
<h3 id="2、再启动broker"><a href="#2、再启动broker" class="headerlink" title="2、再启动broker"></a>2、再启动broker</h3><p>启动broker是使用的mqbroker指令，只是注意启动broker时需要通过-c 指定对应的配置文件。</p>
<p>在<strong>worker2</strong>上启动broker-a的master节点和broker-b的slave节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>

<p>在work3上启动broker-b的master节点和broker-a的slave节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line">nohup ./mqbroker -c ../conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动slave时，如果遇到报错 Lock failed,MQ already started ，那是因为有多个实例共用了同一个storePath造成的，这时就需要调整store的路径。</p>
</blockquote>
<h3 id="3、启动状态检查"><a href="#3、启动状态检查" class="headerlink" title="3、启动状态检查"></a>3、启动状态检查</h3><p>使用jps指令，能看到一个NameSrvStartup进程和两个BrokerStartup进程。</p>
<p>nohup.out中也有启动成功的日志。</p>
<p>对应的日志文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看nameServer日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看broker日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<h3 id="4、测试mqadmin管理工具"><a href="#4、测试mqadmin管理工具" class="headerlink" title="4、测试mqadmin管理工具"></a>4、测试mqadmin管理工具</h3><p>RocketMQ的源代码中并没有为我们提供类似于Nacos或者RabbitMQ那样的控制台，只提供了一个mqadmin指令来管理RocketMQ，命令在bin目录下。使用方式是 .&#x2F;mqadmin {command} {args}</p>
<p>所有指令如下：</p>
<h4 id="Topic相关："><a href="#Topic相关：" class="headerlink" title="Topic相关："></a><strong>Topic相关</strong>：</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>updateTopic</td>
<td>创建更新Topic配置</td>
<td>-b</td>
<td>Broker 地址，表示 topic 所在 Broker，只支持单台Broker，地址为ip:port</td>
</tr>
<tr>
<td>-c</td>
<td>cluster 名称，表示 topic 所在集群（集群可通过 clusterList 查询）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h-</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>指定新topic的读写权限( W&#x3D;2|R&#x3D;4|WR&#x3D;6 )</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>可读队列数（默认为 8）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-w</td>
<td>可写队列数（默认为 8）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic 名称（名称只能使用字符 ^[a-zA-Z0-9_-]+$ ）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>deleteTopic</td>
<td>删除Topic</td>
<td>-c</td>
<td>cluster 名称，表示删除某集群下的某个 topic （集群 可通过 clusterList 查询）</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic 名称（名称只能使用字符 ^[a-zA-Z0-9_-]+$ ）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>topicList</td>
<td>查看 Topic 列表信息</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-c</td>
<td>不配置-c只返回topic列表，增加-c返回clusterName, topic, consumerGroup信息，即topic的所属集群和订阅关系，没有参数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>topicRoute</td>
<td>查看 Topic 路由信息</td>
<td>-t</td>
<td>topic 名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>topicStatus</td>
<td>查看 Topic 消息队列offset</td>
<td>-t</td>
<td>topic 名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>topicClusterList</td>
<td>查看 Topic 所在集群列表</td>
<td>-t</td>
<td>topic 名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>updateTopicPerm</td>
<td>更新 Topic 读写权限</td>
<td>-t</td>
<td>topic 名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>Broker 地址，表示 topic 所在 Broker，只支持单台Broker，地址为ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>指定新 topic 的读写权限( W&#x3D;2|R&#x3D;4|WR&#x3D;6 )</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>cluster 名称，表示 topic 所在集群（集群可通过 clusterList 查询），-b优先，如果没有-b，则对集群中所有Broker执行命令</td>
<td></td>
<td></td>
</tr>
<tr>
<td>updateOrderConf</td>
<td>从NameServer上创建、删除、获取特定命名空间的kv配置，目前还未启用</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic，键</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>orderConf，值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-m</td>
<td>method，可选get、put、delete</td>
<td></td>
<td></td>
</tr>
<tr>
<td>allocateMQ</td>
<td>以平均负载算法计算消费者列表负载消息队列的负载结果</td>
<td>-t</td>
<td>topic 名称</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>ipList，用逗号分隔，计算这些ip去负载Topic的消息队列</td>
<td></td>
<td></td>
</tr>
<tr>
<td>statsAll</td>
<td>打印Topic订阅关系、TPS、积累量、24h读写总量等信息</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>是否只打印活跃topic</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>指定topic</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="集群相关"><a href="#集群相关" class="headerlink" title="集群相关"></a><strong>集群相关</strong></h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clusterList</td>
<td>查看集群信息，集群、BrokerName、BrokerId、TPS等信息</td>
<td>-m</td>
<td>打印更多信息 (增加打印出如下信息 #InTotalYest, #OutTotalYest, #InTotalToday ,#OutTotalToday)</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>打印间隔，单位秒</td>
<td></td>
<td></td>
</tr>
<tr>
<td>clusterRT</td>
<td>发送消息检测集群各Broker RT。消息发往${BrokerName} Topic。</td>
<td>-a</td>
<td>amount，每次探测的总数，RT &#x3D; 总时间 &#x2F; amount</td>
</tr>
<tr>
<td>-s</td>
<td>消息大小，单位B</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>探测哪个集群</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>是否打印格式化日志，以|分割，默认不打印</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-m</td>
<td>所属机房，打印使用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>发送间隔，单位秒</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="Broker相关"><a href="#Broker相关" class="headerlink" title="Broker相关"></a><strong>Broker相关</strong></h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>updateBrokerConfig</td>
<td>更新 Broker 配置文件，会修改Broker.conf</td>
<td>-b</td>
<td>Broker 地址，格式为ip:port</td>
</tr>
<tr>
<td>-c</td>
<td>cluster 名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-k</td>
<td>key 值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>value 值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>brokerStatus</td>
<td>查看 Broker 统计信息、运行状态（你想要的信息几乎都在里面）</td>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>brokerConsumeStats</td>
<td>Broker中各个消费者的消费情况，按Message Queue维度返回Consume Offset，Broker Offset，Diff，TImestamp等信息</td>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
</tr>
<tr>
<td>-t</td>
<td>请求超时时间</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-l</td>
<td>diff阈值，超过阈值才打印</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-o</td>
<td>是否为顺序topic，一般为false</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getBrokerConfig</td>
<td>获取Broker配置</td>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wipeWritePerm</td>
<td>从NameServer上清除 Broker写权限</td>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>cleanExpiredCQ</td>
<td>清理Broker上过期的Consume Queue，如果手动减少对列数可能产生过期队列</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>集群名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>cleanUnusedTopic</td>
<td>清理Broker上不使用的Topic，从内存中释放Topic的Consume Queue，如果手动删除Topic会产生不使用的Topic</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>Broker 地址，地址为ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>集群名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sendMsgStatus</td>
<td>向Broker发消息，返回发送状态和RT</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>BrokerName，注意不同于Broker地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>消息大小，单位B</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>发送次数</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a><strong>消息相关</strong></h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>queryMsgById</td>
<td>根据offsetMsgId查询msg，如果使用开源控制台，应使用offsetMsgId，此命令还有其他参数，具体作用请阅读QueryMsgByIdSubCommand。</td>
<td>-i</td>
<td>msgId</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>queryMsgByKey</td>
<td>根据消息 Key 查询消息</td>
<td>-k</td>
<td>msgKey</td>
</tr>
<tr>
<td>-t</td>
<td>Topic 名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>queryMsgByOffset</td>
<td>根据 Offset 查询消息</td>
<td>-b</td>
<td>Broker 名称，（这里需要注意 填写的是 Broker 的名称，不是 Broker 的地址，Broker 名称可以在 clusterList 查到）</td>
</tr>
<tr>
<td>-i</td>
<td>query 队列 id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-o</td>
<td>offset 值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic 名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>queryMsgByUniqueKey</td>
<td>根据msgId查询，msgId不同于offsetMsgId，区别详见常见运维问题。-g，-d配合使用，查到消息后尝试让特定的消费者消费消息并返回消费结果</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>uniqe msg id</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>consumerGroup</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>clientId</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>checkMsgSendRT</td>
<td>检测向topic发消息的RT，功能类似clusterRT</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>探测次数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>消息大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sendMessage</td>
<td>发送一条消息，可以根据配置发往特定Message Queue，或普通发送。</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>body，消息体</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-k</td>
<td>keys</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>tags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>BrokerName</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>queueId</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumeMessage</td>
<td>消费消息。可以根据offset、开始&amp;结束时间戳、消息队列消费消息，配置不同执行不同消费逻辑，详见ConsumeMessageCommand。</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>BrokerName</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-o</td>
<td>从offset开始消费</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>queueId</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>消费者分组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>开始时间戳，格式详见-h</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>结束时间戳</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>消费多少条消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>printMsg</td>
<td>从Broker消费消息并打印，可选时间段</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>字符集，例如UTF-8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>subExpress，过滤表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>开始时间戳，格式参见-h</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-e</td>
<td>结束时间戳</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>是否打印消息体</td>
<td></td>
<td></td>
</tr>
<tr>
<td>printMsgByQueue</td>
<td>类似printMsg，但指定Message Queue</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>queueId</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>BrokerName</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>字符集，例如UTF-8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>subExpress，过滤表达式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>开始时间戳，格式参见-h</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-e</td>
<td>结束时间戳</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>是否打印消息</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>是否打印消息体</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>是否统计tag数量并打印</td>
<td></td>
<td></td>
</tr>
<tr>
<td>resetOffsetByTime</td>
<td>按时间戳重置offset，Broker和consumer都会重置</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>消费者分组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>重置为此时间戳对应的offset</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-f</td>
<td>是否强制重置，如果false，只支持回溯offset，如果true，不管时间戳对应offset与consumeOffset关系</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>是否重置c++客户端offset</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="消费者和消费者组相关"><a href="#消费者和消费者组相关" class="headerlink" title="消费者和消费者组相关"></a><strong>消费者和消费者组相关</strong></h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>consumerProgress</td>
<td>查看订阅组消费状态，可以查看具体的client IP的消息积累量</td>
<td>-g</td>
<td>消费者所属组名</td>
</tr>
<tr>
<td>-s</td>
<td>是否打印client IP</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumerStatus</td>
<td>查看消费者状态，包括同一个分组中是否都是相同的订阅，分析Process Queue是否堆积，返回消费者jstack结果，内容较多，使用者参见ConsumerStatusSubCommand</td>
<td>-h</td>
<td>打印帮助</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>consumer group</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>clientId</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>是否执行jstack</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getConsumerStatus</td>
<td>获取 Consumer 消费进度</td>
<td>-g</td>
<td>消费者所属组名</td>
</tr>
<tr>
<td>-t</td>
<td>查询主题</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>Consumer 客户端 ip</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>updateSubGroup</td>
<td>更新或创建订阅关系</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>Broker地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>集群名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>消费者分组名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>分组是否允许消费</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-m</td>
<td>是否从最小offset开始消费</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>是否是广播模式</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-q</td>
<td>重试队列数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>最大重试次数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-i</td>
<td>当slaveReadEnable开启时有效，且还未达到从slave消费时建议从哪个BrokerId消费，可以配置备机id，主动从备机消费</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-w</td>
<td>如果Broker建议从slave消费，配置决定从哪个slave消费，配置BrokerId，例如1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-a</td>
<td>当消费者数量变化时是否通知其他消费者负载均衡</td>
<td></td>
<td></td>
</tr>
<tr>
<td>deleteSubGroup</td>
<td>从Broker删除订阅关系</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>Broker地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>集群名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g</td>
<td>消费者分组名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>cloneGroupOffset</td>
<td>在目标群组中使用源群组的offset</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>源消费者组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>目标消费者组</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>topic名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-o</td>
<td>暂未使用</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="连接相关"><a href="#连接相关" class="headerlink" title="连接相关"></a>连接相关</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>consumerConnec tion</td>
<td>查询 Consumer 的网络连接</td>
<td>-g</td>
<td>消费者所属组名</td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>producerConnec tion</td>
<td>查询 Producer 的网络连接</td>
<td>-g</td>
<td>生产者所属组名</td>
</tr>
<tr>
<td>-t</td>
<td>主题名称</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>NameServer相关</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>updateKvConfig</td>
<td>更新NameServer的kv配置，目前还未使用</td>
<td>-s</td>
<td>命名空间</td>
</tr>
<tr>
<td>-k</td>
<td>key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>deleteKvConfig</td>
<td>删除NameServer的kv配置</td>
<td>-s</td>
<td>命名空间</td>
</tr>
<tr>
<td>-k</td>
<td>key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getNamesrvConfig</td>
<td>获取NameServer配置</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>updateNamesrvConfig</td>
<td>修改NameServer配置</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-k</td>
<td>key</td>
<td></td>
<td></td>
</tr>
<tr>
<td>-v</td>
<td>value</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>命令选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>startMonitoring</td>
<td>开启监控进程，监控消息误删、重试队列消息数等</td>
<td>-n</td>
<td>NameServer 服务地址，格式 ip:port</td>
</tr>
<tr>
<td>-h</td>
<td>打印帮助</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<p>1、几乎所有指令都需要通过-n参数配置nameServer地址，格式为ip:port</p>
<p>2、几乎所有执行都可以通过-h参数获得帮助</p>
<p>3、当既有Broker地址(-b)又有集群名称clustername(-c)配合项，则优先以Broker地址执行指令。如果不配置Broker地址，则对集群中所有主机执行指令。</p>
</blockquote>
<h3 id="5、命令行快速验证"><a href="#5、命令行快速验证" class="headerlink" title="5、命令行快速验证"></a>5、命令行快速验证</h3><p>在RocketMQ的安装包中，提供了一个tools.sh工具可以用来在命令行快速验证RocketMQ服务。我们在worker2上进入RocketMQ的安装目录：</p>
<p>发送消息：默认会发1000条消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>

<p>接收消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/tools.sh  org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这是官方提供的Demo，但是官方的源码中，这两个类都是没有指定nameServer的，所以运行会有点问题。要指定NameServer地址，可以配置一个环境变量NAMESRV_ADDR，这样默认会读取这个NameServer地址。可以配到.bash_profile里或者直接临时指定。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=&#x27;worker1:9876;worker2:9876;worker3:9876&#x27;</span><br></pre></td></tr></table></figure>

<p>然后就可以正常执行了。</p>
<p>这个NameServer地址的读取方式见源码中org.apache.rocketmq.common.utils.NameServerAddressUtils</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNameServerAddresses</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> System.getProperty(<span class="string">&quot;rocketmq.namesrv.addr&quot;</span>, System.getenv(<span class="string">&quot;NAMESRV_ADDR&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是在DefaultMQProducer中默认的设置NameServer地址的方式，这个rokcetmq.namesrv.addr属性可以在java中使用System.setproperties指定，也可以在SpringBoot中配到配置文件里。</p>
<blockquote>
<p>这个tools.sh就封装了一个简单的运行RocketMQ的环境，可以运行源码中的其他示例，然后自己的例子也可以放到RocketMQ的lib目录下去执行。</p>
</blockquote>
<h2 id="8、搭建管理控制台"><a href="#8、搭建管理控制台" class="headerlink" title="8、搭建管理控制台"></a>8、搭建管理控制台</h2><p>RocketMQ源代码中并没有提供控制台，但是有一个Rocket的社区扩展项目中提供了一个控制台，地址： <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p>
<p>下载下来后，进入其中的rocket-console目录，使用maven进行编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<p>编译完成后，获取target下的jar包，就可以直接执行。但是这个时候要注意，在这个项目的application.properties中需要指定nameserver的地址。默认这个属性是空的。</p>
<p>那我们可以在jar包的当前目录下增加一个application.properties文件，覆盖jar包中默认的一个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=worker1:9876;worker2:9876;worker3:9876</span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.1.jar</span><br></pre></td></tr></table></figure>

<p>启动完成后，可以访问 <a href="http://192.168.232.128:8080看到管理页面">http://192.168.232.128:8080看到管理页面</a></p>
<blockquote>
<p>在管理页面的右上角可以选择语言。</p>
</blockquote>
<h2 id="Dleger高可用集群搭建"><a href="#Dleger高可用集群搭建" class="headerlink" title="Dleger高可用集群搭建"></a>Dleger高可用集群搭建</h2><p> 通过这种方式，我们搭建了一个主从结构的RocketMQ集群，但是我们要注意，这种主从结构是只做数据备份，没有容灾功能的。也就是说当一个master节点挂了后，slave节点是无法切换成master节点继续提供服务的。注意这个集群至少要是3台，允许少于一半的节点发生故障。</p>
<blockquote>
<p>如果slave挂了，对集群的影响不会很大，因为slave只是做数据备份的。但是影响也是会有的，例如，当消费者要拉取的数据量比较大时，RocketMQ有一定的机制会优先保证Master节点的性能，只让Master节点返回一小部分数据，而让其他部分的数据从slave节点去拉取。</p>
<p>另外，需要注意，Dleger会有他自己的CommitLog机制，也就是说，使用主从集群累计下来的消息，是无法转移到Dleger集群中的。</p>
</blockquote>
<p> 而如果要进行高可用的容灾备份，需要采用Dledger的方式来搭建高可用集群。注意，这个Dledger需要在RocketMQ4.5以后的版本才支持，我们使用的4.7.1版本已经默认集成了dledger。</p>
<h3 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h3><p> 要搭建高可用的Broker集群，我们只需要配置conf&#x2F;dleger下的配置文件就行。</p>
<blockquote>
<p>这种模式是基于Raft协议的，是一个类似于Zookeeper的paxos协议的选举协议，也是会在集群中随机选举出一个leader，其他的就是follower。只是他选举的过程跟paxos有点不同。Raft协议基于随机休眠机制的，选举过程会比paxos相对慢一点。</p>
</blockquote>
<p> 首先：<a target="_blank" rel="noopener" href="http://我们同样是需要修改runserver.sh和runbroker.sh/">我们同样是需要修改runserver.sh和runbroker.sh</a>，对JVM内存进行定制。</p>
<p> 然后：我们需要修改conf&#x2F;dleger下的配置文件。 跟dleger相关的几个配置项如下：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>enableDLegerCommitLog</td>
<td>是否启动 DLedger</td>
<td>true</td>
</tr>
<tr>
<td>dLegerGroup</td>
<td>DLedger Raft Group的名字，建议和 brokerName 保持一致</td>
<td>RaftNode00</td>
</tr>
<tr>
<td>dLegerPeers</td>
<td>DLedger Group 内各节点的端口信息，同一个 Group 内的各个节点配置必须要保证一致</td>
<td>n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</td>
</tr>
<tr>
<td>dLegerSelfId</td>
<td>节点 id, 必须属于 dLegerPeers 中的一个；同 Group 内各个节点要唯一</td>
<td>n0</td>
</tr>
<tr>
<td>sendMessageThreadPoolNums</td>
<td>发送线程个数，建议配置成 Cpu 核数</td>
<td>16</td>
</tr>
</tbody></table>
<p>配置完后，同样是使用 nohup bin&#x2F;mqbroker -c $conf_name &amp; 的方式指定实例文件。</p>
<blockquote>
<p>在bin&#x2F;dleger下有个fast-try.sh，这个脚本是在本地启动三个RocketMQ实例，搭建一个高可用的集群，读取的就是conf&#x2F;dleger下的broker-no.conf，broker-n1.conf和broker-n2.conf。使用这个脚本同样要注意定制下JVM内存，他给每个实例默认定制的是1G内存，虚拟机肯定是不够的。</p>
<p>这种单机三实例的集群搭建完成后，可以使用 bin&#x2F;mqadmin clusterList -n worker1.conf的方式查看集群状态。</p>
<p>单机状态下一般一次主从切换需要大概10S的时间。</p>
</blockquote>
<h2 id="9、调整系统参数"><a href="#9、调整系统参数" class="headerlink" title="9、调整系统参数"></a>9、调整系统参数</h2><p>到这里，我们的整个RocketMQ的服务就搭建完成了。但是在实际使用时，我们说RocketMQ的吞吐量、性能都很高，那要发挥RocketMQ的高性能，还需要对RocketMQ以及服务器的性能进行定制</p>
<h3 id="1、配置RocketMQ的JVM内存大小："><a href="#1、配置RocketMQ的JVM内存大小：" class="headerlink" title="1、配置RocketMQ的JVM内存大小："></a>1、配置RocketMQ的JVM内存大小：</h3><p>之前提到过，在runserver.sh中需要定制nameserver的内存大小，在runbroker.sh中需要定制broker的内存大小。这些默认的配置可以认为都是经过检验的最优化配置，但是在实际情况中都还需要根据服务器的实际情况进行调整。这里以runbroker.sh中对G1GC的配置举例，在runbroker.sh中的关键配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0&quot;</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -verbose:gc -Xloggc:$&#123;GC_LOG_DIR&#125;/rmq_broker_gc_%p_%t.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy&quot;</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m&quot;</span><br></pre></td></tr></table></figure>

<p>-XX:+UseG1GC: 使用G1垃圾回收器， -XX:G1HeapRegionSize&#x3D;16m 将G1的region块大小设为16M，-XX:G1ReservePercent：在G1的老年代中预留25%空闲内存，这个默认值是10%，RocketMQ把这个参数调大了。-XX:InitiatingHeapOccupancyPercent&#x3D;30：当堆内存的使用率达到30%之后就会启动G1垃圾回收器尝试回收垃圾，默认值是45%，RocketMQ把这个参数调小了，也就是提高了GC的频率，但是避免了垃圾对象过多，一次垃圾回收时间太长的问题。</p>
<p>然后，后面定制了GC的日志文件，确定GC日志文件的地址、打印的内容以及控制每个日志文件的大小为30M并且只保留5个文件。这些在进行性能检验时，是相当重要的参考内容。</p>
<h3 id="2、RocketMQ的其他一些核心参数"><a href="#2、RocketMQ的其他一些核心参数" class="headerlink" title="2、RocketMQ的其他一些核心参数"></a>2、RocketMQ的其他一些核心参数</h3><p>例如在conf&#x2F;dleger&#x2F;broker-n0.conf中有一个参数：sendMessageThreadPoolNums&#x3D;16。这一个参数是表明RocketMQ内部用来发送消息的线程池的线程数量是16个，其实这个参数可以根据机器的CPU核心数进行适当调整，例如如果你的机器核心数超过16个，就可以把这个参数适当调大。</p>
<h3 id="3、Linux内核参数定制"><a href="#3、Linux内核参数定制" class="headerlink" title="3、Linux内核参数定制"></a>3、Linux内核参数定制</h3><p>我们在部署RocketMQ的时候，还需要对Linux内核参数进行一定的定制。例如</p>
<ul>
<li><strong>ulimit</strong>，需要进行大量的网络通信和磁盘IO。</li>
<li><strong>vm.extra_free_kbytes</strong>，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）</li>
<li><strong>vm.min_free_kbytes</strong>，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。</li>
<li><strong>vm.max_map_count</strong>，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。</li>
<li><strong>vm.swappiness</strong>，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。</li>
<li><strong>File descriptor limits</strong>，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350。</li>
</ul>
<blockquote>
<p>这些参数在CentOS7中的配置文件都在 &#x2F;proc&#x2F;sys&#x2F;vm目录下。</p>
<p>另外，RocketMQ的bin目录下有个os.sh里面设置了RocketMQ建议的系统内核参数，可以根据情况进行调整。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/08/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-08 09:37:18 / 修改时间：09:40:20" itemprop="dateCreated datePublished" datetime="2022-03-08T09:37:18+08:00">2022-03-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://floating-dreamm.github.io/2022/03/07/index-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/WechatIMG1.jpeg">
      <meta itemprop="name" content="靓仔灬很忙">
      <meta itemprop="description" content="同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Boyce">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/index-1/" class="post-title-link" itemprop="url">IDEA快捷键</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 17:20:29" itemprop="dateCreated datePublished" datetime="2022-03-07T17:20:29+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-13 10:34:12" itemprop="dateModified" datetime="2022-03-13T10:34:12+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/quickHelp/" itemprop="url" rel="index"><span itemprop="name">quickHelp</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/quickHelp/%E5%BF%AB%E6%8D%B7%E9%94%AE/" itemprop="url" rel="index"><span itemprop="name">快捷键</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/quickHelp/%E5%BF%AB%E6%8D%B7%E9%94%AE/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Windows-x2F-Linux"><a href="#Windows-x2F-Linux" class="headerlink" title="Windows&#x2F;Linux"></a>Windows&#x2F;Linux</h1><h2 id="编辑类快捷键"><a href="#编辑类快捷键" class="headerlink" title="编辑类快捷键"></a>编辑类快捷键</h2><table>
<thead>
<tr>
<th align="center">编辑类快捷键</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">psvm + Tab</td>
<td align="center">生成main方法</td>
</tr>
<tr>
<td align="center">sout + tab</td>
<td align="center">生成输出语句</td>
</tr>
<tr>
<td align="center">Ctrl+X &#x2F; Ctrl + Y</td>
<td align="center">删除一行</td>
</tr>
<tr>
<td align="center">Ctrl+D</td>
<td align="center">复制一行</td>
</tr>
<tr>
<td align="center">Ctrl+&#x2F; 或 Ctrl+Shift+&#x2F;</td>
<td align="center">注释代码</td>
</tr>
<tr>
<td align="center">Ctrl + Z</td>
<td align="center">撤销</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Z</td>
<td align="center">取消撤销</td>
</tr>
<tr>
<td align="center">Ctrl + C</td>
<td align="center">复制</td>
</tr>
<tr>
<td align="center">Ctrl + V</td>
<td align="center">粘贴</td>
</tr>
<tr>
<td align="center">Ctrl + O</td>
<td align="center">重写方法</td>
</tr>
<tr>
<td align="center">Ctrl + I</td>
<td align="center">实现方法</td>
</tr>
<tr>
<td align="center">Ctr + shift + U</td>
<td align="center">大小写转化</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + J</td>
<td align="center">整合两行为一行</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + space</td>
<td align="center">自动补全代码</td>
</tr>
<tr>
<td align="center">Alt + 回车</td>
<td align="center">导入包,自动修正</td>
</tr>
<tr>
<td align="center">Alt + &#x2F;</td>
<td align="center">代码提示</td>
</tr>
<tr>
<td align="center">Alt + Insert</td>
<td align="center">生成代码(如GET,SET方法,构造函数等)</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + L</td>
<td align="center">格式化代码</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + I</td>
<td align="center">自动缩进</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + T</td>
<td align="center">生成try catch</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + O</td>
<td align="center">优化导入的类和包</td>
</tr>
<tr>
<td align="center">fori</td>
<td align="center">生成for循环for (int i &#x3D; 0; i&lt; ; i++) { }</td>
</tr>
<tr>
<td align="center">iter</td>
<td align="center">生成增强for循环</td>
</tr>
<tr>
<td align="center">itar</td>
<td align="center">生成array for代码块</td>
</tr>
<tr>
<td align="center">itit</td>
<td align="center">生成iterator 迭代</td>
</tr>
<tr>
<td align="center">itli</td>
<td align="center">生成List的遍历</td>
</tr>
<tr>
<td align="center">itco</td>
<td align="center">生成Collection迭代</td>
</tr>
</tbody></table>
<h2 id="查找、替换类快捷键"><a href="#查找、替换类快捷键" class="headerlink" title="查找、替换类快捷键"></a>查找、替换类快捷键</h2><table>
<thead>
<tr>
<th align="center">查找、替换类快捷键</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + F</td>
<td align="center">在当前文件中查找</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + F</td>
<td align="center">在整个项目或者指定窗口中查找文本</td>
</tr>
<tr>
<td align="center">Ctrl + N</td>
<td align="center">在项目中查找类</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + N</td>
<td align="center">查找文件</td>
</tr>
<tr>
<td align="center">Ctrl + R</td>
<td align="center">在当前文件进行文本替换</td>
</tr>
<tr>
<td align="center">Ctrl + Shift+R</td>
<td align="center">在指定窗口替换文本</td>
</tr>
<tr>
<td align="center">Ctrl + W</td>
<td align="center">自动按语法选中代码</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + W</td>
<td align="center">反向自动按语法选中代码</td>
</tr>
<tr>
<td align="center">Ctrl + G</td>
<td align="center">定位行</td>
</tr>
<tr>
<td align="center">Ctrl＋Shift＋Backspace</td>
<td align="center">跳转到上一次编辑的位置</td>
</tr>
<tr>
<td align="center">Ctrl + alt + ←&#x2F;→</td>
<td align="center">前后跳转编辑过的地方</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Alt + N</td>
<td align="center">查找 变量 &#x2F; 方法</td>
</tr>
<tr>
<td align="center">Alt + F7</td>
<td align="center">找到你的函数或者变量或者类的所有引用到的地方</td>
</tr>
<tr>
<td align="center">Alt + F3</td>
<td align="center">高亮显示所有该选中文本，按 Enter 选中下一个，按 Esc 高亮消失</td>
</tr>
<tr>
<td align="center">F4</td>
<td align="center">在当前类中查找变量的来源</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + F7</td>
<td align="center">高亮显示所有该选中文本，按 Esc 高亮消失</td>
</tr>
<tr>
<td align="center">双击Shift</td>
<td align="center">查找任何内容</td>
</tr>
</tbody></table>
<h2 id="编译、运行类快捷键"><a href="#编译、运行类快捷键" class="headerlink" title="编译、运行类快捷键"></a>编译、运行类快捷键</h2><table>
<thead>
<tr>
<th align="center">编译、运行类快捷键</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + F9</td>
<td align="center">编译项目</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + F9</td>
<td align="center">编译当前文件</td>
</tr>
<tr>
<td align="center">Shift + F10</td>
<td align="center">正常启动</td>
</tr>
<tr>
<td align="center">Alt + Shift + F10</td>
<td align="center">弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td align="center">Shift + F9</td>
<td align="center">debug模式启动</td>
</tr>
<tr>
<td align="center">Alt + Shift + F9</td>
<td align="center">选择 Debug</td>
</tr>
</tbody></table>
<h2 id="Debug快捷键"><a href="#Debug快捷键" class="headerlink" title="Debug快捷键"></a>Debug快捷键</h2><table>
<thead>
<tr>
<th align="center">Debug快捷键</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F7</td>
<td align="center">在 Debug 模式下，步入</td>
</tr>
<tr>
<td align="center">Shift + F7</td>
<td align="center">智能步入</td>
</tr>
<tr>
<td align="center">Alt + Shift + F7</td>
<td align="center">强制步入</td>
</tr>
<tr>
<td align="center">F8</td>
<td align="center">在 Debug 模式下，步过，不进入当前方法体内</td>
</tr>
<tr>
<td align="center">Shift + F8</td>
<td align="center">步出</td>
</tr>
<tr>
<td align="center">Alt + Shift + F8</td>
<td align="center">强制步过</td>
</tr>
<tr>
<td align="center">alt + F8</td>
<td align="center">在 Debug 模式下，选中查看值</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + F8</td>
<td align="center">查看断点</td>
</tr>
<tr>
<td align="center">F9</td>
<td align="center">在 Debug 模式下，恢复程序运行</td>
</tr>
<tr>
<td align="center">Alt +F9</td>
<td align="center">运行至光标的位置</td>
</tr>
<tr>
<td align="center">Ctrl + Alt+ F9</td>
<td align="center">强制运行至光标处</td>
</tr>
<tr>
<td align="center">Alt + F10</td>
<td align="center">定位到断点</td>
</tr>
</tbody></table>
<h2 id="重构快捷键"><a href="#重构快捷键" class="headerlink" title="重构快捷键"></a>重构快捷键</h2><table>
<thead>
<tr>
<th align="center">重构快捷键</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shift + F6</td>
<td align="center">重命名</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + C</td>
<td align="center">抽取常量</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + F</td>
<td align="center">抽取字段</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + M</td>
<td align="center">抽取方法</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + P</td>
<td align="center">抽取参数</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + V</td>
<td align="center">抽取变量</td>
</tr>
</tbody></table>
<h2 id="其他类快捷键"><a href="#其他类快捷键" class="headerlink" title="其他类快捷键"></a>其他类快捷键</h2><table>
<thead>
<tr>
<th align="center">其他</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + C</td>
<td align="center">复制文件名</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + C</td>
<td align="center">复制文件的完整路径</td>
</tr>
<tr>
<td align="center">Ctrl + E</td>
<td align="center">显示最近打开的文件</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + E</td>
<td align="center">显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td align="center">Ctrl + P</td>
<td align="center">方法参数提示</td>
</tr>
<tr>
<td align="center">Ctrl + Q</td>
<td align="center">可以看到当前方法的声明</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + Space</td>
<td align="center">类名或接口名提示</td>
</tr>
<tr>
<td align="center">Ctrl + F12</td>
<td align="center">显示当前文件的结构</td>
</tr>
<tr>
<td align="center">Ctrl + H</td>
<td align="center">显示当前类的结构图</td>
</tr>
<tr>
<td align="center">Ctrl + Q</td>
<td align="center">显示注释文档信息</td>
</tr>
<tr>
<td align="center">Shift+Shift</td>
<td align="center">弹出 Search Everywhere 弹出层，查找任任内容</td>
</tr>
<tr>
<td align="center">Ctrl + [</td>
<td align="center">移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td align="center">Ctrl + ]</td>
<td align="center">移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td align="center">Ctrl + K</td>
<td align="center">版本控制提交项目</td>
</tr>
<tr>
<td align="center">Ctrl + T</td>
<td align="center">版本控制更新项目</td>
</tr>
<tr>
<td align="center">Ctrl + Tab</td>
<td align="center">切换编辑窗口</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="靓仔灬很忙"
      src="/images/WechatIMG1.jpeg">
  <p class="site-author-name" itemprop="name">靓仔灬很忙</p>
  <div class="site-description" itemprop="description">同样是第一次做人，凭什么让我活在别人制定的规则里；All i want is just to be myself!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Floating-Dreamm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Floating-Dreamm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cl516729483@outlook.com" title="E-Mail → mailto:cl516729483@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">靓仔灬很忙</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">81k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:13</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
